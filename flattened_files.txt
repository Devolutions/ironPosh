--- File: crates/pwsh-core/Cargo.toml ---
[package]
name = "pwsh-core"
version = "0.1.0"
edition = "2024"

[dependencies]
hyper = "1.6.0"
thiserror = "2.0.12"
uuid = { version = "1.17.0", features = ["v4"] }
protocol-winrm = {path = "../protocol-winrm"}
protocol-powershell-remoting = {path = "../protocol-powershell-remoting"}
xml = { path = "../xml" }
typed-builder = "0.21.0"
base64 = "0.22.1"
tracing = "0.1.41"


[dev-dependencies]
ureq = "2"
tracing-subscriber = {version = "0.3.19", features = ["env-filter"]}
tokio = { version = "1", features = ["full"] }
anyhow = "1"

--- File: crates/pwsh-core/examples/README.md ---
# WinRM PowerShell Client Example

## Usage

The `connect.rs` example demonstrates a basic WinRM PowerShell client that connects to a remote Windows server.

### Configuration

Edit the following lines in `connect.rs` to match your test server:

```rust
let server = ServerAddress::Domain("your-server-ip".to_string()); // Change to your server
let port = 5985; // or 5986 for HTTPS
let scheme = Scheme::Http; // or Scheme::Https
let auth = Authentication::Basic {
    username: "your-username".to_string(),
    password: "your-password".to_string(),
};
```

### Running

```bash
cargo run -p pwsh-core --example connect
```

### Current Status

- ✅ Generates proper PowerShell negotiation messages (SessionCapability, InitRunspacePool)
- ✅ Fragments messages according to PowerShell remoting protocol
- ✅ Builds WS-Management SOAP envelopes
- ✅ Makes initial shell creation request
- ✅ Makes receive request
- ⚠️ ConnectReceiveCycle state hits `todo!()` (needs implementation)

### Expected Flow

1. **Idle → Connecting**: Sends shell creation request with PowerShell negotiation
2. **Connecting → ConnectReceiveCycle**: Processes shell creation response, sends receive request
3. **ConnectReceiveCycle**: Currently hits `todo!()` - needs to parse receive response and complete handshake

The client is ready for testing against real PowerShell servers and will help debug the protocol implementation step by step.

--- File: crates/pwsh-core/examples/connect/config.rs ---
use std::net::Ipv4Addr;

use pwsh_core::connector::{Authentication, ConnectorConfig, Scheme, http::ServerAddress};
use tracing_subscriber::EnvFilter;

/// Initialize logging with file output
pub fn init_logging() -> anyhow::Result<()> {
    let log_file = std::fs::File::create("winrm_client.log")?;
    tracing_subscriber::fmt::SubscriberBuilder::default()
        // Hide HTTP-related logs by setting them to ERROR level
        // Focus on our PowerShell remoting logic
        .with_env_filter(EnvFilter::new("pwsh_core=debug,protocol_powershell_remoting=debug,protocol_winrm=info,ureq=error"))
        .with_max_level(tracing::Level::DEBUG)
        .with_target(false)
        .with_line_number(true)
        .with_file(true)
        .with_writer(log_file)
        .init();
    Ok(())
}

/// Create the default connector configuration
pub fn create_connector_config() -> ConnectorConfig {
    // Configuration - modify these for your test server
    let server = ServerAddress::Ip(std::net::IpAddr::V4(Ipv4Addr::new(10, 10, 0, 3))); // Change to your server
    let port = 5985;
    let scheme = Scheme::Http;
    let auth = Authentication::Basic {
        username: "Administrator".to_string(),
        password: "DevoLabs123!".to_string(),
    };

    ConnectorConfig {
        server: (server, port),
        scheme,
        authentication: auth,
    }
}


--- File: crates/pwsh-core/examples/connect/connection.rs ---
use anyhow::Context;
use pwsh_core::connector::active_session::ActiveSession;
use pwsh_core::connector::{Connector, ConnectorConfig, ConnectorStepResult};
use tracing::{info, info_span, warn};

use crate::http_client::make_http_request;

/// Establish connection to the PowerShell remote server
pub async fn establish_connection(
    config: ConnectorConfig,
) -> anyhow::Result<(
    ActiveSession,
    pwsh_core::connector::http::HttpRequest<String>,
)> {
    let mut connector = Connector::new(config);
    info!("Created connector, starting connection...");

    let mut response = None;
    let _span = info_span!("ConnectionLoop").entered();

    let (active_session, next_request) = loop {
        let step_result = connector
            .step(response.take())
            .context("Failed to step through connector")?;

        info!(step_result = ?step_result.name(), "Processing step result");

        match step_result {
            ConnectorStepResult::SendBack(http_request) => {
                // Make the HTTP request (using ureq for simplicity in example)
                response = Some(make_http_request(&http_request).await?);
            }
            ConnectorStepResult::SendBackError(e) => {
                warn!("Connection step failed: {}", e);
                anyhow::bail!("Connection failed: {}", e);
            }
            ConnectorStepResult::Connected {
                active_session,
                next_receive_request,
            } => {
                break (active_session, next_receive_request);
            }
        }
    };

    drop(_span);
    Ok((active_session, next_request))
}


--- File: crates/pwsh-core/examples/connect/http_client.rs ---
use tracing::{debug, info};

/// Make an HTTP request using ureq
pub async fn make_http_request(
    request: &pwsh_core::connector::http::HttpRequest<String>,
) -> Result<pwsh_core::connector::http::HttpResponse<String>, anyhow::Error> {
    info!("Making HTTP request to: {}", request.url);
    debug!("Request headers: {:?}", request.headers);
    debug!(
        "Request body length: {:?}",
        request.body.as_ref().map(|b| b.len())
    );

    // Build the HTTP client request
    let mut ureq_request = match request.method {
        pwsh_core::connector::http::Method::Post => ureq::post(&request.url),
        pwsh_core::connector::http::Method::Get => ureq::get(&request.url),
        pwsh_core::connector::http::Method::Put => ureq::put(&request.url),
        pwsh_core::connector::http::Method::Delete => ureq::delete(&request.url),
    };

    // Add headers
    for (name, value) in &request.headers {
        ureq_request = ureq_request.set(name, value);
    }

    // Add cookie if present
    if let Some(cookie) = &request.cookie {
        ureq_request = ureq_request.set("Cookie", cookie);
    }

    // Make the request
    let response = if let Some(body) = &request.body {
        ureq_request.send_string(body)?
    } else {
        ureq_request.call()?
    };

    // Read response
    let response_body = response.into_string()?;
    debug!("Response body length: {}", response_body.len());

    // Return as HttpResponse with proper response format
    Ok(pwsh_core::connector::http::HttpResponse {
        status_code: 200,
        headers: vec![],
        body: Some(response_body),
    })
}


--- File: crates/pwsh-core/examples/connect/main.rs ---
mod config;
mod connection;
mod http_client;
mod network;
mod types;
mod user_input;

use anyhow::Context;
use pwsh_core::connector::ActiveSessionOutput;
use pwsh_core::connector::active_session::UserEvent;
use tokio::sync::{mpsc, oneshot};
use tracing::{error, info, instrument, warn};

use config::{create_connector_config, init_logging};
use connection::establish_connection;
use network::spawn_network_handler;
use tracing_subscriber::fmt::format;
use types::NextStep;
use user_input::spawn_user_input_handler;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    init_logging()?;
    let _span = tracing::span!(tracing::Level::INFO, "main").entered();
    info!("Starting WinRM PowerShell client");

    // Create configuration and establish connection
    let config = create_connector_config();
    let (active_session, next_request) = establish_connection(config).await?;
    info!("Runspace pool is now open and ready for operations!");

    // Set up communication channels
    let (network_request_tx, network_request_rx) = mpsc::channel(2);
    let (network_response_tx, network_response_rx) = mpsc::channel(2);
    let (user_request_tx, user_request_rx) = mpsc::channel(2);

    // Spawn network handler
    let handle = spawn_network_handler(network_request_rx, network_response_tx);

    // Set up pipeline creation
    let (pipeline_tx, pipeline_rx) = oneshot::channel();
    let handle2 = spawn_user_input_handler(user_request_tx.clone(), pipeline_rx);

    // Send initial network request
    network_request_tx
        .send(next_request)
        .await
        .context("Failed to send initial request")?;

    // Run the main event loop
    run_event_loop(
        active_session,
        network_response_rx,
        user_request_rx,
        network_request_tx,
        Some(pipeline_tx),
    )
    .await
    .inspect_err(|e| error!("Error in main event loop: {}", e))?;

    info!("Exiting main function");
    handle.abort();
    handle2.abort();
    drop(_span);
    Ok(())
}

/// Main event loop that processes network responses and user requests
#[instrument(skip_all)]
async fn run_event_loop(
    mut active_session: pwsh_core::connector::active_session::ActiveSession,
    mut network_response_rx: mpsc::Receiver<pwsh_core::connector::http::HttpResponse<String>>,
    mut user_request_rx: mpsc::Receiver<pwsh_core::connector::UserOperation>,
    network_request_tx: mpsc::Sender<pwsh_core::connector::http::HttpRequest<String>>,
    mut pipeline_tx: Option<oneshot::Sender<pwsh_core::powershell::PipelineHandle>>,
) -> anyhow::Result<()> {
    loop {
        let next_step = tokio::select! {
            network_response = network_response_rx.recv() => {
                if let Some(response) = network_response {
                    NextStep::NetworkResponse(response)
                } else {
                    error!("No response received from server");
                    return Err(anyhow::anyhow!("No response received from server"));
                }
            },
            user_request = user_request_rx.recv() => {
                if let Some(user_request) = user_request {
                    NextStep::UserRequest(user_request)
                } else {
                    error!("No user request received");
                    return Err(anyhow::anyhow!("No user request received"));
                }
            },
        };

        info!("Processing next step: {next_step}");

        let step_results = match next_step {
            NextStep::NetworkResponse(http_response) => {
                info!(
                    "Processing network response with body length: {}",
                    http_response.body.as_ref().map(|b| b.len()).unwrap_or(0)
                );

                active_session
                    .accept_server_response(http_response)
                    .map_err(|e| {
                        error!("Failed to accept server response: {:#}", e);
                        e
                    })
                    .context("Failed to accept server response")?
            }
            NextStep::UserRequest(user_operation) => {
                info!("Processing user operation: {:?}", user_operation);

                vec![
                    active_session
                        .accept_client_operation(user_operation)
                        .map_err(|e| {
                            error!("Failed to accept user operation: {:#}", e);
                            e
                        })
                        .context("Failed to accept user operation")?,
                ]
            }
        };

        info!(?step_results, "Received server response, processing...");

        for step_result in step_results {
            info!(?step_result, "Processing step result");
            match step_result {
                ActiveSessionOutput::SendBack(http_requests) => {
                    for http_request in http_requests {
                        network_request_tx
                            .send(http_request)
                            .await
                            .context("Failed to send HTTP request")?;
                    }
                }
                ActiveSessionOutput::SendBackError(e) => {
                    error!("Error in session step: {}", e);
                    return Err(anyhow::anyhow!("Session step failed: {}", e));
                }
                ActiveSessionOutput::UserEvent(event) => match event {
                    UserEvent::PipelineCreated { powershell } => {
                        info!("Pipeline created: {:?}", powershell);
                        let sent = pipeline_tx.take().map(|tx| tx.send(powershell));
                        if let Some(Err(_)) = sent {
                            error!("Failed to send pipeline through channel");
                            return Err(anyhow::anyhow!("Failed to send pipeline through channel"));
                        }
                    }
                },
                ActiveSessionOutput::HostCall(host_call) => {
                    info!("Received host call: method_name='{}', call_id={}", 
                          host_call.method_name, host_call.call_id);
                    
                    let method = host_call.get_param().map_err(|e| {
                        error!("Failed to parse host call parameters: {:#}", e);
                        e
                    })?;
                    
                    info!("Processing host call method: {:?}", method);

                    // Handle the host call and create a response
                    use pwsh_core::host::{HostCallMethodReturn, RawUIMethodReturn};
                    
                    let response = match method {
                        // For GetBufferSize, return a default console buffer size
                        pwsh_core::host::HostCallMethodWithParams::RawUIMethod(
                            pwsh_core::host::RawUIMethodParams::GetBufferSize
                        ) => {
                            info!("Handling GetBufferSize - returning default console size");
                            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferSize(120, 30))
                        }
                        
                        // For WriteProgress, just acknowledge (void return)
                        pwsh_core::host::HostCallMethodWithParams::UIMethod(
                            pwsh_core::host::UIMethodParams::WriteProgress(source_id, record)
                        ) => {
                            info!("Handling WriteProgress - source_id={}, record={}", source_id, record);
                            HostCallMethodReturn::UIMethod(pwsh_core::host::UIMethodReturn::WriteProgress)
                        }
                        
                        // For other methods, return not implemented error for now
                        other => {
                            warn!("Host call method not implemented: {:?}", other);
                            HostCallMethodReturn::Error(pwsh_core::host::HostError::NotImplemented)
                        }
                    };

                    // Submit the response
                    let host_response = host_call.submit_result(response);
                    info!("Created host call response for call_id={}", host_response.call_id);
                    
                    // For now, we're not sending the response back yet - that requires more infrastructure
                    // TODO: Implement sending host call responses back to the server
                }
                ActiveSessionOutput::OperationSuccess => {
                    info!("Operation completed successfully");
                }
                ActiveSessionOutput::PipelineOutput { output, handle: _handle } => {
                    info!("Pipeline output: {}", output);
                    println!("Pipeline output: {}", output);
                }
            }
        }
    }
}


--- File: crates/pwsh-core/examples/connect/mod.rs ---
pub mod config;
pub mod connection;
pub mod http_client;
pub mod main;
pub mod network;
pub mod types;
pub mod user_input;

--- File: crates/pwsh-core/examples/connect/network.rs ---
use tokio::sync::mpsc;
use tracing::{Instrument, error, info_span};

use crate::http_client::make_http_request;

/// Spawn network request handler task
pub fn spawn_network_handler(
    mut network_request_rx: mpsc::Receiver<pwsh_core::connector::http::HttpRequest<String>>,
    network_response_tx: mpsc::Sender<pwsh_core::connector::http::HttpResponse<String>>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(
        async move {
            while let Some(request) = network_request_rx.recv().await {
                let network_response_tx = network_response_tx.clone();
                tokio::spawn(async move {
                    match make_http_request(&request).await {
                        Ok(response) => {
                            if let Err(e) = network_response_tx.send(response).await {
                                error!("Failed to send network response: {}", e);
                            }
                        }
                        Err(e) => {
                            error!("HTTP request failed: {}", e);
                        }
                    }
                });
            }
        }
        .instrument(info_span!("NetworkRequestHandler")),
    )
}


--- File: crates/pwsh-core/examples/connect/types.rs ---
use std::fmt;

use pwsh_core::connector::UserOperation;

/// Represents the next step in the event loop
#[derive(Debug)]
pub enum NextStep {
    NetworkResponse(pwsh_core::connector::http::HttpResponse<String>),
    UserRequest(UserOperation),
}

impl fmt::Display for NextStep {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            NextStep::NetworkResponse(_) => write!(f, "NetworkResponse"),
            NextStep::UserRequest(_) => write!(f, "UserRequest"),
        }
    }
}


--- File: crates/pwsh-core/examples/connect/user_input.rs ---
use pwsh_core::connector::active_session::PowershellOperations;
use pwsh_core::pipeline::PipelineCommand;
use pwsh_core::powershell::PipelineHandle;
use pwsh_core::{connector::UserOperation, powershell::PipelineOutputType};
use tokio::io::AsyncBufReadExt;
use tokio::sync::mpsc;
use tracing::{Instrument, error, info, info_span};

/// Handle user input for PowerShell commands
pub async fn handle_user_input(
    user_request_tx: mpsc::Sender<UserOperation>,
    pipeline: PipelineHandle,
) {
    info!("Pipeline ready! Enter PowerShell commands (type 'exit' to quit):");

    let stdin = tokio::io::stdin();
    let mut reader = tokio::io::BufReader::new(stdin);
    let mut line = String::new();

    loop {
        print!("> ");
        std::io::Write::flush(&mut std::io::stdout()).unwrap();

        line.clear();
        match reader.read_line(&mut line).await {
            Ok(0) => break, // EOF
            Ok(_) => {
                let command = line.trim().to_string();
                if command.to_lowercase() == "exit" {
                    info!("Exiting...");
                    break;
                }
                if !command.is_empty() {
                    // Add the script to the pipeline
                    if let Err(e) = user_request_tx
                        .send(UserOperation::OperatePipeline {
                            powershell: pipeline,
                            operation: PowershellOperations::AddCommand {
                                command: PipelineCommand::new_script(command),
                            },
                        })
                        .await
                    {
                        error!("Failed to send operation: {}", e);
                        break;
                    }

                    // Invoke the pipeline
                    if let Err(e) = user_request_tx
                        .send(UserOperation::InvokePipeline {
                            powershell: pipeline,
                            output_type: PipelineOutputType::Streamed,
                        })
                        .await
                    {
                        error!("Failed to send invoke: {}", e);
                        break;
                    }
                }
            }
            Err(e) => {
                error!("Failed to read input: {}", e);
                break;
            }
        }
    }
}

/// Spawn user input handler task
pub fn spawn_user_input_handler(
    user_request_tx: mpsc::Sender<UserOperation>,
    pipeline_rx: tokio::sync::oneshot::Receiver<PipelineHandle>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(
        async move {
            info!("Creating initial pipeline...");
            if let Err(e) = user_request_tx.send(UserOperation::CreatePipeline).await {
                error!("Failed to send create pipeline request: {}", e);
                return;
            }

            // Wait for pipeline to be created
            match pipeline_rx.await {
                Ok(pipeline) => {
                    handle_user_input(user_request_tx, pipeline).await;
                }
                Err(e) => {
                    error!("Failed to receive pipeline: {}", e);
                }
            }
        }
        .instrument(info_span!("UserInputHandler")),
    )
}


--- File: crates/pwsh-core/src/connector/active_session.rs ---
use crate::{
    connector::http::{HttpBuilder, HttpRequest, HttpResponse},
    host::{self, HostCallRequest, HostCallType},
    pipeline::{ParameterValue, PipelineCommand},
    powershell::{PipelineHandle, PipelineOutputType},
    runspace_pool::{RunspacePool, pool::AcceptResponsResult},
};
use protocol_powershell_remoting::{PipelineOutput, PsValue};
use tracing::{debug, error, instrument};

#[derive(Debug, PartialEq, Eq)]
pub enum UserEvent {
    PipelineCreated { powershell: PipelineHandle },
}

#[derive(Debug)]
pub enum ActiveSessionOutput {
    SendBack(Vec<HttpRequest<String>>),
    SendBackError(crate::PwshCoreError),
    UserEvent(UserEvent),
    HostCall(HostCallRequest),
    PipelineOutput {
        output: PipelineOutput,
        handle: PipelineHandle,
    },
    OperationSuccess,
}

impl PartialEq for ActiveSessionOutput {
    fn eq(&self, other: &Self) -> bool {
        self.priority() == other.priority()
    }
}

impl Eq for ActiveSessionOutput {}

impl PartialOrd for ActiveSessionOutput {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for ActiveSessionOutput {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.priority().cmp(&other.priority())
    }
}

impl ActiveSessionOutput {
    pub fn priority(&self) -> u8 {
        match self {
            ActiveSessionOutput::HostCall { .. } => 1,
            ActiveSessionOutput::SendBack(_) => 2,
            ActiveSessionOutput::SendBackError(_) => 3,
            ActiveSessionOutput::UserEvent(_) => 4,
            ActiveSessionOutput::PipelineOutput { .. } => 5,
            ActiveSessionOutput::OperationSuccess => 6,
        }
    }
}

#[derive(Debug)]
pub enum PowershellOperations {
    AddCommand { command: PipelineCommand },
    AddArgument(String),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum HostCallScope {
    Pipeline { command_id: uuid::Uuid },
    RunspacePool,
}

impl From<HostCallType> for HostCallScope {
    fn from(host_call_type: HostCallType) -> Self {
        match host_call_type {
            HostCallType::Pipeline { id } => HostCallScope::Pipeline { command_id: id },
            HostCallType::RunspacePool => HostCallScope::RunspacePool,
        }
    }
}

#[derive(Debug)]
pub enum UserOperation {
    CreatePipeline,
    OperatePipeline {
        powershell: PipelineHandle,
        operation: PowershellOperations,
    },
    InvokePipeline {
        powershell: PipelineHandle,
        output_type: PipelineOutputType,
    },
    /// Reply to a server-initiated host call (PipelineHostCall or RunspacePoolHostCall)
    SubmitHostResponse {
        scope: HostCallScope,
        call_id: i64,
        method_id: i32,
        method_name: String,
        result: Option<PsValue>,
        error: Option<PsValue>,
    },
    /// Allow UI to abort a pending prompt cleanly (timeout, user cancelled)
    CancelHostCall {
        scope: HostCallScope,
        call_id: i64,
        reason: Option<String>,
    },
}

/// ActiveSession manages post-connection operations
#[derive(Debug)]
pub struct ActiveSession {
    runspace_pool: RunspacePool,
    http_builder: HttpBuilder,
    /// Tracks pending host calls by (scope, call_id) to validate responses
    pending_host_calls: std::collections::HashMap<(HostCallScope, i64), ()>,
}

impl ActiveSession {
    pub fn new(runspace_pool: RunspacePool, http_builder: HttpBuilder) -> Self {
        Self {
            runspace_pool,
            http_builder,
            pending_host_calls: std::collections::HashMap::new(),
        }
    }

    /// Handle a client-initiated operation
    pub fn accept_client_operation(
        &mut self,
        operation: UserOperation,
    ) -> Result<ActiveSessionOutput, crate::PwshCoreError> {
        match operation {
            UserOperation::CreatePipeline => {
                Ok(ActiveSessionOutput::UserEvent(UserEvent::PipelineCreated {
                    powershell: self.runspace_pool.init_pipeline(),
                }))
            }
            UserOperation::OperatePipeline {
                powershell,
                operation,
            } => {
                match operation {
                    PowershellOperations::AddCommand { command } => {
                        self.runspace_pool.add_command(powershell, command)?;
                    }
                    PowershellOperations::AddArgument(arg) => {
                        self.runspace_pool.add_switch_parameter(powershell, arg)?;
                    }
                }
                Ok(ActiveSessionOutput::OperationSuccess)
            }
            UserOperation::InvokePipeline {
                powershell,
                output_type,
            } => {
                let command_request = self
                    .runspace_pool
                    .invoke_pipeline_request(powershell, output_type);
                match command_request {
                    Ok(request) => {
                        let response = self.http_builder.post("/wsman", request);
                        Ok(ActiveSessionOutput::SendBack(vec![response]))
                    }
                    Err(e) => Ok(ActiveSessionOutput::SendBackError(e)),
                }
            }
            UserOperation::SubmitHostResponse {
                scope,
                call_id,
                method_id,
                method_name,
                result,
                error,
            } => {
                // Validate that this host call is actually pending
                let key = (scope.clone(), call_id);
                if !self.pending_host_calls.contains_key(&key) {
                    return Err(crate::PwshCoreError::InvalidState(
                        "Host call not found or already completed",
                    ));
                }

                // Remove from pending calls
                self.pending_host_calls.remove(&key);

                // Create the appropriate host response message based on scope
                match scope {
                    HostCallScope::Pipeline { command_id } => self.send_pipeline_host_response(
                        command_id,
                        call_id,
                        method_id,
                        method_name,
                        result,
                        error,
                    ),
                    HostCallScope::RunspacePool => self.send_runspace_pool_host_response(
                        call_id,
                        method_id,
                        method_name,
                        result,
                        error,
                    ),
                }
            }
            UserOperation::CancelHostCall {
                scope,
                call_id,
                reason: _reason,
            } => {
                // Remove from pending calls if it exists
                let key = (scope.clone(), call_id);
                self.pending_host_calls.remove(&key);

                // For cancellation, send an error response
                let error_msg = format!("Host call {call_id} was cancelled");
                let error = Some(PsValue::Primitive(
                    protocol_powershell_remoting::PsPrimitiveValue::Str(error_msg),
                ));

                match scope {
                    HostCallScope::Pipeline { command_id } => self.send_pipeline_host_response(
                        command_id,
                        call_id,
                        0,
                        "Cancelled".to_string(),
                        None,
                        error,
                    ),
                    HostCallScope::RunspacePool => self.send_runspace_pool_host_response(
                        call_id,
                        0,
                        "Cancelled".to_string(),
                        None,
                        error,
                    ),
                }
            }
        }
    }

    /// Handle a server response
    #[instrument(skip(self, response))]
    pub fn accept_server_response(
        &mut self,
        response: HttpResponse<String>,
    ) -> Result<Vec<ActiveSessionOutput>, crate::PwshCoreError> {
        let body = response.body.ok_or(crate::PwshCoreError::InvalidState(
            "Expected a body in server response",
        ))?;

        debug!("Response body length: {}", body.len());

        let results = self.runspace_pool.accept_response(body).map_err(|e| {
            error!("RunspacePool.accept_response failed: {:#}", e);
            e
        })?;

        let mut step_output = Vec::new();
        debug!(?results, "RunspacePool accept_response results");

        for (index, result) in results.into_iter().enumerate() {
            debug!("Processing result {}: {:?}", index, result);

            match result {
                AcceptResponsResult::ReceiveResponse { desired_streams } => {
                    debug!(
                        "Creating receive request for streams: {:?}",
                        desired_streams
                    );
                    let receive_request = self
                        .runspace_pool
                        .fire_receive(desired_streams)
                        .map_err(|e| {
                            error!("Failed to create receive request: {:#}", e);
                            e
                        })?;
                    let response = self.http_builder.post("/wsman", receive_request);
                    step_output.push(ActiveSessionOutput::SendBack(vec![response]));
                }
                AcceptResponsResult::NewPipeline(pipeline) => {
                    debug!("New pipeline created: {:?}", pipeline);
                    step_output.push(ActiveSessionOutput::UserEvent(UserEvent::PipelineCreated {
                        powershell: pipeline,
                    }));
                }
                AcceptResponsResult::HostCall(host_call) => {
                    debug!(host_call = ?host_call, "Received host call request");
                    // Track this host call as pending
                    let scope: HostCallScope = host_call.call_type.clone().into();
                    let key = (scope, host_call.call_id);
                    self.pending_host_calls.insert(key, ());

                    step_output.push(ActiveSessionOutput::HostCall(host_call));
                }
                AcceptResponsResult::PipelineOutput { output, handle } => {
                    debug!("Pipeline output: {:?}", output);
                    step_output.push(ActiveSessionOutput::PipelineOutput {
                        output,
                        handle: handle.clone(),
                    });
                }
            }
        }

        step_output.sort();
        debug!("Returning {} step outputs", step_output.len());
        Ok(step_output)
    }

    /// Send a pipeline host response back to the server
    fn send_pipeline_host_response(
        &mut self,
        command_id: uuid::Uuid,
        call_id: i64,
        method_id: i32,
        method_name: String,
        result: Option<PsValue>,
        error: Option<PsValue>,
    ) -> Result<ActiveSessionOutput, crate::PwshCoreError> {
        // Only send a response if we have a result or error to report
        // Void methods (like Write, WriteLine, WriteProgress) don't need responses
        if result.is_none() && error.is_none() {
            return Ok(ActiveSessionOutput::OperationSuccess);
        }

        use protocol_powershell_remoting::PipelineHostResponse;

        let host_response = PipelineHostResponse::builder()
            .call_id(call_id)
            .method_id(method_id)
            .method_name(method_name)
            .method_result_opt(result)
            .method_exception_opt(error)
            .build();

        // Fragment and send via RunspacePool
        let request = self
            .runspace_pool
            .send_pipeline_host_response(command_id, host_response)?;
        let http_response = self.http_builder.post("/wsman", request);

        // Queue a receive after sending the response
        let receive_request = self.runspace_pool.fire_receive(
            crate::runspace_pool::DesiredStream::pipeline_streams(command_id),
        )?;
        let receive_http_response = self.http_builder.post("/wsman", receive_request);

        Ok(ActiveSessionOutput::SendBack(vec![
            http_response,
            receive_http_response,
        ]))
    }

    /// Send a runspace pool host response back to the server
    fn send_runspace_pool_host_response(
        &mut self,
        call_id: i64,
        method_id: i32,
        method_name: String,
        result: Option<PsValue>,
        error: Option<PsValue>,
    ) -> Result<ActiveSessionOutput, crate::PwshCoreError> {
        // Only send a response if we have a result or error to report
        // Void methods (like Write, WriteLine, WriteProgress) don't need responses
        if result.is_none() && error.is_none() {
            return Ok(ActiveSessionOutput::OperationSuccess);
        }

        use protocol_powershell_remoting::RunspacePoolHostResponse;

        let host_response = RunspacePoolHostResponse::builder()
            .call_id(call_id)
            .method_id(method_id)
            .method_name(method_name)
            .method_result_opt(result)
            .method_exception_opt(error)
            .build();

        // Fragment and send via RunspacePool
        let request = self
            .runspace_pool
            .send_runspace_pool_host_response(host_response)?;
        let http_response = self.http_builder.post("/wsman", request);

        // Queue a receive after sending the response
        let receive_request = self
            .runspace_pool
            .fire_receive(crate::runspace_pool::DesiredStream::runspace_pool_streams())?;
        let receive_http_response = self.http_builder.post("/wsman", receive_request);

        Ok(ActiveSessionOutput::SendBack(vec![
            http_response,
            receive_http_response,
        ]))
    }
}


--- File: crates/pwsh-core/src/connector/http.rs ---
use base64::Engine;
use std::{fmt::Display, net::IpAddr};

#[derive(Debug, Clone)]
pub enum ServerAddress {
    Ip(IpAddr),
    Domain(String),
}

impl Display for ServerAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ServerAddress::Ip(ip) => write!(f, "{ip}"),
            ServerAddress::Domain(domain) => write!(f, "{domain}"),
        }
    }
}

#[derive(Debug, Clone)]
pub enum Method {
    Get,
    Post,
    Put,
    Delete,
}

#[derive(Debug, Clone)]
pub struct HttpRequest<T> {
    pub method: Method,
    pub url: String,
    pub headers: Vec<(String, String)>,
    pub body: Option<T>,
    pub cookie: Option<String>,
}

impl<T> HttpRequest<T> {
    pub fn with_headers(mut self, headers: Vec<(String, String)>) -> Self {
        self.headers.extend(headers);
        self
    }
}

#[derive(Debug, Clone)]
pub struct HttpResponse<T> {
    pub status_code: u16,
    pub headers: Vec<(String, String)>,
    pub body: Option<T>,
}

#[derive(Debug)]
pub struct HttpBuilder {
    pub(crate) server: ServerAddress,
    pub(crate) port: u16,
    pub(crate) scheme: crate::connector::Scheme,
    pub(crate) authentication: crate::connector::Authentication,
    pub(crate) cookie: Option<String>,
}

impl HttpBuilder {
    pub fn new(
        server: ServerAddress,
        port: u16,
        scheme: crate::connector::Scheme,
        authentication: crate::connector::Authentication,
    ) -> Self {
        Self {
            server,
            port,
            scheme,
            authentication,
            cookie: None,
        }
    }

    pub fn with_cookie(mut self, cookie: String) -> Self {
        self.cookie = Some(cookie);
        self
    }

    fn build_url(&self, path: &str) -> String {
        let scheme_str = match self.scheme {
            crate::connector::Scheme::Http => "http",
            crate::connector::Scheme::Https => "https",
        };

        let server_str = match &self.server {
            ServerAddress::Ip(ip) => ip.to_string(),
            ServerAddress::Domain(domain) => domain.clone(),
        };

        format!("{}://{}:{}{}", scheme_str, server_str, self.port, path)
    }

    fn build_auth_header(&self) -> String {
        match &self.authentication {
            crate::connector::Authentication::Basic { username, password } => {
                let credentials = format!("{username}:{password}");
                let encoded = base64::engine::general_purpose::STANDARD.encode(credentials);
                format!("Basic {encoded}")
            }
        }
    }

    fn build_host_header(&self) -> String {
        match &self.server {
            ServerAddress::Ip(ip) => format!("{}:{}", ip, self.port),
            ServerAddress::Domain(domain) => format!("{}:{}", domain, self.port),
        }
    }

    fn build_headers(&self, body: Option<&str>) -> Vec<(String, String)> {
        let mut headers = vec![
            ("Host".to_string(), self.build_host_header()),
            (
                "Content-Type".to_string(),
                "application/soap+xml; charset=utf-8".to_string(),
            ),
            ("Authorization".to_string(), self.build_auth_header()),
        ];

        if let Some(body_content) = body {
            headers.push(("Content-Length".to_string(), body_content.len().to_string()));
        } else {
            headers.push(("Content-Length".to_string(), "0".to_string()));
        }

        if let Some(cookie) = &self.cookie {
            headers.push(("Cookie".to_string(), cookie.clone()));
        }

        headers
    }

    pub fn post(&self, path: &str, body: String) -> HttpRequest<String> {
        HttpRequest {
            method: Method::Post,
            url: self.build_url(path),
            headers: self.build_headers(Some(&body)),
            body: Some(body),
            cookie: self.cookie.clone(),
        }
    }

    pub fn get(&self, path: &str) -> HttpRequest<String> {
        HttpRequest {
            method: Method::Get,
            url: self.build_url(path),
            headers: self.build_headers(None),
            body: None,
            cookie: self.cookie.clone(),
        }
    }

    pub fn put(&self, path: &str, body: String) -> HttpRequest<String> {
        HttpRequest {
            method: Method::Put,
            url: self.build_url(path),
            headers: self.build_headers(Some(&body)),
            body: Some(body),
            cookie: self.cookie.clone(),
        }
    }

    pub fn delete(&self, path: &str) -> HttpRequest<String> {
        HttpRequest {
            method: Method::Delete,
            url: self.build_url(path),
            headers: self.build_headers(None),
            body: None,
            cookie: self.cookie.clone(),
        }
    }
}


--- File: crates/pwsh-core/src/connector/mod.rs ---
use std::sync::Arc;

use protocol_powershell_remoting::HostInfo;
use protocol_winrm::ws_management::WsMan;
use tracing::{info, instrument, warn};

use crate::{
    connector::http::{HttpBuilder, HttpRequest, HttpResponse, ServerAddress},
    runspace_pool::{
        DesiredStream, ExpectShellCreated, RunspacePool, RunspacePoolCreator, RunspacePoolState,
        pool::AcceptResponsResult,
    },
};

pub use active_session::{ActiveSession, ActiveSessionOutput, UserOperation};
pub mod active_session;
pub mod http;

#[derive(Debug, Clone)]
pub enum Authentication {
    Basic { username: String, password: String },
    // TODO: Add SSPI
}

#[derive(Debug, Clone)]
pub enum Scheme {
    Http,
    Https,
}

pub struct ConnectorConfig {
    pub server: (ServerAddress, u16),
    pub scheme: Scheme,
    pub authentication: Authentication,
}

impl ConnectorConfig {
    pub fn wsman_to(&self, query: Option<&str>) -> String {
        let query = query
            .map(|q| format!("?{}", q.trim_start_matches('?')))
            .unwrap_or_default();

        match &self.scheme {
            Scheme::Http => format!("http://{}:{}/wsman{}", self.server.0, self.server.1, query),
            Scheme::Https => format!("https://{}:{}/wsman{}", self.server.0, self.server.1, query),
        }
    }
}

#[derive(Debug)]
pub enum ConnectorStepResult {
    SendBack(HttpRequest<String>),
    SendBackError(crate::PwshCoreError),
    Connected {
        active_session: ActiveSession,
        next_receive_request: HttpRequest<String>,
    },
}

impl ConnectorStepResult {
    pub fn name(&self) -> &'static str {
        match self {
            ConnectorStepResult::SendBack(_) => "SendBack",
            ConnectorStepResult::SendBackError(_) => "SendBackError",
            ConnectorStepResult::Connected { .. } => "Connected",
        }
    }
}

impl ConnectorStepResult {
    pub fn priority(&self) -> u8 {
        match self {
            ConnectorStepResult::SendBack(_) => 0,
            ConnectorStepResult::SendBackError(_) => 1,
            ConnectorStepResult::Connected { .. } => 2,
        }
    }
}

#[derive(Default, Debug)]
pub enum ConnectorState {
    Idle,
    #[default]
    Taken,
    Connecting {
        expect_shell_created: ExpectShellCreated,
        http_builder: HttpBuilder,
    },
    ConnectReceiveCycle {
        runspace_pool: RunspacePool,
        http_builder: HttpBuilder,
    },
    Connected,
    Failed,
}

impl ConnectorState {
    fn state_name(&self) -> &'static str {
        match self {
            ConnectorState::Idle => "Idle",
            ConnectorState::Taken => "Taken",
            ConnectorState::Connecting { .. } => "Connecting",
            ConnectorState::ConnectReceiveCycle { .. } => "ConnectReceiveCycle",
            ConnectorState::Connected => "Connected",
            ConnectorState::Failed => "Failed",
        }
    }
}

pub struct Connector {
    state: ConnectorState,
    config: ConnectorConfig,
}

impl Connector {
    pub fn new(config: ConnectorConfig) -> Self {
        Self {
            state: ConnectorState::Idle,
            config,
        }
    }

    pub fn set_state(&mut self, state: ConnectorState) {
        info!(state = state.state_name(), "Setting connector state");
        self.state = state;
    }

    #[instrument(skip(self, server_response), name = "Connector::step")]
    pub fn step(
        &mut self,
        server_response: Option<HttpResponse<String>>,
    ) -> Result<ConnectorStepResult, crate::PwshCoreError> {
        let state = std::mem::take(&mut self.state);

        let (new_state, response) = match state {
            ConnectorState::Taken => {
                return Err(crate::PwshCoreError::UnlikelyToHappen(
                    "Connector should not be in Taken state when stepping",
                ));
            }
            ConnectorState::Failed => {
                warn!("Connector is in Failed state, cannot proceed");
                return Err(crate::PwshCoreError::InvalidState(
                    "Connector is in Failed state",
                ));
            }
            ConnectorState::Connected => {
                warn!("Connector is already connected, cannot step further");
                return Err(crate::PwshCoreError::InvalidState(
                    "Connector is already connected",
                ));
            }
            ConnectorState::Idle => {
                debug_assert!(
                    server_response.is_none(),
                    "Request should be None in Idle state"
                );
                let connection = Arc::new(WsMan::builder().to(self.config.wsman_to(None)).build());
                let runspace_pool = RunspacePoolCreator::builder()
                    .host_info(HostInfo::builder().build())
                    .build()
                    .into_runspace_pool(connection);

                let http_builder = HttpBuilder::new(
                    self.config.server.0.clone(),
                    self.config.server.1,
                    self.config.scheme.clone(),
                    self.config.authentication.clone(),
                );

                let (xml_body, expect_shell_created) = runspace_pool.open()?;

                let response = http_builder.post("/wsman", xml_body);

                let new_state = ConnectorState::Connecting {
                    expect_shell_created,
                    http_builder,
                };

                (new_state, ConnectorStepResult::SendBack(response))
            }
            ConnectorState::Connecting {
                expect_shell_created,
                http_builder,
            } => {
                info!("Processing Connecting state");
                let response = server_response.ok_or({
                    crate::PwshCoreError::InvalidState("Expected a response in Connecting state")
                })?;

                let body = response.body.ok_or({
                    crate::PwshCoreError::InvalidState("Expected a body in Connecting state")
                })?;

                let mut runspace_pool = expect_shell_created.accept(body)?;

                let receive_request =
                    runspace_pool.fire_receive(DesiredStream::runspace_pool_streams())?;

                let response = http_builder.post("/wsman", receive_request);

                let new_state = ConnectorState::ConnectReceiveCycle {
                    runspace_pool,
                    http_builder,
                };

                (new_state, ConnectorStepResult::SendBack(response))
            }
            ConnectorState::ConnectReceiveCycle {
                mut runspace_pool,
                http_builder,
            } => {
                let response = server_response.ok_or({
                    crate::PwshCoreError::InvalidState(
                        "Expected a response in ConnectReceiveCycle state",
                    )
                })?;

                let body = response.body.ok_or({
                    crate::PwshCoreError::InvalidState(
                        "Expected a body in ConnectReceiveCycle state",
                    )
                })?;

                let accept_response_results = runspace_pool.accept_response(body)?;
                let Some(AcceptResponsResult::ReceiveResponse { desired_streams }) =
                    accept_response_results
                        .into_iter()
                        .find(|r| matches!(r, AcceptResponsResult::ReceiveResponse { .. }))
                else {
                    return Err(crate::PwshCoreError::InvalidState(
                        "Expected ReceiveResponse in ConnectReceiveCycle state",
                    ));
                };

                if let RunspacePoolState::NegotiationSent = runspace_pool.state {
                    let receive_request = runspace_pool.fire_receive(desired_streams)?;
                    let response = http_builder.post("/wsman", receive_request);
                    let new_state = ConnectorState::ConnectReceiveCycle {
                        runspace_pool,
                        http_builder,
                    };
                    (new_state, ConnectorStepResult::SendBack(response))
                } else if let RunspacePoolState::Opened = runspace_pool.state {
                    info!("Connection established successfully - returning ActiveSession");
                    let next_receive_request = runspace_pool.fire_receive(desired_streams)?;
                    let next_http_request = http_builder.post("/wsman", next_receive_request);
                    let active_session = ActiveSession::new(runspace_pool, http_builder);
                    (
                        ConnectorState::Connected,
                        ConnectorStepResult::Connected {
                            active_session,
                            next_receive_request: next_http_request,
                        },
                    )
                } else {
                    warn!("Unexpected RunspacePool state: {:?}", runspace_pool.state);
                    (
                        ConnectorState::Failed,
                        ConnectorStepResult::SendBackError(crate::PwshCoreError::InvalidState(
                            "Unexpected RunspacePool state",
                        )),
                    )
                }
            }
        };

        self.set_state(new_state);
        Ok(response)
    }
}


--- File: crates/pwsh-core/src/host/conversions.rs ---
use super::{
    error::HostError,
    methods::{HostCallMethodWithParams, HostMethodParams, RawUIMethodParams, UIMethodParams},
};

/// Convert HostCallRequest to HostCallMethodWithParams based on method_id and parameters
impl TryFrom<&super::HostCallRequest> for HostCallMethodWithParams {
    type Error = HostError;

    fn try_from(call: &super::HostCallRequest) -> Result<Self, Self::Error> {
        // PowerShell method IDs based on the protocol specification
        // Host methods: 1-10, UI methods: 11-30, RawUI methods: 31-60
        match call.method_id {
            // Host methods (1-10)
            1 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetName,
            )),
            2 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetVersion,
            )),
            3 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetInstanceId,
            )),
            4 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetCurrentCulture,
            )),
            5 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetCurrentUICulture,
            )),
            6 => {
                let exit_code = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::HostMethod(
                    HostMethodParams::SetShouldExit(exit_code),
                ))
            }
            7 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::EnterNestedPrompt,
            )),
            8 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::ExitNestedPrompt,
            )),
            9 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::NotifyBeginApplication,
            )),
            10 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::NotifyEndApplication,
            )),

            // UI methods (11-30)
            11 => Ok(HostCallMethodWithParams::UIMethod(UIMethodParams::ReadLine)),
            12 => Ok(HostCallMethodWithParams::UIMethod(
                UIMethodParams::ReadLineAsSecureString,
            )),
            13 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(UIMethodParams::Write(
                    value,
                )))
            }
            14 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteLine(value),
                ))
            }
            15 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteErrorLine(value),
                ))
            }
            16 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteDebugLine(value),
                ))
            }
            17 => {
                let source_id = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i64())
                    .ok_or(HostError::InvalidParameters)?;
                let record = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteProgress(source_id, record),
                ))
            }
            18 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteVerboseLine(value),
                ))
            }
            19 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteWarningLine(value),
                ))
            }
            20 => {
                let caption = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let descriptions = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string_array())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(UIMethodParams::Prompt(
                    caption,
                    descriptions,
                )))
            }
            21 => {
                let caption = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let message = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let choices = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_string_array())
                    .ok_or(HostError::InvalidParameters)?;
                let default_choice = call
                    .parameters
                    .get(3)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::PromptForChoice(caption, message, choices, default_choice),
                ))
            }
            22 => {
                let caption = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let message = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let user_name = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let target_name = call
                    .parameters
                    .get(3)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::PromptForCredential(caption, message, user_name, target_name),
                ))
            }

            // RawUI methods (31-60)
            31 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetForegroundColor,
            )),
            32 => {
                let color = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetForegroundColor(color),
                ))
            }
            33 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetBackgroundColor,
            )),
            34 => {
                let color = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetBackgroundColor(color),
                ))
            }
            35 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetCursorPosition,
            )),
            36 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetCursorPosition(x, y),
                ))
            }
            37 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetWindowPosition,
            )),
            38 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetWindowPosition(x, y),
                ))
            }
            39 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetCursorSize,
            )),
            40 => {
                let percentage = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetCursorSize(percentage),
                ))
            }
            41 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetBufferSize,
            )),
            42 => {
                let width = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let height = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetBufferSize(width, height),
                ))
            }
            43 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetWindowSize,
            )),
            44 => {
                let width = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let height = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetWindowSize(width, height),
                ))
            }
            45 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetMaxWindowSize,
            )),
            46 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetMaxPhysicalWindowSize,
            )),
            47 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetKeyAvailable,
            )),
            48 => {
                let options = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::ReadKey(options),
                ))
            }
            49 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::FlushInputBuffer,
            )),
            50 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let contents = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetBufferContents(x, y, contents),
                ))
            }
            51 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let width = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let height = call
                    .parameters
                    .get(3)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::GetBufferContents(x, y, width, height),
                ))
            }
            52 => {
                // ScrollBufferContents has complex parameters - simplified for now
                let params: Vec<i32> = call
                    .parameters
                    .iter()
                    .take(6)
                    .filter_map(|p| p.as_i32())
                    .collect();
                let fill = call
                    .parameters
                    .get(6)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;

                if params.len() == 6 {
                    Ok(HostCallMethodWithParams::RawUIMethod(
                        RawUIMethodParams::ScrollBufferContents(
                            params[0], params[1], params[2], params[3], params[4], params[5], fill,
                        ),
                    ))
                } else {
                    Err(HostError::InvalidParameters)
                }
            }

            _ => Err(HostError::NotImplemented),
        }
    }
}


--- File: crates/pwsh-core/src/host/error.rs ---
/// Error type for host operations
#[derive(Debug, Clone, PartialEq)]
pub enum HostError {
    NotImplemented,
    InvalidParameters,
    RequestReturnMismatch,
    Cancelled,
    Other(String),
}

impl std::fmt::Display for HostError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HostError::NotImplemented => write!(f, "Operation not implemented"),
            HostError::InvalidParameters => write!(f, "Invalid parameters"),
            HostError::RequestReturnMismatch => write!(f, "Request and return types do not match"),
            HostError::Cancelled => write!(f, "Operation cancelled"),
            HostError::Other(msg) => write!(f, "{msg}"),
        }
    }
}

impl std::error::Error for HostError {}

/// Result type for host operations
pub type HostResult<T> = Result<T, HostError>;


--- File: crates/pwsh-core/src/host/methods.rs ---
use uuid::Uuid;

/// PowerShell Host method calls (requests with parameters)
#[derive(Debug, Clone, PartialEq)]
pub enum HostMethodParams {
    GetName,
    GetVersion,
    GetInstanceId,
    GetCurrentCulture,
    GetCurrentUICulture,
    SetShouldExit(i32), // exit_code
    EnterNestedPrompt,
    ExitNestedPrompt,
    NotifyBeginApplication,
    NotifyEndApplication,
}

/// PowerShell Host UI method calls (requests with parameters)
#[derive(Debug, Clone, PartialEq)]
pub enum UIMethodParams {
    ReadLine,
    ReadLineAsSecureString,
    Write(String),                                       // value
    WriteLine(String),                                   // value
    WriteErrorLine(String),                              // value
    WriteDebugLine(String),                              // value
    WriteProgress(i64, String),                          // source_id, record
    WriteVerboseLine(String),                            // value
    WriteWarningLine(String),                            // value
    Prompt(String, Vec<String>),                         // caption, descriptions
    PromptForChoice(String, String, Vec<String>, i32), // caption, message, choices, default_choice
    PromptForCredential(String, String, String, String), // caption, message, user_name, target_name
}

/// PowerShell Host Raw UI method calls (requests with parameters)
#[derive(Debug, Clone, PartialEq)]
pub enum RawUIMethodParams {
    GetForegroundColor,
    SetForegroundColor(i32), // color
    GetBackgroundColor,
    SetBackgroundColor(i32), // color
    GetCursorPosition,
    SetCursorPosition(i32, i32), // x, y
    GetWindowPosition,
    SetWindowPosition(i32, i32), // x, y
    GetCursorSize,
    SetCursorSize(i32), // percentage
    GetBufferSize,
    SetBufferSize(i32, i32), // width, height
    GetWindowSize,
    SetWindowSize(i32, i32), // width, height
    GetMaxWindowSize,
    GetMaxPhysicalWindowSize,
    GetKeyAvailable,
    ReadKey(i32), // options
    FlushInputBuffer,
    SetBufferContents(i32, i32, String),   // x, y, contents
    GetBufferContents(i32, i32, i32, i32), // x, y, width, height
    ScrollBufferContents(i32, i32, i32, i32, i32, i32, String), // source rectangle, destination, clip, fill
}

/// Host call request containing the method and metadata
#[derive(Debug, Clone, PartialEq)]
pub enum HostCallMethodWithParams {
    HostMethod(HostMethodParams),
    UIMethod(UIMethodParams),
    RawUIMethod(RawUIMethodParams),
}

impl HostCallMethodWithParams {
    /// Submit the result and validate that the request and return types match
    /// Returns (method_result, method_exception)
    pub fn submit(
        self,
        result: HostCallMethodReturn,
    ) -> Result<
        (
            Option<protocol_powershell_remoting::PsValue>,
            Option<protocol_powershell_remoting::PsValue>,
        ),
        super::error::HostError,
    > {
        use protocol_powershell_remoting::{PsPrimitiveValue, PsValue};

        // Validate that the request and return types match
        if !matches(&self, &result) {
            return Err(super::error::HostError::RequestReturnMismatch);
        }

        let (method_result, method_exception) = match result {
            HostCallMethodReturn::Error(error) => {
                // Convert error to PsValue exception
                let error_message = error.to_string();
                (
                    None,
                    Some(PsValue::Primitive(PsPrimitiveValue::Str(error_message))),
                )
            }
            HostCallMethodReturn::HostMethod(method_return) => {
                let result = match method_return {
                    HostMethodReturn::GetName(name) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(name)))
                    }
                    HostMethodReturn::GetVersion(version) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(version)))
                    }
                    HostMethodReturn::GetInstanceId(id) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(id.to_string())))
                    }
                    HostMethodReturn::GetCurrentCulture(culture) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(culture)))
                    }
                    HostMethodReturn::GetCurrentUICulture(culture) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(culture)))
                    }
                    HostMethodReturn::SetShouldExit
                    | HostMethodReturn::EnterNestedPrompt
                    | HostMethodReturn::ExitNestedPrompt
                    | HostMethodReturn::NotifyBeginApplication
                    | HostMethodReturn::NotifyEndApplication => None, // void returns
                };
                (result, None)
            }
            HostCallMethodReturn::UIMethod(ui_return) => {
                let result = match ui_return {
                    UIMethodReturn::ReadLine(text) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(text)))
                    }
                    UIMethodReturn::ReadLineAsSecureString(secure_data) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Bytes(secure_data)))
                    }
                    UIMethodReturn::Prompt(values) => Some(PsValue::from_string_array(values)),
                    UIMethodReturn::PromptForChoice(choice) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(choice)))
                    }
                    UIMethodReturn::PromptForCredential(username, password) => {
                        // Create a credential-like object
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "UserName".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "UserName".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::Str(username)),
                            },
                        );
                        properties.insert(
                            "Password".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Password".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::Bytes(password)),
                            },
                        );
                        Some(PsValue::Object(
                            protocol_powershell_remoting::ComplexObject {
                                type_def: None,
                                to_string: None,
                                content:
                                    protocol_powershell_remoting::ComplexObjectContent::Standard,
                                adapted_properties: std::collections::BTreeMap::new(),
                                extended_properties: properties,
                            },
                        ))
                    }
                    UIMethodReturn::Write
                    | UIMethodReturn::WriteLine
                    | UIMethodReturn::WriteErrorLine
                    | UIMethodReturn::WriteDebugLine
                    | UIMethodReturn::WriteProgress
                    | UIMethodReturn::WriteVerboseLine
                    | UIMethodReturn::WriteWarningLine => None, // void returns
                };
                (result, None)
            }
            HostCallMethodReturn::RawUIMethod(raw_ui_return) => {
                let result = match raw_ui_return {
                    RawUIMethodReturn::GetForegroundColor(color) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(color)))
                    }
                    RawUIMethodReturn::GetBackgroundColor(color) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(color)))
                    }
                    RawUIMethodReturn::GetCursorPosition(x, y)
                    | RawUIMethodReturn::GetWindowPosition(x, y) => {
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "X".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "X".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(x)),
                            },
                        );
                        properties.insert(
                            "Y".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Y".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(y)),
                            },
                        );
                        Some(PsValue::Object(
                            protocol_powershell_remoting::ComplexObject {
                                type_def: None,
                                to_string: None,
                                content:
                                    protocol_powershell_remoting::ComplexObjectContent::Standard,
                                adapted_properties: std::collections::BTreeMap::new(),
                                extended_properties: properties,
                            },
                        ))
                    }
                    RawUIMethodReturn::GetCursorSize(size) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(size)))
                    }
                    RawUIMethodReturn::GetBufferSize(width, height)
                    | RawUIMethodReturn::GetWindowSize(width, height)
                    | RawUIMethodReturn::GetMaxWindowSize(width, height)
                    | RawUIMethodReturn::GetMaxPhysicalWindowSize(width, height) => {
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "Width".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Width".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(width)),
                            },
                        );
                        properties.insert(
                            "Height".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Height".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(height)),
                            },
                        );
                        Some(PsValue::Object(
                            protocol_powershell_remoting::ComplexObject {
                                type_def: None,
                                to_string: None,
                                content:
                                    protocol_powershell_remoting::ComplexObjectContent::Standard,
                                adapted_properties: std::collections::BTreeMap::new(),
                                extended_properties: properties,
                            },
                        ))
                    }
                    RawUIMethodReturn::GetKeyAvailable(available) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Bool(available)))
                    }
                    RawUIMethodReturn::ReadKey(virtual_key, character, control_state, key_down) => {
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "VirtualKeyCode".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "VirtualKeyCode".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(virtual_key)),
                            },
                        );
                        properties.insert(
                            "Character".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Character".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::Str(
                                    character.to_string(),
                                )),
                            },
                        );
                        properties.insert(
                            "ControlKeyState".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "ControlKeyState".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(control_state)),
                            },
                        );
                        properties.insert(
                            "KeyDown".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "KeyDown".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(key_down)),
                            },
                        );
                        Some(PsValue::Object(
                            protocol_powershell_remoting::ComplexObject {
                                type_def: None,
                                to_string: None,
                                content:
                                    protocol_powershell_remoting::ComplexObjectContent::Standard,
                                adapted_properties: std::collections::BTreeMap::new(),
                                extended_properties: properties,
                            },
                        ))
                    }
                    RawUIMethodReturn::GetBufferContents(contents) => {
                        Some(PsValue::from_string_array(contents))
                    }
                    RawUIMethodReturn::SetForegroundColor
                    | RawUIMethodReturn::SetBackgroundColor
                    | RawUIMethodReturn::SetCursorPosition
                    | RawUIMethodReturn::SetWindowPosition
                    | RawUIMethodReturn::SetCursorSize
                    | RawUIMethodReturn::SetBufferSize
                    | RawUIMethodReturn::SetWindowSize
                    | RawUIMethodReturn::FlushInputBuffer
                    | RawUIMethodReturn::SetBufferContents
                    | RawUIMethodReturn::ScrollBufferContents => None, // void returns
                };
                (result, None)
            }
        };

        Ok((method_result, method_exception))
    }
}

/// PowerShell Host method responses (return values)
#[derive(Debug, Clone, PartialEq)]
pub enum HostMethodReturn {
    GetName(String),
    GetVersion(String), // Version string
    GetInstanceId(Uuid),
    GetCurrentCulture(String),   // CultureInfo
    GetCurrentUICulture(String), // CultureInfo
    SetShouldExit,               // void return
    EnterNestedPrompt,
    ExitNestedPrompt,
    NotifyBeginApplication,
    NotifyEndApplication,
}

/// PowerShell Host UI method responses (return values)
#[derive(Debug, Clone, PartialEq)]
pub enum UIMethodReturn {
    ReadLine(String),
    ReadLineAsSecureString(Vec<u8>), // SecureString representation
    Write,                           // void return
    WriteLine,                       // void return
    WriteErrorLine,                  // void return
    WriteDebugLine,                  // void return
    WriteProgress,                   // void return
    WriteVerboseLine,                // void return
    WriteWarningLine,                // void return
    Prompt(Vec<String>),             // field values
    PromptForChoice(i32),            // selected choice index
    PromptForCredential(String, Vec<u8>), // username, password (SecureString)
}

/// PowerShell Host Raw UI method responses (return values)
#[derive(Debug, Clone, PartialEq)]
pub enum RawUIMethodReturn {
    GetForegroundColor(i32),
    SetForegroundColor, // void return
    GetBackgroundColor(i32),
    SetBackgroundColor,          // void return
    GetCursorPosition(i32, i32), // x, y
    SetCursorPosition,           // void return
    GetWindowPosition(i32, i32), // x, y
    SetWindowPosition,           // void return
    GetCursorSize(i32),
    SetCursorSize,                      // void return
    GetBufferSize(i32, i32),            // width, height
    SetBufferSize,                      // void return
    GetWindowSize(i32, i32),            // width, height
    SetWindowSize,                      // void return
    GetMaxWindowSize(i32, i32),         // width, height
    GetMaxPhysicalWindowSize(i32, i32), // width, height
    GetKeyAvailable(bool),
    ReadKey(i32, char, i32, i32), // virtual_key_code, character, control_key_state, key_down
    FlushInputBuffer,             // void return
    SetBufferContents,            // void return
    GetBufferContents(Vec<String>), // cell contents
    ScrollBufferContents,         // void return
}

/// Complete host call response
#[derive(Debug, Clone, PartialEq)]
pub enum HostCallMethodReturn {
    HostMethod(HostMethodReturn),
    UIMethod(UIMethodReturn),
    RawUIMethod(RawUIMethodReturn),
    Error(super::error::HostError),
}

fn matches(params: &HostCallMethodWithParams, returns: &HostCallMethodReturn) -> bool {
    match (params, returns) {
        // Host method matches
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetName),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetName(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetVersion),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetVersion(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetInstanceId),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetInstanceId(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetCurrentCulture),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetCurrentCulture(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetCurrentUICulture),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetCurrentUICulture(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::SetShouldExit(_)),
            HostCallMethodReturn::HostMethod(HostMethodReturn::SetShouldExit),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::EnterNestedPrompt),
            HostCallMethodReturn::HostMethod(HostMethodReturn::EnterNestedPrompt),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::ExitNestedPrompt),
            HostCallMethodReturn::HostMethod(HostMethodReturn::ExitNestedPrompt),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::NotifyBeginApplication),
            HostCallMethodReturn::HostMethod(HostMethodReturn::NotifyBeginApplication),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::NotifyEndApplication),
            HostCallMethodReturn::HostMethod(HostMethodReturn::NotifyEndApplication),
        ) => true,

        // UI method matches
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::ReadLine),
            HostCallMethodReturn::UIMethod(UIMethodReturn::ReadLine(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::ReadLineAsSecureString),
            HostCallMethodReturn::UIMethod(UIMethodReturn::ReadLineAsSecureString(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::Write(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::Write),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteErrorLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteErrorLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteDebugLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteDebugLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteProgress(_, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteProgress),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteVerboseLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteVerboseLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteWarningLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteWarningLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::Prompt(_, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::Prompt(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::PromptForChoice(_, _, _, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::PromptForChoice(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::PromptForCredential(_, _, _, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::PromptForCredential(_, _)),
        ) => true,

        // RawUI method matches
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetForegroundColor),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetForegroundColor(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetForegroundColor(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetForegroundColor),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetBackgroundColor),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBackgroundColor(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetBackgroundColor(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetBackgroundColor),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetCursorPosition),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetCursorPosition(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetCursorPosition(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetCursorPosition),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetWindowPosition),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetWindowPosition(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetWindowPosition(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetWindowPosition),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetCursorSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetCursorSize(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetCursorSize(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetCursorSize),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetBufferSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetBufferSize(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetBufferSize),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetWindowSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetWindowSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetWindowSize(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetWindowSize),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetMaxWindowSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetMaxWindowSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetMaxPhysicalWindowSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetMaxPhysicalWindowSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetKeyAvailable),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetKeyAvailable(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::ReadKey(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::ReadKey(_, _, _, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::FlushInputBuffer),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::FlushInputBuffer),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetBufferContents(_, _, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetBufferContents),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetBufferContents(_, _, _, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferContents(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::ScrollBufferContents(
                _,
                _,
                _,
                _,
                _,
                _,
                _,
            )),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::ScrollBufferContents),
        ) => true,

        // Error can match with any request
        (_, HostCallMethodReturn::Error(_)) => true,

        // No match
        _ => false,
    }
}


--- File: crates/pwsh-core/src/host/mod.rs ---
mod conversions;
mod error;
mod methods;
mod types;

pub use error::*;
pub use methods::*;
pub use types::*;

use protocol_powershell_remoting::{PipelineHostCall, PsValue};

#[derive(Debug, Clone)]
pub struct HostCallRequest {
    /// Type of the host call
    pub call_type: HostCallType,
    /// Unique identifier for this host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Parameters for the method call as a list of values
    pub parameters: Vec<PsValue>,
}

impl HostCallRequest {
    pub fn new(
        call_type: HostCallType,
        call_id: i64,
        method_id: i32,
        method_name: String,
        parameters: Vec<PsValue>,
    ) -> Self {
        Self {
            call_type,
            call_id,
            method_id,
            method_name,
            parameters,
        }
    }

    /// Extract the method call with typed parameters
    pub fn get_param(&self) -> Result<HostCallMethodWithParams, HostError> {
        HostCallMethodWithParams::try_from(self)
    }

    /// Submit the result and create a response
    pub fn submit_result(self, result: HostCallMethodReturn) -> HostCallResponse {
        // Extract method and delegate to the new submit method
        let method = match self.get_param() {
            Ok(method) => method,
            Err(error) => {
                // If we can't extract the method, create an error response
                return HostCallResponse {
                    call_type: self.call_type,
                    call_id: self.call_id,
                    method_id: self.method_id,
                    method_name: self.method_name,
                    method_result: None,
                    method_exception: Some(PsValue::Primitive(
                        protocol_powershell_remoting::PsPrimitiveValue::Str(error.to_string()),
                    )),
                };
            }
        };

        let (method_result, method_exception) = match method.submit(result) {
            Ok((result, exception)) => (result, exception),
            Err(error) => {
                // If submit fails, create an error response
                (
                    None,
                    Some(PsValue::Primitive(
                        protocol_powershell_remoting::PsPrimitiveValue::Str(error.to_string()),
                    )),
                )
            }
        };

        HostCallResponse {
            call_type: self.call_type,
            call_id: self.call_id,
            method_id: self.method_id,
            method_name: self.method_name,
            method_result,
            method_exception,
        }
    }

    /// Convenience method to extract method and get a closure for submitting results
    /// Usage: let (method_result, method_exception) = self.get_method()?.submit(result)?;
    pub fn extract_method_and_submit(
        self,
        result: HostCallMethodReturn,
    ) -> Result<(Option<PsValue>, Option<PsValue>), HostError> {
        self.get_param()?.submit(result)
    }
}

#[derive(Debug, Clone)]
pub struct HostCallResponse {
    /// Type of the host call
    pub call_type: HostCallType,
    /// Unique identifier for this host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Optional return value from the method
    pub method_result: Option<PsValue>,
    /// Optional exception thrown by the method invocation
    pub method_exception: Option<PsValue>,
}

impl From<(&PipelineHostCall, HostCallType)> for HostCallRequest {
    fn from((call, call_type): (&PipelineHostCall, HostCallType)) -> Self {
        let PipelineHostCall {
            call_id,
            method_id,
            method_name,
            parameters,
        } = call;

        Self {
            call_type,
            call_id: *call_id,
            method_id: *method_id,
            method_name: method_name.to_string(),
            parameters: parameters.to_vec(),
        }
    }
}

impl From<HostCallRequest> for PipelineHostCall {
    fn from(val: HostCallRequest) -> Self {
        PipelineHostCall {
            call_id: val.call_id,
            method_id: val.method_id,
            method_name: val.method_name,
            parameters: val.parameters,
        }
    }
}


--- File: crates/pwsh-core/src/host/types.rs ---
use uuid::Uuid;

#[derive(Debug, Clone)]
pub enum HostCallType {
    Pipeline { id: Uuid },
    RunspacePool,
}


--- File: crates/pwsh-core/src/lib.rs ---
use std::borrow::Cow;

pub mod connector;
pub mod host;
pub mod pipeline;
pub mod powershell;
pub mod runspace;
pub mod runspace_pool;

#[derive(Debug, thiserror::Error)]
pub enum PwshCoreError {
    #[error("Connector error: {0}")]
    ConnectorError(String),

    #[error("Runspace error: {0}")]
    RunspaceError(String),

    #[error("Hyper error: {0}")]
    IOError(std::io::Error),

    #[error("Hyper error: {0}")]
    HyperError(#[from] hyper::http::Error),

    #[error("Invalid state: {0}")]
    InvalidState(&'static str),

    #[error("Something unlikely happened: {0}")]
    UnlikelyToHappen(&'static str),

    #[error("Protocol error: {0}")]
    PowerShellRemotingError(#[from] protocol_powershell_remoting::PowerShellRemotingError),

    #[error("XML parsing error: {0}")]
    XmlParsingError(#[from] xml::XmlError),

    #[error("Invalid response: {0}")]
    InvalidResponse(Cow<'static, str>),

    #[error("Host error: {0}")]
    HostError(#[from] crate::host::HostError),
}


--- File: crates/pwsh-core/src/pipeline.rs ---
use crate::runspace_pool::PsInvocationState;

/// Represents a parameter value in business logic terms
#[derive(Debug, Clone, PartialEq)]
pub enum ParameterValue {
    String(String),
    Integer(i64),
    Boolean(bool),
    Array(Vec<ParameterValue>),
    Null,
}

/// Represents a single parameter for a command
#[derive(Debug, Clone, PartialEq)]
pub struct Parameter {
    pub name: String,
    pub value: Option<ParameterValue>,
}

/// Represents a single PowerShell command in business logic terms
#[derive(Debug, Clone, PartialEq)]
pub struct PipelineCommand {
    pub command_text: String,
    pub is_script: bool,
    pub parameters: Vec<Parameter>,
}

impl PipelineCommand {
    pub fn new_script(script: String) -> Self {
        Self {
            command_text: script,
            is_script: true,
            parameters: Vec::new(),
        }
    }

    pub fn new_command(command: String) -> Self {
        Self {
            command_text: command,
            is_script: false,
            parameters: Vec::new(),
        }
    }

    pub fn add_parameter(&mut self, name: String, value: ParameterValue) {
        self.parameters.push(Parameter {
            name,
            value: Some(value),
        });
    }

    pub fn add_switch_parameter(&mut self, name: String) {
        self.parameters.push(Parameter { name, value: None });
    }

    pub(crate) fn new_output_stream() -> PipelineCommand {
        PipelineCommand::new_script("Out-String -Stream".to_string())
    }
}

/// Represents execution results in business terms
#[derive(Debug, Clone, Default)]
pub struct ExecutionResult {
    pub error_messages: Vec<String>,
    pub warning_messages: Vec<String>,
    pub debug_messages: Vec<String>,
    pub information_messages: Vec<String>,
    pub progress_records: Vec<protocol_powershell_remoting::ProgressRecord>,
    pub information_records: Vec<protocol_powershell_remoting::InformationRecord>,
}

/// Internal representation of a PowerShell pipeline's state and configuration.
/// This is owned and managed by the `RunspacePool`.
#[derive(Debug, Clone)]
pub struct Pipeline {
    pub(crate) state: PsInvocationState,
    pub(crate) commands: Vec<PipelineCommand>,
    pub(crate) results: ExecutionResult,
}

impl Pipeline {
    pub(crate) fn new() -> Self {
        Self {
            state: PsInvocationState::NotStarted,
            commands: Vec::new(),
            results: ExecutionResult::default(),
        }
    }

    pub(crate) fn add_information_record(
        &mut self,
        record: protocol_powershell_remoting::InformationRecord,
    ) {
        self.results.information_records.push(record);
    }

    pub(crate) fn add_progress_record(
        &mut self,
        record: protocol_powershell_remoting::ProgressRecord,
    ) {
        self.results.progress_records.push(record);
    }

    pub(crate) fn add_switch_parameter(&mut self, name: String) {
        if let Some(last_cmd) = self.commands.last_mut() {
            last_cmd.add_switch_parameter(name);
        } else {
            tracing::warn!("Attempted to add a switch parameter with no prior command.");
        }
    }

    pub(crate) fn add_command(&mut self, command: PipelineCommand) {
        self.commands.push(command);
    }
}

// Conversion methods to protocol types
impl From<ParameterValue> for protocol_powershell_remoting::PsValue {
    fn from(value: ParameterValue) -> Self {
        use protocol_powershell_remoting::{PsPrimitiveValue, PsValue};
        match value {
            ParameterValue::String(s) => PsValue::Primitive(PsPrimitiveValue::Str(s)),
            ParameterValue::Integer(i) => PsValue::Primitive(PsPrimitiveValue::I64(i)),
            ParameterValue::Boolean(b) => PsValue::Primitive(PsPrimitiveValue::Bool(b)),
            ParameterValue::Array(_arr) => {
                todo!("Convert array to PsValue")
            }
            ParameterValue::Null => PsValue::Primitive(PsPrimitiveValue::Nil),
        }
    }
}

impl From<&PipelineCommand> for protocol_powershell_remoting::Command {
    fn from(cmd: &PipelineCommand) -> Self {
        use protocol_powershell_remoting::{CommandParameter, PsPrimitiveValue, PsValue};

        // Convert parameters to CommandParameter
        let mut args = Vec::new();
        for param in &cmd.parameters {
            let param_value = match &param.value {
                Some(value) => value.clone().into(),
                None => {
                    // Switch parameter (no value) - use boolean true
                    PsValue::Primitive(PsPrimitiveValue::Bool(true))
                }
            };

            args.push(
                CommandParameter::builder()
                    .name(param.name.clone())
                    .value(param_value)
                    .build(),
            );
        }

        protocol_powershell_remoting::Command::builder()
            .cmd(&cmd.command_text)
            .is_script(cmd.is_script)
            .args(args)
            .build()
    }
}

impl Pipeline {
    /// Convert the business-level pipeline to a protocol-level PowerShellPipeline
    pub(crate) fn to_protocol_pipeline(
        &self,
    ) -> Result<
        protocol_powershell_remoting::messages::create_pipeline::PowerShellPipeline,
        crate::PwshCoreError,
    > {
        use protocol_powershell_remoting::{Command, Commands};

        // Convert all commands to protocol commands
        let protocol_commands: Vec<Command> = self.commands.iter().map(|cmd| cmd.into()).collect();

        // Use TryFrom to create Commands (handles empty check)
        let commands = Commands::try_from(protocol_commands)
            .map_err(crate::PwshCoreError::PowerShellRemotingError)?;

        Ok(
            protocol_powershell_remoting::messages::create_pipeline::PowerShellPipeline::builder()
                .is_nested(false)
                .redirect_shell_error_output_pipe(true)
                .cmds(commands)
                .build(),
        )
    }
}


--- File: crates/pwsh-core/src/powershell.rs ---
/// A handle to a PowerShell pipeline managed by a `RunspacePool`.
///
/// This struct is a lightweight, copyable identifier for a specific pipeline.
/// All operations on the pipeline are performed via methods on the `RunspacePool`
/// that take this handle as an argument.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct PipelineHandle {
    pub(crate) id: uuid::Uuid,
}

impl PipelineHandle {
    /// Returns the unique identifier for this PowerShell handle.
    pub fn id(&self) -> uuid::Uuid {
        self.id
    }
}


/// Defines how the output of a pipeline should be handled
/// This concept is not part of the PWSH protocol, it is used internally
/// to determine how the output should be processed when invoking a pipeline.
#[derive(Debug)]
pub enum PipelineOutputType {
    Raw,
    /// Invoke pipeline with a extra command `Out-String -Stream`
    Streamed,
}

--- File: crates/pwsh-core/src/runspace/mod.rs ---
pub mod win_rs;


--- File: crates/pwsh-core/src/runspace/win_rs.rs ---
use base64::Engine;
use protocol_winrm::{
    cores::{Attribute, DesiredStream, Receive, Shell, Tag, Text, Time, tag_name},
    rsp::{
        commandline::CommandLineValue,
        receive::{CommandStateValue, ReceiveValue},
        rsp::ShellValue,
    },
    soap::{SoapEnvelope, body::SoapBody},
    ws_management::{self, OptionSetValue, SelectorSetValue, WsMan},
};
use tracing::{debug, instrument};
use uuid::Uuid;
use xml::builder::Element;

#[derive(Debug, Clone, typed_builder::TypedBuilder)]
pub struct WinRunspace {
    #[builder(default = "stdin pr".to_string())]
    input_streams: String,
    #[builder(default = "stdout".to_string())]
    output_streams: String,
    #[builder(default, setter(strip_option))]
    environment: Option<std::collections::HashMap<String, String>>,
    #[builder(default, setter(strip_option))]
    idle_time_out: Option<f64>,
    #[builder(default, setter(strip_option))]
    name: Option<String>,

    #[builder(default = "http://schemas.microsoft.com/powershell/Microsoft.PowerShell".to_string())]
    resource_uri: String,

    #[builder(default = uuid::Uuid::new_v4())]
    id: uuid::Uuid,

    #[builder(default)]
    no_profile: Option<bool>,

    #[builder(default)]
    codepage: Option<u32>,

    #[builder(default)]
    shell_id: Option<String>,
    #[builder(default)]
    owner: Option<String>,
    #[builder(default)]
    client_ip: Option<String>,
    #[builder(default)]
    shell_run_time: Option<String>,
    #[builder(default)]
    shell_inactivity: Option<String>,

    #[builder(default)]
    selector_set: SelectorSetValue,

    #[builder(default)]
    opened: bool,
}

impl WinRunspace {
    pub fn open<'a>(
        &'a self,
        ws_man: &'a WsMan,
        option_set: Option<OptionSetValue>,
        open_content: &'a str,
    ) -> impl Into<Element<'a>> {
        let shell = Tag::from_name(Shell)
            .with_attribute(protocol_winrm::cores::Attribute::ShellId(
                self.id.to_string().into(),
            ))
            .with_attribute(protocol_winrm::cores::Attribute::Name(
                self.name.as_deref().unwrap_or("Runspace1").into(),
            ))
            .with_declaration(protocol_winrm::cores::Namespace::WsmanShell);

        let shell_value = ShellValue::builder()
            .input_streams(self.input_streams.as_ref())
            .output_streams(self.output_streams.as_ref())
            .idle_time_out_opt(self.idle_time_out.map(Time).map(Tag::new))
            .creation_xml(
                Tag::new(open_content)
                    .with_declaration(protocol_winrm::cores::Namespace::PowerShellRemoting),
            )
            .build();

        let shell = shell.with_value(shell_value);

        let mut option_set = option_set.unwrap_or_default();

        if let Some(profile) = self.no_profile {
            option_set = option_set.add_option("WINRS_NOPROFILE", profile.to_string());
        }

        if let Some(codepage) = self.codepage {
            option_set = option_set.add_option("WINRS_CODEPAGE", codepage.to_string());
        }

        ws_man.invoke(
            ws_management::WsAction::Create,
            None,
            SoapBody::builder().shell(shell).build(),
            Some(option_set),
            None,
        )
    }

    pub fn fire_receive<'a>(
        &'a self,
        ws_man: &'a WsMan,
        desired_streams: Vec<crate::runspace_pool::DesiredStream>,
    ) -> impl Into<Element<'a>> {
        let desired_streams = desired_streams
            .into_iter()
            .map(|stream| {
                let mut tag =
                    Tag::from_name(DesiredStream).with_value(Text::from(stream.name().to_owned()));

                if let Some(command_id) = stream.command_id() {
                    tag = tag.with_attribute(Attribute::CommandId(*command_id));
                }

                tag
            })
            .collect();

        let receive = ReceiveValue::builder()
            .desired_streams(desired_streams)
            .build();

        let receive_tag = Tag::from_name(Receive)
            .with_value(receive)
            .with_declaration(protocol_winrm::cores::Namespace::WsmanShell);

        let option_set = OptionSetValue::default()
            .add_option("WSMAN_CMDSHELL_OPTION_KEEPALIVE", true.to_string());

        let selector_set = self
            .shell_id
            .as_ref()
            .map(|shell_id| SelectorSetValue::new().add_selector("ShellId", shell_id));

        ws_man.invoke(
            ws_management::WsAction::ShellReceive,
            Some(&self.resource_uri),
            SoapBody::builder().receive(receive_tag).build(),
            Some(option_set),
            selector_set,
        )
    }

    #[instrument(skip_all)]
    pub(crate) fn accept_receive_response<'a>(
        &mut self,
        soap_envelope: &SoapEnvelope<'a>,
    ) -> Result<(Vec<Stream>, Option<CommandState>), crate::PwshCoreError> {
        let receive_response = &soap_envelope
            .body
            .as_ref()
            .receive_response
            .as_ref()
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "No ReceiveResponse found in response".into(),
            ))?;

        let streams = receive_response
            .value
            .streams
            .iter()
            .map(Stream::try_from)
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| {
                crate::PwshCoreError::InvalidResponse("Failed to decode streams".into())
            })?;

        let command_state = receive_response
            .value
            .command_state
            .as_ref()
            .map(CommandState::try_from)
            .transpose()?;

        debug!(receive_response = ?receive_response,?command_state, "Received streams and command state");

        Ok((streams, command_state))
    }

    pub fn accept_create_response<'a>(
        &mut self,
        soap_envelop: &SoapEnvelope<'a>,
    ) -> Result<(), crate::PwshCoreError> {
        let shell = &soap_envelop.body.as_ref().shell.as_ref().ok_or(
            crate::PwshCoreError::InvalidResponse("No shell found in response".into()),
        )?;
        let shell_id = shell.as_ref().shell_id.as_ref().map(|id| id.clone_value());
        let resource_uri = &shell.as_ref().resource_uri;
        let owner = &shell.as_ref().owner;
        let client_ip = &shell.as_ref().client_ip;
        let idle_time_out = &shell.as_ref().idle_time_out;
        let output_stream = &shell.as_ref().output_streams;
        let shell_run_time = &shell.as_ref().shell_run_time;
        let shell_inactivity = &shell.as_ref().shell_inactivity;

        self.shell_id = shell_id.map(|s| s.as_ref().to_string());
        self.owner = owner.as_ref().map(|o| o.value.as_ref().to_string());
        self.client_ip = client_ip.as_ref().map(|c| c.value.as_ref().to_string());
        self.idle_time_out = idle_time_out.as_ref().map(|t| t.value.0);
        self.output_streams = output_stream
            .as_ref()
            .map(|o| o.value.as_ref().to_string())
            .unwrap_or_else(|| "stdout".to_string());

        self.resource_uri = resource_uri
            .as_ref()
            .map(|r| r.value.as_ref().to_string())
            .unwrap_or_else(|| self.resource_uri.clone());

        self.shell_run_time = shell_run_time
            .as_ref()
            .map(|t| t.value.as_ref().to_string());

        self.shell_inactivity = shell_inactivity
            .as_ref()
            .map(|t| t.value.as_ref().to_string());

        let resource_created = soap_envelop.body.as_ref().resource_created.as_ref().ok_or(
            crate::PwshCoreError::InvalidResponse("No ResourceCreated found in response".into()),
        )?;

        let reference_parameters = resource_created.as_ref().reference_parameters.as_ref();

        let selector_set = &reference_parameters.selector_set;

        self.selector_set = selector_set.value.clone();

        self.opened = true;

        Ok(())
    }

    pub(crate) fn create_pipeline_request<'a>(
        &'a self,
        connection: &'a WsMan,
        command_id: uuid::Uuid,
        arguments: Vec<String>,
        executable: Option<String>,
        no_shell: Option<bool>,
    ) -> Result<impl Into<Element<'a>>, crate::PwshCoreError> {
        let command_line = CommandLineValue {
            command: executable,
            arguments,
        };

        let request = connection.invoke(
            ws_management::WsAction::Command,
            Some(self.resource_uri.as_ref()),
            SoapBody::builder()
                .command_line(
                    Tag::new(command_line).with_attribute(Attribute::CommandId(command_id)),
                )
                .build(),
            Some(OptionSetValue::default().add_option(
                "WINRS_SKIP_CMD_SHELL",
                no_shell.unwrap_or_default().to_string(),
            )),
            self.selector_set.clone().into(),
        );

        Ok(request)
    }

    /// Send data to the shell stdin (for host responses)
    /// TODO: We should handle fragmentation properly
    pub fn send_data_request<'a>(
        &'a self,
        connection: &'a WsMan,
        command_id: Option<uuid::Uuid>,
        data: Vec<String>,
    ) -> Result<impl Into<Element<'a>>, crate::PwshCoreError> {
        use protocol_winrm::{
            cores::{Tag, tag_name::Send},
            soap::body::SoapBody,
        };

        // Add send tag with data
        let send_tag = if let Some(cmd_id) = command_id {
            // For pipeline-scoped sends, include CommandId
            Tag::from_name(Send)
                .with_value(Text::from(data.join("")))
                .with_attribute(Attribute::CommandId(cmd_id))
        } else {
            // For runspace-scoped sends, no CommandId
            Tag::from_name(Send).with_value(Text::from(data.join("")))
        };

        let request = connection.invoke(
            ws_management::WsAction::Send,
            Some(self.resource_uri.as_ref()),
            SoapBody::builder().send(send_tag).build(),
            Some(
                OptionSetValue::default()
                    .add_option("WSMAN_CMDSHELL_OPTION_KEEPALIVE", true.to_string()),
            ),
            self.selector_set.clone().into(),
        );

        Ok(request)
    }

    pub fn accept_commannd_response<'a>(
        &mut self,
        soap_envelope: &SoapEnvelope<'a>,
    ) -> Result<Uuid, crate::PwshCoreError> {
        let command_id = soap_envelope
            .body
            .as_ref()
            .command_response
            .as_ref()
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "No CommandResponse found in response".into(),
            ))?
            .as_ref()
            .as_ref();

        Ok(command_id.0)
    }
}

#[derive(Debug, Clone)]
pub(crate) struct Stream {
    name: String,
    command_id: Option<Uuid>,
    value: Vec<u8>,
}

impl Stream {
    pub(crate) fn name(&self) -> &str {
        &self.name
    }

    pub(crate) fn command_id(&self) -> Option<&Uuid> {
        self.command_id.as_ref()
    }

    pub(crate) fn value(&self) -> &[u8] {
        &self.value
    }
}

impl<'a> TryFrom<&Tag<'a, Text<'a>, tag_name::Stream>> for Stream {
    type Error = crate::PwshCoreError;

    fn try_from(value: &Tag<'a, Text<'a>, tag_name::Stream>) -> Result<Self, Self::Error> {
        let attributes = &value.attributes;
        let name = attributes
            .iter()
            .find_map(|attr| match attr {
                Attribute::Name(name) => Some(name.to_string()),
                _ => None,
            })
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "Stream tag missing name attribute".into(),
            ))?;

        let command_id = attributes.iter().find_map(|attr| match attr {
            Attribute::CommandId(id) => Some(id.to_owned()),
            _ => None,
        });

        // let value = value.value.as_ref();
        let value = base64::engine::general_purpose::STANDARD
            .decode(value.value.as_ref())
            .map_err(|_| {
                crate::PwshCoreError::InvalidResponse("Failed to decode stream value".into())
            })?;

        Ok(Stream {
            name,
            command_id,
            value,
        })
    }
}

#[derive(Debug)]
pub struct CommandState {
    pub command_id: Uuid,
    pub state: String,
    pub exit_code: Option<i32>,
}

impl<'a> TryFrom<&Tag<'a, CommandStateValue<'a>, tag_name::CommandState>> for CommandState {
    type Error = crate::PwshCoreError;

    fn try_from(
        value: &Tag<'a, CommandStateValue<'a>, tag_name::CommandState>,
    ) -> Result<Self, Self::Error> {
        let command_id = value
            .attributes
            .iter()
            .find_map(|attr| match attr {
                Attribute::CommandId(id) => Some(id),
                _ => None,
            })
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "CommandState tag missing command_id attribute".into(),
            ))?;

        let state = value
            .attributes
            .iter()
            .find_map(|attr| match attr {
                Attribute::State(state) => Some(state.to_string()),
                _ => None,
            })
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "CommandState tag missing state attribute".into(),
            ))?;

        let exit_code = value
            .value
            .exit_code
            .as_ref()
            .map(|exit_code| exit_code.value.0);

        Ok(CommandState {
            command_id: *command_id,
            state: state.to_string(),
            exit_code,
        })
    }
}

impl CommandState {
    pub fn is_done(&self) -> bool {
        self.state
            == "http://schemas.microsoft.com/powershell/Microsoft.PowerShell/CommandState/Done"
    }

    pub fn is_pending(&self) -> bool {
        self.state
            == "http://schemas.microsoft.com/powershell/Microsoft.PowerShell/CommandState/Pending"
    }

    pub fn is_running(&self) -> bool {
        self.state
            == "http://schemas.microsoft.com/powershell/Microsoft.PowerShell/CommandState/Running"
    }
}


--- File: crates/pwsh-core/src/runspace_pool/creator.rs ---
use std::{collections::HashMap, sync::Arc};

use protocol_powershell_remoting::{
    ApartmentState, ApplicationPrivateData, Defragmenter, Fragmenter, HostInfo, PSThreadOptions,
    PsValue, SessionCapability,
};
use protocol_winrm::ws_management::WsMan;

use crate::{pipeline::Pipeline, runspace::win_rs::WinRunspace};

use super::{enums::RunspacePoolState, pool::RunspacePool};

#[derive(Debug, typed_builder::TypedBuilder)]
pub struct RunspacePoolCreator {
    #[builder(default = uuid::Uuid::new_v4())]
    id: uuid::Uuid,
    #[builder(default = RunspacePoolState::BeforeOpen)]
    pub(crate) state: RunspacePoolState,

    #[builder(default = 1)]
    min_runspaces: usize,
    #[builder(default = 1)]
    max_runspaces: usize,

    #[builder(default = PSThreadOptions::Default)]
    thread_options: PSThreadOptions,

    #[builder(default = ApartmentState::Unknown)]
    apartment_state: ApartmentState,

    host_info: HostInfo,

    #[builder(default = std::collections::BTreeMap::new())]
    application_arguments: std::collections::BTreeMap<PsValue, PsValue>,

    #[builder(default = Defragmenter::new())]
    defragmenter: Defragmenter,

    #[builder(default)]
    application_private_data: Option<ApplicationPrivateData>,

    #[builder(default)]
    session_capability: Option<SessionCapability>,

    #[builder(default)]
    pipelines: HashMap<uuid::Uuid, Pipeline>,
}

impl RunspacePoolCreator {
    pub fn into_runspace_pool(self, connection: Arc<WsMan>) -> RunspacePool {
        let shell = WinRunspace::builder().id(self.id).build();

        RunspacePool {
            id: self.id,
            state: self.state,
            min_runspaces: self.min_runspaces,
            max_runspaces: self.max_runspaces,
            thread_options: self.thread_options,
            apartment_state: self.apartment_state,
            host_info: self.host_info,
            application_arguments: self.application_arguments,
            fragmenter: Fragmenter::new(connection.max_envelope_size() as usize),
            connection,
            shell,
            defragmenter: self.defragmenter,
            application_private_data: self.application_private_data,
            session_capability: self.session_capability,
            pipelines: self.pipelines,
            runspace_pool_desired_stream_is_pooling: false,
        }
    }
}


--- File: crates/pwsh-core/src/runspace_pool/enums.rs ---
use protocol_powershell_remoting::RunspacePoolStateValue;

#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub enum PowerShellState {
    CreatePipelineSent,
    Ready,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PsInvocationState {
    NotStarted = 0,
    Running = 1,
    Stopping = 2,
    Stopped = 3,
    Completed = 4,
    Failed = 5,
    Disconnected = 6,
}

impl From<protocol_powershell_remoting::PSInvocationState> for PsInvocationState {
    fn from(value: protocol_powershell_remoting::PSInvocationState) -> Self {
        match value {
            protocol_powershell_remoting::PSInvocationState::NotStarted => {
                PsInvocationState::NotStarted
            }
            protocol_powershell_remoting::PSInvocationState::Running => PsInvocationState::Running,
            protocol_powershell_remoting::PSInvocationState::Stopping => {
                PsInvocationState::Stopping
            }
            protocol_powershell_remoting::PSInvocationState::Stopped => PsInvocationState::Stopped,
            protocol_powershell_remoting::PSInvocationState::Completed => {
                PsInvocationState::Completed
            }
            protocol_powershell_remoting::PSInvocationState::Failed => PsInvocationState::Failed,
            protocol_powershell_remoting::PSInvocationState::Disconnected => {
                PsInvocationState::Disconnected
            }
        }
    }
}

/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/b05495bc-a9b2-4794-9f43-4bf1f3633900
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum RunspacePoolState {
    BeforeOpen = 0,
    Opening = 1,
    Opened = 2,
    Closed = 3,
    Closing = 4,
    Broken = 5,
    NegotiationSent = 6,
    NegotiationSucceeded = 7,
    Connecting = 8,
    Disconnected = 9,
}

impl From<&RunspacePoolStateValue> for RunspacePoolState {
    fn from(value: &RunspacePoolStateValue) -> Self {
        match value {
            RunspacePoolStateValue::BeforeOpen => RunspacePoolState::BeforeOpen,
            RunspacePoolStateValue::Opening => RunspacePoolState::Opening,
            RunspacePoolStateValue::Opened => RunspacePoolState::Opened,
            RunspacePoolStateValue::Closed => RunspacePoolState::Closed,
            RunspacePoolStateValue::Closing => RunspacePoolState::Closing,
            RunspacePoolStateValue::Broken => RunspacePoolState::Broken,
            RunspacePoolStateValue::NegotiationSent => RunspacePoolState::NegotiationSent,
            RunspacePoolStateValue::NegotiationSucceeded => RunspacePoolState::NegotiationSucceeded,
            RunspacePoolStateValue::Connecting => RunspacePoolState::Connecting,
            RunspacePoolStateValue::Disconnected => RunspacePoolState::Disconnected,
        }
    }
}


--- File: crates/pwsh-core/src/runspace_pool/expect_shell_created.rs ---
use protocol_winrm::soap::SoapEnvelope;
use xml::parser::XmlDeserialize;

use super::pool::RunspacePool;

#[derive(Debug)]
pub struct ExpectShellCreated {
    pub(super) runspace_pool: RunspacePool,
}

impl ExpectShellCreated {
    pub fn accept(self, response: String) -> Result<RunspacePool, crate::PwshCoreError> {
        let ExpectShellCreated { mut runspace_pool } = self;

        let parsed = xml::parser::parse(response.as_str())?;

        let soap_response = SoapEnvelope::from_node(parsed.root_element())
            .map_err(crate::PwshCoreError::XmlParsingError)?;

        runspace_pool.shell.accept_create_response(&soap_response)?;

        Ok(runspace_pool)
    }
}


--- File: crates/pwsh-core/src/runspace_pool/mod.rs ---
pub mod creator;
pub mod enums;
pub mod expect_shell_created;
pub mod pool;
pub mod types;

// Re-export public types
pub use creator::RunspacePoolCreator;
pub use enums::{PowerShellState, PsInvocationState, RunspacePoolState};
pub use expect_shell_created::ExpectShellCreated;
pub use pool::{DesiredStream, RunspacePool};
pub use types::{PipelineRepresentation, Runspace};


--- File: crates/pwsh-core/src/runspace_pool/pool.rs ---
use std::{collections::HashMap, sync::Arc};

use base64::Engine;
use protocol_powershell_remoting::{
    ApartmentState, ApplicationPrivateData, Commands, CreatePipeline, Defragmenter, HostInfo,
    InitRunspacePool, PSThreadOptions, PipelineOutput, PowerShellPipeline, PsValue,
    RunspacePoolStateMessage, SessionCapability, fragmentation,
};
use protocol_winrm::{
    soap::SoapEnvelope,
    ws_management::{OptionSetValue, WsMan},
};
use tracing::{debug, error, info, instrument, trace, warn};
use uuid::Uuid;
use xml::parser::XmlDeserialize;

use crate::{
    PwshCoreError,
    host::{HostCallRequest, HostCallType},
    pipeline::{ParameterValue, Pipeline, PipelineCommand},
    powershell::{PipelineHandle, PipelineOutputType},
    runspace::win_rs::WinRunspace,
    runspace_pool::PsInvocationState,
};

use super::enums::RunspacePoolState;

const PROTOCOL_VERSION: &str = "2.3";
const PS_VERSION: &str = "2.0";
const SERIALIZATION_VERSION: &str = "1.1.0.1";

#[derive(Debug, Clone)]
pub struct DesiredStream {
    name: String,
    command_id: Option<Uuid>,
}
impl DesiredStream {
    pub(crate) fn new(name: impl Into<String>, command_id: Option<Uuid>) -> Self {
        Self {
            name: name.into(),
            command_id,
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn command_id(&self) -> Option<&Uuid> {
        self.command_id.as_ref()
    }

    pub(crate) fn runspace_pool_streams() -> Vec<Self> {
        vec![DesiredStream {
            name: "stdout".to_string(),
            command_id: None,
        }]
    }

    pub(crate) fn pipeline_streams(command_id: Uuid) -> Vec<Self> {
        vec![
            DesiredStream {
                name: "stdout".to_string(),
                command_id: Some(command_id),
            },
            DesiredStream {
                name: "stderr".to_string(),
                command_id: Some(command_id),
            },
        ]
    }

    pub(crate) fn stdout_for_command(command_id: Uuid) -> Self {
        DesiredStream {
            name: "stdout".to_string(),
            command_id: Some(command_id),
        }
    }
}

#[derive(Debug)]
pub enum AcceptResponsResult {
    ReceiveResponse {
        desired_streams: Vec<DesiredStream>,
    },
    NewPipeline(PipelineHandle),
    HostCall(HostCallRequest),
    PipelineOutput {
        output: PipelineOutput,
        handle: PipelineHandle,
    },
}

#[derive(Debug)]
pub enum PwshMessageResponse {
    HostCall(HostCallRequest),
    PipelineOutput {
        output: PipelineOutput,
        handle: PipelineHandle,
    },
}

impl PwshMessageResponse {
    pub fn name(&self) -> &str {
        match self {
            PwshMessageResponse::HostCall(_) => "HostCall",
            PwshMessageResponse::PipelineOutput { .. } => "PipelineOutput",
        }
    }
}

impl From<PwshMessageResponse> for AcceptResponsResult {
    fn from(response: PwshMessageResponse) -> Self {
        match response {
            PwshMessageResponse::HostCall(host_call) => AcceptResponsResult::HostCall(host_call),
            PwshMessageResponse::PipelineOutput { output, handle } => {
                AcceptResponsResult::PipelineOutput { output, handle }
            }
        }
    }
}

#[derive(Debug)]
pub struct RunspacePool {
    pub(super) id: uuid::Uuid,
    pub(crate) state: RunspacePoolState,
    pub(super) min_runspaces: usize,
    pub(super) max_runspaces: usize,
    pub(super) thread_options: PSThreadOptions,
    pub(super) apartment_state: ApartmentState,
    pub(super) host_info: HostInfo,
    pub(super) application_arguments: std::collections::BTreeMap<PsValue, PsValue>,
    pub(super) shell: WinRunspace,
    pub(super) connection: Arc<WsMan>,
    pub(super) defragmenter: Defragmenter,
    pub(super) application_private_data: Option<ApplicationPrivateData>,
    pub(super) session_capability: Option<SessionCapability>,
    pub(super) pipelines: HashMap<uuid::Uuid, Pipeline>,
    pub(super) fragmenter: fragmentation::Fragmenter,
    pub(super) runspace_pool_desired_stream_is_pooling: bool,
}

impl RunspacePool {
    #[instrument(skip(self), name = "RunspacePool::open")]
    pub fn open(
        mut self,
    ) -> Result<(String, super::expect_shell_created::ExpectShellCreated), crate::PwshCoreError>
    {
        if self.state != RunspacePoolState::BeforeOpen {
            return Err(crate::PwshCoreError::InvalidState(
                "RunspacePool must be in BeforeOpen state to open",
            ));
        }

        let session_capability = SessionCapability {
            protocol_version: PROTOCOL_VERSION.to_string(),
            ps_version: PS_VERSION.to_string(),
            serialization_version: SERIALIZATION_VERSION.to_string(),
            time_zone: None,
        };

        let init_runspace_pool = InitRunspacePool {
            min_runspaces: self.min_runspaces as i32,
            max_runspaces: self.max_runspaces as i32,
            thread_options: self.thread_options,
            apartment_state: self.apartment_state,
            host_info: self.host_info.clone(),
            application_arguments: self.application_arguments.clone(),
        };

        debug!(session_capability = ?session_capability);
        debug!(init_runspace_pool = ?init_runspace_pool);

        let request_groups = self.fragmenter.fragment_multiple(
            &[&session_capability, &init_runspace_pool],
            self.id,
            None,
        )?;

        trace!(request_groups = ?request_groups, "Fragmented negotiation requests");

        self.state = RunspacePoolState::NegotiationSent;

        debug_assert!(
            request_groups.len() == 1,
            "We should have only one request group for the opening negotiation"
        );

        let request = request_groups
            .into_iter()
            .next()
            .ok_or(crate::PwshCoreError::UnlikelyToHappen(
                "No request group generated for negotiation",
            ))
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))?;

        let option_set = OptionSetValue::new().add_option("protocolversion", PROTOCOL_VERSION);

        let result = self
            .shell
            .open(&self.connection, Some(option_set), &request);

        Ok((
            result.into().to_string(),
            super::expect_shell_created::ExpectShellCreated {
                runspace_pool: self,
            },
        ))
    }

    // We should accept the pipeline id here, but for now let's ignore it
    pub(crate) fn fire_receive<'a>(
        &mut self,
        desired_streams: Vec<DesiredStream>,
    ) -> Result<String, crate::PwshCoreError> {
        debug_assert!(!desired_streams.is_empty(), "At least one desired stream");
        Ok(self
            .shell
            .fire_receive(&self.connection, desired_streams)
            .into()
            .to_string())
    }

    #[instrument(skip(self, soap_envelope))]
    pub(crate) fn accept_response(
        &mut self,
        soap_envelope: String,
    ) -> Result<Vec<AcceptResponsResult>, crate::PwshCoreError> {
        debug!("Parsing SOAP envelope of length: {}", soap_envelope.len());

        let parsed = xml::parser::parse(soap_envelope.as_str()).map_err(|e| {
            error!("Failed to parse XML: {:#}", e);
            e
        })?;

        let soap_envelope = SoapEnvelope::from_node(parsed.root_element()).map_err(|e| {
            error!("Failed to parse SOAP envelope: {:#}", e);
            crate::PwshCoreError::XmlParsingError(e)
        })?;

        let mut result = Vec::new();

        if soap_envelope.body.as_ref().receive_response.is_some() {
            debug!("Processing receive response");

            let (streams, command_state) = self
                .shell
                .accept_receive_response(&soap_envelope)
                .map_err(|e| {
                    error!("Failed to accept receive response: {:#}", e);
                    e
                })?;

            let streams_ids = streams
                .iter()
                .filter_map(|stream| stream.command_id().cloned())
                .collect::<Vec<_>>();

            let is_there_a_stream_has_no_command_id =
                streams.iter().any(|stream| stream.command_id().is_none());
            if is_there_a_stream_has_no_command_id {
                debug!(
                    "There is a stream without command_id, it should be the runspace pool stream"
                );
                self.runspace_pool_desired_stream_is_pooling = false
            }

            debug!(
                "Processing {} streams with command IDs: {:?}",
                streams.len(),
                streams_ids
            );

            let handle_pwsh_response = self.handle_pwsh_responses(streams).map_err(|e| {
                error!("Failed to handle PowerShell responses: {:#}", e);
                e
            })?;

            debug!(
                names = ?handle_pwsh_response.iter().map(|r| r.name()).collect::<Vec<_>>(),
                "Handled PowerShell responses"
            );

            result.extend(handle_pwsh_response.into_iter().map(|resp| resp.into()));

            if let Some(command_state) = command_state
                && command_state.is_done()
            {
                debug!(
                    "Command {} is done, removing pipeline",
                    command_state.command_id
                );
                // If command state is done, we can remove the pipeline from the pool
                self.pipelines.remove(&command_state.command_id);
            }

            let desired_streams = if !streams_ids.is_empty() {
                // find the intersetction of streams.id and self.pipelines.keys()
                streams_ids
                    .into_iter()
                    .filter(|stream| {
                        self.pipelines
                            .keys()
                            .any(|pipeline_id| pipeline_id == stream)
                    })
                    .map(|stream| DesiredStream::new("stdout", stream.to_owned().into()))
                    .collect::<Vec<_>>()
            } else {
                if !self.runspace_pool_desired_stream_is_pooling {
                    self.runspace_pool_desired_stream_is_pooling = true;
                    DesiredStream::runspace_pool_streams()
                } else {
                    vec![]
                }
            };

            if !desired_streams.is_empty() {
                result.push(AcceptResponsResult::ReceiveResponse { desired_streams });
            }
        }

        if soap_envelope.body.as_ref().command_response.is_some() {
            let pipeline_id = self.shell.accept_commannd_response(&soap_envelope)?;

            // We have received the pipeline creation response
            // 1. update the state of the pipeline
            // 2. fire receive request for the new pipeline
            self.pipelines
                .get_mut(&pipeline_id)
                .ok_or(crate::PwshCoreError::InvalidResponse(
                    "Pipeline not found for command response".into(),
                ))?
                .state = PsInvocationState::Running;

            result.push(AcceptResponsResult::ReceiveResponse {
                desired_streams: vec![DesiredStream::stdout_for_command(pipeline_id)],
            });
        }

        debug!(?result, "Accept response results");

        Ok(result)
    }

    pub(crate) fn init_pipeline(&mut self) -> PipelineHandle {
        let pineline_id = uuid::Uuid::new_v4();
        self.pipelines.insert(pineline_id, Pipeline::new());
        PipelineHandle { id: pineline_id }
    }

    /// Fire create pipeline for a specific pipeline handle (used by service API)
    #[instrument(skip(self, responses))]
    fn handle_pwsh_responses(
        &mut self,
        responses: Vec<crate::runspace::win_rs::Stream>,
    ) -> Result<Vec<PwshMessageResponse>, crate::PwshCoreError> {
        let mut result = Vec::new();

        for (stream_index, stream) in responses.into_iter().enumerate() {
            debug!(
                stream_index,
                stream_name = ?stream.name(),
                pipeline_id = ?stream.command_id(),
                "Processing stream"
            );

            let messages = match self.defragmenter.defragment(stream.value()).map_err(|e| {
                error!("Failed to defragment stream {}: {:#}", stream_index, e);
                e
            })? {
                fragmentation::DefragmentResult::Incomplete => {
                    debug!("Stream {} incomplete, continuing", stream_index);
                    continue;
                }
                fragmentation::DefragmentResult::Complete(power_shell_remoting_messages) => {
                    debug!(
                        "Stream {} complete with {} messages",
                        stream_index,
                        power_shell_remoting_messages.len()
                    );
                    power_shell_remoting_messages
                }
            };

            for (msg_index, message) in messages.into_iter().enumerate() {
                debug!(
                    "Processing message {}.{}: type={:?}",
                    stream_index, msg_index, message.message_type
                );

                let ps_value = message.parse_ps_message().map_err(|e| {
                    error!(
                        "Failed to parse PS message {}.{}: {:#}",
                        stream_index, msg_index, e
                    );
                    e
                })?;

                info!(?ps_value,message_type = ?message.message_type, "Parsed PS message");

                match message.message_type {
                    protocol_powershell_remoting::MessageType::SessionCapability => {
                        debug!("Handling SessionCapability message");
                        self.handle_session_capability(ps_value).map_err(|e| {
                            error!("Failed to handle SessionCapability: {:#}", e);
                            e
                        })?;
                    }
                    protocol_powershell_remoting::MessageType::ApplicationPrivateData => {
                        debug!("Handling ApplicationPrivateData message");
                        self.handle_application_private_data(ps_value)
                            .map_err(|e| {
                                error!("Failed to handle ApplicationPrivateData: {:#}", e);
                                e
                            })?;
                    }
                    protocol_powershell_remoting::MessageType::RunspacepoolState => {
                        debug!("Handling RunspacepoolState message");
                        self.handle_runspacepool_state(ps_value).map_err(|e| {
                            error!("Failed to handle RunspacepoolState: {:#}", e);
                            e
                        })?;
                    }
                    protocol_powershell_remoting::MessageType::ProgressRecord => {
                        debug!(
                            "Handling ProgressRecord message for stream={}, command_id={:?}",
                            stream.name(),
                            stream.command_id()
                        );
                        self.handle_progress_record(ps_value, stream.name(), stream.command_id())
                            .map_err(|e| {
                                error!("Failed to handle ProgressRecord: {:#}", e);
                                e
                            })?;
                    }
                    protocol_powershell_remoting::MessageType::InformationRecord => {
                        debug!(
                            "Handling InformationRecord message for stream={}, command_id={:?}",
                            stream.name(),
                            stream.command_id()
                        );
                        self.handle_information_record(
                            ps_value,
                            stream.name(),
                            stream.command_id(),
                        )
                        .map_err(|e| {
                            error!("Failed to handle InformationRecord: {:#}", e);
                            e
                        })?;
                    }
                    protocol_powershell_remoting::MessageType::PipelineState => {
                        debug!(
                            "Handling PipelineState message for stream={}, command_id={:?}",
                            stream.name(),
                            stream.command_id()
                        );
                        self.handle_pipeline_state(ps_value, stream.name(), stream.command_id())
                            .map_err(|e| {
                                error!("Failed to handle PipelineState: {:#}", e);
                                e
                            })?;
                    }
                    protocol_powershell_remoting::MessageType::PipelineHostCall => {
                        debug!(
                            stream_name = ?stream.name(),
                            pipeline_id = ?stream.command_id(),
                            "Handling PipelineHostCall message"
                        );

                        let host_call = self
                            .handle_pipeline_host_call(ps_value, stream.name(), stream.command_id())
                            .map_err(|e| {
                                error!("Failed to handle PipelineHostCall: {:#}", e);
                                e
                            })?;
                        debug!(?host_call, "Successfully created host call");
                        result.push(PwshMessageResponse::HostCall(host_call));
                        debug!("Pushed HostCall response");
                    }
                    protocol_powershell_remoting::MessageType::PipelineOutput => {
                        debug!(
                            "Handling PipelineOutput message for stream={}, command_id={:?}",
                            stream.name(),
                            stream.command_id()
                        );

                        let output = self.handle_pipeline_output(ps_value)?;

                        debug!("Successfully handled PipelineOutput: {:?}", output);
                        result.push(PwshMessageResponse::PipelineOutput {
                            output,
                            handle: PipelineHandle {
                                id: stream
                                    .command_id()
                                    .ok_or(crate::PwshCoreError::InvalidResponse(
                                        "PipelineOutput message must have a command_id".into(),
                                    ))?
                                    .clone(),
                            },
                        });
                    }
                    _ => {
                        error!(
                            "Received message of type {:?}, but no handler implemented",
                            message.message_type
                        );
                        todo!("Handle other message types as needed");
                    }
                }
            }
        }

        info!(?result, "Processed PowerShell responses");
        Ok(result)
    }

    #[instrument(skip(self))]
    fn handle_session_capability(
        &mut self,
        session_capability: PsValue,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(session_capability) = session_capability else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected SessionCapability as PsValue::Object".into(),
            ));
        };

        let session_capability = SessionCapability::try_from(session_capability)?;
        debug!(?session_capability, "Received SessionCapability");
        self.session_capability = Some(session_capability);
        Ok(())
    }

    #[instrument(skip(self))]
    fn handle_application_private_data(
        &mut self,
        app_data: PsValue,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(app_data) = app_data else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected ApplicationPrivateData as PsValue::Object".into(),
            ));
        };

        let app_data = ApplicationPrivateData::try_from(app_data)?;
        trace!(?app_data, "Received ApplicationPrivateData");
        self.application_private_data = Some(app_data);
        Ok(())
    }

    #[instrument(skip(self, ps_value))]
    fn handle_runspacepool_state(&mut self, ps_value: PsValue) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(runspacepool_state) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected RunspacepoolState as PsValue::Object".into(),
            ));
        };

        let runspacepool_state = RunspacePoolStateMessage::try_from(runspacepool_state)?;
        trace!(?runspacepool_state, "Received RunspacePoolState");

        self.state = RunspacePoolState::from(&runspacepool_state.runspace_state);

        Ok(())
    }

    #[instrument(skip(self, ps_value, stream_name, command_id))]
    fn handle_progress_record(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(progress_record) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected ProgressRecord as PsValue::Object".into(),
            ));
        };

        let progress_record =
            protocol_powershell_remoting::ProgressRecord::try_from(progress_record)?;

        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        trace!(
            ?progress_record,
            stream_name = stream_name,
            command_id = ?command_id,
            "Received ProgressRecord"
        );

        // Find the pipeline by command_id
        let pipeline = self
            .pipelines
            .get_mut(command_id)
            .ok_or(PwshCoreError::InvalidResponse(
                "Pipeline not found for command_id".into(),
            ))?;

        pipeline.add_progress_record(progress_record);

        Ok(())
    }

    #[instrument(skip(self, ps_value, stream_name, command_id))]
    fn handle_information_record(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(info_record) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected InformationRecord as PsValue::Object".into(),
            ));
        };

        let info_record = protocol_powershell_remoting::InformationRecord::try_from(info_record)?;
        trace!(
            ?info_record,
            stream_name = stream_name,
            command_id = ?command_id,
            "Received InformationRecord"
        );

        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        // Find the pipeline by command_id
        let pipeline = self
            .pipelines
            .get_mut(command_id)
            .ok_or(PwshCoreError::InvalidResponse(
                "Pipeline not found for command_id".into(),
            ))?;

        pipeline.add_information_record(info_record);

        Ok(())
    }

    #[instrument(skip(self, ps_value, stream_name, command_id))]
    fn handle_pipeline_state(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(pipeline_state) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected PipelineState as PsValue::Object".into(),
            ));
        };

        let pipeline_state =
            protocol_powershell_remoting::PipelineStateMessage::try_from(pipeline_state)?;
        trace!(
            ?pipeline_state,
            stream_name = stream_name,
            command_id = ?command_id,
            "Received PipelineState"
        );
        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        // Find the pipeline by command_id
        let pipeline = self
            .pipelines
            .get_mut(command_id)
            .ok_or(PwshCoreError::InvalidResponse(
                "Pipeline not found for command_id".into(),
            ))?;
        // Update the pipeline state
        pipeline.state = PsInvocationState::from(pipeline_state.pipeline_state);

        Ok(())
    }

    // --- PowerShell Pipeline Management API ---
    // Note: PowerShell handles are created by the server via fire_create_pipeline/accept_response flow
    // Users should get handles from the ActiveSession after calling CreatePipeline operation

    /// Adds a switch parameter (no value) to the last command in the specified pipeline.
    pub fn add_switch_parameter(
        &mut self,
        handle: PipelineHandle,
        name: String,
    ) -> Result<(), PwshCoreError> {
        let pipeline = self
            .pipelines
            .get_mut(&handle.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;

        if pipeline.state != PsInvocationState::NotStarted {
            return Err(PwshCoreError::InvalidState(
                "Cannot add to a pipeline that has already been started",
            ));
        }

        pipeline.add_switch_parameter(name);
        Ok(())
    }

    /// Invokes the specified pipeline and waits for its completion.
    ///
    /// This method will handle the entire PSRP message exchange:
    /// 1. Send the `CreatePipeline` message.
    /// 2. Send `Command`, `Send`, and `EndOfInput` messages.
    /// 3. Enter a loop to `Receive` and process responses.
    /// 4. Defragment and deserialize messages, updating the pipeline's state, output, and error streams.
    /// 5. Return the final output upon completion.
    pub fn invoke_pipeline_request(
        &mut self,
        handle: PipelineHandle,
        output_type: PipelineOutputType,
    ) -> Result<String, PwshCoreError> {
        let pipeline = self
            .pipelines
            .get_mut(&handle.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;

        if let PipelineOutputType::Streamed = output_type {
            pipeline.add_command(PipelineCommand::new_output_stream());
        }

        // Set pipeline state to Running
        pipeline.state = PsInvocationState::Running;
        info!(pipeline_id = %handle.id(), "Invoking pipeline");

        // Convert business pipeline to protocol pipeline and build CreatePipeline message
        let protocol_pipeline = pipeline.to_protocol_pipeline()?;
        let create_pipeline = CreatePipeline::builder()
            .power_shell(protocol_pipeline)
            .host_info(self.host_info.clone())
            .apartment_state(self.apartment_state)
            .build();

        debug!(?create_pipeline);

        let fragmented =
            self.fragmenter
                .fragment(&create_pipeline, self.id, Some(handle.id()), None)?;

        let arguments = fragmented
            .into_iter()
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))
            .collect::<Vec<_>>();

        let request = self.shell.create_pipeline_request(
            &self.connection,
            handle.id(),
            arguments,
            None,
            None,
        )?;

        Ok(request.into().to_string())
    }

    #[instrument(skip_all)]
    pub fn handle_pipeline_host_call(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<HostCallRequest, crate::PwshCoreError> {
        let PsValue::Object(pipeline_host_call) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected PipelineHostCall as PsValue::Object".into(),
            ));
        };

        let pipeline_host_call =
            protocol_powershell_remoting::PipelineHostCall::try_from(pipeline_host_call)?;

        debug!(
            ?pipeline_host_call,
            stream_name = stream_name,
            command_id = ?command_id,
            method_id = pipeline_host_call.method_id,
            method_name = pipeline_host_call.method_name,
            parameter_count = pipeline_host_call.parameters.len(),
            "Received PipelineHostCall"
        );

        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        Ok(HostCallRequest::from((
            &pipeline_host_call,
            HostCallType::Pipeline {
                id: command_id.to_owned(),
            },
        )))
    }

    /// Send a pipeline host response to the server
    pub fn send_pipeline_host_response(
        &mut self,
        command_id: uuid::Uuid,
        host_response: protocol_powershell_remoting::PipelineHostResponse,
    ) -> Result<String, PwshCoreError> {
        // Fragment the host response message
        let fragmented =
            self.fragmenter
                .fragment(&host_response, self.id, Some(command_id), None)?;

        // Encode fragments as base64
        let arguments = fragmented
            .into_iter()
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))
            .collect::<Vec<_>>();

        // Create WS-Man Send request (send data to stdin)
        let request =
            self.shell
                .send_data_request(&self.connection, Some(command_id), arguments)?;

        Ok(request.into().to_string())
    }

    /// Send a runspace pool host response to the server
    pub fn send_runspace_pool_host_response(
        &mut self,
        host_response: protocol_powershell_remoting::RunspacePoolHostResponse,
    ) -> Result<String, PwshCoreError> {
        // Fragment the host response message
        let fragmented = self.fragmenter.fragment(
            &host_response,
            self.id,
            None, // No command ID for runspace pool messages
            None,
        )?;

        // Encode fragments as base64
        let arguments = fragmented
            .into_iter()
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))
            .collect::<Vec<_>>();

        // Create WS-Man Send request (send data to stdin)
        let request = self.shell.send_data_request(
            &self.connection,
            None, // No command ID for runspace pool
            arguments,
        )?;

        Ok(request.into().to_string())
    }

    pub fn handle_pipeline_output(
        &mut self,
        ps_value: PsValue,
    ) -> Result<PipelineOutput, PwshCoreError> {
        let pipeline_output = PipelineOutput::from(ps_value);

        Ok(pipeline_output)
    }

    pub(crate) fn add_command(
        &mut self,
        powershell: PipelineHandle,
        command: PipelineCommand,
    ) -> Result<(), PwshCoreError> {
        let pipeline = self
            .pipelines
            .get_mut(&powershell.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;

        if pipeline.state != PsInvocationState::NotStarted {
            return Err(PwshCoreError::InvalidState(
                "Cannot add to a pipeline that has already been started",
            ));
        }

        pipeline.add_command(command);
        Ok(())
    }
}


--- File: crates/pwsh-core/src/runspace_pool/types.rs ---
use std::hash::Hash;

use crate::runspace_pool::PsInvocationState;

#[derive(Debug, Clone)]
pub struct PipelineRepresentation {
    pub id: uuid::Uuid,
    pub state: PsInvocationState,
}

impl PipelineRepresentation {
    pub fn new(id: uuid::Uuid) -> Self {
        PipelineRepresentation {
            id,
            state: PsInvocationState::NotStarted,
        }
    }

    pub fn id(&self) -> uuid::Uuid {
        self.id
    }
}

impl Hash for PipelineRepresentation {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}

impl PartialEq for PipelineRepresentation {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl Eq for PipelineRepresentation {}

pub struct Runspace {
    pub id: uuid::Uuid,
    pub state: super::enums::RunspacePoolState,
}


