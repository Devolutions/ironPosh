--- File: .claude/settings.local.json ---
{
  "$schema": "https://json.schemastore.org/claude-code-settings.json",
  "permissions": {
    "allow": [
      "Bash(cargo --version)",
      "Bash(cargo check:*)",
      "Bash(cargo run:*)",
      "Bash(cargo test:*)",
      "Bash(cargo build:*)",
      "Bash(git add:*)",
      "WebFetch(domain:www.dmtf.org)",
      "WebFetch(domain:learn.microsoft.com)",
      "Bash(git commit:*)",
      "Bash(cargo expand:*)",
      "Bash(cargo clippy:*)",
      "Bash(find:*)",
      "Bash(rg:*)",
      "Bash(mkdir:*)",
      "Bash(rm:*)"
    ],
    "deny": [],
    "additionalDirectories": [
      "C:\\c\\dev",
      "C:\\c\\dev\\ironwinrm\\crates"
    ]
  }
}

--- File: .github/CODEOWNERS ---
# File auto-generated and managed by Devops
/.github/ @devolutions/devops
/.github/dependabot.yml @devolutions/security-managers


--- File: .gitignore ---
/target
*.log


--- File: CLAUDE.md ---
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

IronWinRM is a Rust implementation for Windows Remote Management (WinRM) and PowerShell Remoting protocols. The project is structured as a Cargo workspace with multiple crates that handle different aspects of remote Windows management.

## Architecture

The project follows a layered architecture with clear separation of concerns:

### Core Crates
- **xml**: Custom XML builder forked from einfach-xml-builder-rs for efficient XML generation
- **protocol-macros**: Procedural macros for protocol code generation
- **protocol-winrm**: Core WinRM protocol implementation with SOAP envelope handling
- **protocol-powershell-remoting**: PowerShell remoting protocol message serialization/deserialization
- **pwsh-core**: High-level PowerShell connection and runspace management

### Protocol Layers
1. **XML Layer** (`crates/xml`): Low-level XML building and parsing
2. **WinRM Protocol Layer** (`crates/protocol-winrm`): SOAP envelopes, WS-Addressing, WS-Management headers
3. **PowerShell Remoting Layer** (`crates/protocol-powershell-remoting`): PowerShell-specific message handling
4. **Core Layer** (`crates/pwsh-core`): Connection management, authentication, runspace operations

### Key Components
- **SOAP Envelope Building**: Complex XML structures for WS-Management communications
- **Authentication**: Basic auth support with extensible credential handling
- **Message Serialization**: PowerShell remoting message format handling
- **Connection Management**: HTTP-based WinRM endpoint communication

## Core XML Processing Traits

### TagValue Trait (`crates/protocol-winrm/src/cores/tag_value.rs:10`)

The `TagValue` trait is the core abstraction for XML element content generation during serialization:

```rust
pub trait TagValue<'a> {
    fn append_to_element(self, element: Element<'a>) -> Element<'a>;
}
```

**Key Implementations:**
- `Text<'a>`: Text content with `Cow<'a, str>` for efficient string handling
- `Empty`: Empty XML elements (self-closing tags)
- `WsUuid`: WS-Management UUID format (`uuid:9EC885D6-F5A4-4771-9D47-4BDF7DAAEA8C`)
- `Time`: WS-Management timeout format (`PT180.000S`)
- Numeric types: `U8`, `U32`, `U64` (generated via `xml_num_value!` macro)
- `Tag<'a, V, N>`: Nested XML tags with attributes and namespace support

### XmlDeserialize Trait (`crates/xml/src/parser/mod.rs:74`)

The `XmlDeserialize` trait enables XML-to-Rust deserialization using the visitor pattern:

```rust
pub trait XmlDeserialize<'a>: Sized {
    type Visitor: XmlVisitor<'a, Value = Self>;
    fn visitor() -> Self::Visitor;
    fn from_node(node: roxmltree::Node<'a, 'a>) -> Result<Self, XmlError>;
    fn from_children(children: impl Iterator<Item = Node<'a, 'a>>) -> Result<Self, XmlError>;
}
```

**Visitor Pattern Architecture:**
- `XmlVisitor`: Traverses XML nodes and builds Rust values
- `NodeDeserializer`: Drives visitors over XML subtrees
- Each type implements both `visit_node` and `visit_children` methods
- Supports complex validation (e.g., UUID format parsing, timeout format validation)

### Bidirectional XML Processing

The architecture enables seamless round-trip XML processing:
- **Serialization**: `TagValue` converts Rust → XML
- **Deserialization**: `XmlDeserialize` converts XML → Rust
- **Type Safety**: Many types implement both traits for consistency
- **Namespace Support**: Full WS-Management, SOAP, and PowerShell namespace handling

### Supporting Infrastructure

- **TagName Trait**: Defines XML tag names and namespace URIs
- **Tag<'a, V, N>**: Generic container combining values with XML metadata (attributes, namespaces)
- **Macros**: `xml_num_value!` and `impl_xml_deserialize!` generate boilerplate implementations
- **Error Handling**: Comprehensive XML validation with descriptive error messages

## Common Development Commands

### Building
```bash
# Build entire workspace
cargo build

# Build specific crate
cargo build -p protocol-winrm

# Check for compilation errors without building
cargo check
```

### Testing
```bash
# Run all tests
cargo test

# Run tests for specific crate
cargo test -p protocol-winrm

# Run specific test
cargo test test_initial_build_request
```

### Examples
```bash
# Run connection example
cargo run --example connect -p pwsh-core

# Run SOAP building example  
cargo run --example build -p protocol-winrm

# Run deserialization example
cargo run --example deserde -p protocol-winrm
```

## Development Patterns

### Error Handling
Each crate defines its own error types using `thiserror`:
- `PwshCoreError` for high-level connection errors
- `PowerShellRemotingError` for protocol-specific errors  
- `ProtocolError` for WinRM protocol errors

### Builder Pattern
Extensively uses `typed-builder` crate for safe construction of complex types like SOAP envelopes, connectors, and configuration objects.

### XML Generation
Custom XML builder with namespace support and typed tag names. Uses compile-time type safety for XML structure validation.

### Tracing
Uses `tracing` crate throughout for structured logging. Examples show proper subscriber initialization for debugging protocol interactions.

## Testing Strategy

Tests are organized by protocol layer:
- Unit tests in `src/` subdirectories
- Integration tests in `tests/` directories  
- Examples serve as integration tests and documentation

Key test files:
- `test_initial_build_request.rs`: SOAP envelope construction
- `test_initial_deserialize_request.rs`: Message deserialization
- Various test modules in `protocol-powershell-remoting/src/tests/`

--- File: Cargo.lock ---
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "anstream"
version = "0.6.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ae563653d1938f79b1ab1b5e668c87c76a9930414574a6583a7b7e11a8e6192"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e231f6134f61b71076a3eab506c379d4f36122f2af15a9ff04415ea4c3339e2"
dependencies = [
 "windows-sys 0.60.2",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3e0633414522a32ffaac8ac6cc8f748e090c5717661fddeea04219e2344f5f2a"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.60.2",
]

[[package]]
name = "anyhow"
version = "1.0.99"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0674a1ddeecb70197781e945de4b3b8ffb61fa939a5597bcf48503737663100"

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "backtrace"
version = "0.3.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets 0.52.6",
]

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bitflags"
version = "2.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cc"
version = "1.2.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "deec109607ca693028562ed836a5f1c4b8bd77755c4e132fc5ce11b0b6211ae7"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"

[[package]]
name = "clap"
version = "4.5.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fc0e74a703892159f5ae7d3aac52c8e6c392f5ae5f359c70b5881d60aaac318"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3e7f4214277f3c7aa526a59dd3fbe306a370daee1f8b7b8c987069cd8e888a8"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14cb31bb0a7d536caef2639baa7fad459e15c3144efefa6dbd1c84562c4739f6"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1137cd7e7fc0fb5d3c5a8678be38ec56e819125d8d7907411fe24ccb943faca8"
dependencies = [
 "crossbeam-channel",
 "crossbeam-deque",
 "crossbeam-epoch",
 "crossbeam-queue",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-queue"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "errno"
version = "0.3.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "778e2ac28f6c47af28e4907f13ffd1e1ddbd400980a9abd7c8df189bf578a5ad"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "flate2"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a3d7db9596fecd151c5f638c0ee5d5bd487b6e0ea232e5dc96d5250f6f94b1d"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasi 0.14.2+wasi-0.2.4",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "h2"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17da50a276f1e01e0ba6c029e47b7100754904ee8a278f886546e98575380785"
dependencies = [
 "atomic-waker",
 "bytes",
 "fnv",
 "futures-core",
 "futures-sink",
 "http",
 "indexmap",
 "slab",
 "tokio",
 "tokio-util",
 "tracing",
]

[[package]]
name = "hashbrown"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5971ac85611da7067dbfcabef3c70ebb5606018acd9e2a3903a0da507521e0d5"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "http"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4a85d31aea989eead29a3aaf9e1115a180df8282431156e533de47660892565"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
dependencies = [
 "bytes",
 "http",
]

[[package]]
name = "http-body-util"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
dependencies = [
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"

[[package]]
name = "hyper"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc2b571658e38e0c01b1fdca3bbbe93c00d3d71693ff2770043f8c29bc7d6f80"
dependencies = [
 "bytes",
 "futures-channel",
 "futures-util",
 "h2",
 "http",
 "http-body",
 "httparse",
 "itoa",
 "pin-project-lite",
 "smallvec",
 "tokio",
 "want",
]

[[package]]
name = "hyper-rustls"
version = "0.27.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3c93eb611681b207e1fe55d5a71ecf91572ec8a6705cdb6857f7d8d5242cf58"
dependencies = [
 "http",
 "hyper",
 "hyper-util",
 "rustls",
 "rustls-pki-types",
 "tokio",
 "tokio-rustls",
 "tower-service",
]

[[package]]
name = "hyper-tls"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70206fc6890eaca9fde8a0bf71caa2ddfc9fe045ac9e5c70df101a7dbde866e0"
dependencies = [
 "bytes",
 "http-body-util",
 "hyper",
 "hyper-util",
 "native-tls",
 "tokio",
 "tokio-native-tls",
 "tower-service",
]

[[package]]
name = "hyper-util"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d9b05277c7e8da2c93a568989bb6207bef0112e8d17df7a6eda4a3cf143bc5e"
dependencies = [
 "base64",
 "bytes",
 "futures-channel",
 "futures-core",
 "futures-util",
 "http",
 "http-body",
 "hyper",
 "ipnet",
 "libc",
 "percent-encoding",
 "pin-project-lite",
 "socket2",
 "system-configuration",
 "tokio",
 "tower-service",
 "tracing",
 "windows-registry",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "idna"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "indexmap"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe4cd85333e22411419a0bcae1297d25e58c9443848b11dc6a86fefe8c78a661"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "io-uring"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b86e202f00093dcba4275d4636b93ef9dd75d025ae560d2521b45ea28ab49013"
dependencies = [
 "bitflags",
 "cfg-if",
 "libc",
]

[[package]]
name = "ipnet"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "469fb0b9cefa57e3ef31275ee7cacb78f2fdca44e4765491884a2b119d4eb130"

[[package]]
name = "iri-string"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbc5ebe9c3a1a7a5127f920a418f7585e9e758e911d0466ed004f393b0e380b2"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "ironposh-client-tokio"
version = "0.1.0"
dependencies = [
 "anyhow",
 "clap",
 "futures",
 "powershell-async",
 "protocol-powershell-remoting",
 "pwsh-core",
 "reqwest",
 "tokio",
 "tracing",
 "tracing-subscriber",
 "uuid",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.174"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"

[[package]]
name = "linux-raw-sys"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "native-tls"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87de3442987e9dbec73158d5c715e7ad9072fda936bb03d19d7fa10e00520f0e"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"

[[package]]
name = "openssl"
version = "0.10.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8505734d46c8ab1e19a1dce3aef597ad87dcb4c37e7188231769bd6bd51cebf8"
dependencies = [
 "bitflags",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "openssl-probe"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d05e27ee213611ffe7d6348b942e8f942b37114c00cc03cec254295a4a17852e"

[[package]]
name = "openssl-sys"
version = "0.9.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90096e2e47630d78b7d1c20952dc621f957103f8bc2c8359ec81290d75238571"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "potential_utf"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
dependencies = [
 "zerovec",
]

[[package]]
name = "powershell-async"
version = "0.1.0"
dependencies = [
 "anyhow",
 "crossbeam",
 "futures",
 "pwsh-core",
 "tracing",
 "uuid",
]

[[package]]
name = "powershell-sync"
version = "0.1.0"
dependencies = [
 "anyhow",
 "clap",
 "protocol-powershell-remoting",
 "pwsh-core",
 "regex",
 "tracing",
 "tracing-subscriber",
 "ureq",
 "uuid",
]

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "protocol-macros"
version = "0.1.0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "protocol-powershell-remoting"
version = "0.1.0"
dependencies = [
 "base64",
 "byteorder",
 "quick-xml",
 "regex",
 "serde",
 "thiserror",
 "tracing",
 "tracing-subscriber",
 "tracing-test",
 "typed-builder",
 "uuid",
 "xml",
]

[[package]]
name = "protocol-winrm"
version = "0.1.0"
dependencies = [
 "base64",
 "byteorder",
 "hyper",
 "paste",
 "protocol-macros",
 "thiserror",
 "tracing",
 "tracing-subscriber",
 "tracing-test",
 "typed-builder",
 "uuid",
 "xml",
]

[[package]]
name = "pwsh-core"
version = "0.1.0"
dependencies = [
 "anyhow",
 "base64",
 "hyper",
 "protocol-powershell-remoting",
 "protocol-winrm",
 "regex",
 "thiserror",
 "tokio",
 "tracing",
 "tracing-subscriber",
 "typed-builder",
 "ureq",
 "uuid",
 "xml",
]

[[package]]
name = "quick-xml"
version = "0.38.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8927b0664f5c5a98265138b7e3f90aa19a6b21353182469ace36d4ac527b7b1b"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "redox_syscall"
version = "0.5.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5407465600fb0548f1442edf71dd20683c6ed326200ace4b1ef0763521bb3b77"
dependencies = [
 "bitflags",
]

[[package]]
name = "regex"
version = "1.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23d7fd106d8c02486a8d64e778353d1cffe08ce79ac2e82f540c86d0facf6912"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.9",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "reqwest"
version = "0.12.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d429f34c8092b2d42c7c93cec323bb4adeb7c67698f70839adec842ec10c7ceb"
dependencies = [
 "base64",
 "bytes",
 "encoding_rs",
 "futures-core",
 "h2",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-rustls",
 "hyper-tls",
 "hyper-util",
 "js-sys",
 "log",
 "mime",
 "native-tls",
 "percent-encoding",
 "pin-project-lite",
 "rustls-pki-types",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tokio-native-tls",
 "tower",
 "tower-http",
 "tower-service",
 "url",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
]

[[package]]
name = "ring"
version = "0.17.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7"
dependencies = [
 "cc",
 "cfg-if",
 "getrandom 0.2.16",
 "libc",
 "untrusted",
 "windows-sys 0.52.0",
]

[[package]]
name = "roxmltree"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c20b6793b5c2fa6553b250154b78d6d0db37e72700ae35fad9387a46f487c97"

[[package]]
name = "rustc-demangle"
version = "0.1.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "989e6739f80c4ad5b13e0fd7fe89531180375b18520cc8c82080e4dc4035b84f"

[[package]]
name = "rustix"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11181fbabf243db407ef8df94a6ce0b2f9a733bd8be4ad02b4eda9602296cac8"
dependencies = [
 "bitflags",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.60.2",
]

[[package]]
name = "rustls"
version = "0.23.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2491382039b29b9b11ff08b76ff6c97cf287671dbb74f0be44bda389fffe9bd1"
dependencies = [
 "log",
 "once_cell",
 "ring",
 "rustls-pki-types",
 "rustls-webpki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rustls-pki-types"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "229a4a4c221013e7e1f1a043678c5cc39fe5171437c88fb47151a21e6f5b5c79"
dependencies = [
 "zeroize",
]

[[package]]
name = "rustls-webpki"
version = "0.103.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a17884ae0c1b773f1ccd2bd4a8c72f16da897310a98b0e84bf349ad5ead92fc"
dependencies = [
 "ring",
 "rustls-pki-types",
 "untrusted",
]

[[package]]
name = "rustversion"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "schannel"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f29ebaa345f945cec9fbbc532eb307f0fdad8161f281b6369539c8d84876b3d"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "security-framework"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
dependencies = [
 "bitflags",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49db231d56a190491cb4aeda9527f1ad45345af50b0851622a7adb8c03b01c32"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.143"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d401abef1d108fbd9cbaebc3e46611f4b1021f714a0597a71f41ee463f5f4a5a"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9203b8055f63a2a00e2f593bb0510367fe707d7ff1e5c872de2f537b339e5410"
dependencies = [
 "libc",
]

[[package]]
name = "slab"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04dc19736151f35336d325007ac991178d504a119863a2fcb3758cdb5e52c50d"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "socket2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "2.0.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17b6f705963418cdb9927482fa304bc562ece2fdd4f616084c50b7023b435a40"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sync_wrapper"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"
dependencies = [
 "futures-core",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "system-configuration"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c879d448e9d986b661742763247d3693ed13609438cf3d006f51f5368a5ba6b"
dependencies = [
 "bitflags",
 "core-foundation",
 "system-configuration-sys",
]

[[package]]
name = "system-configuration-sys"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e1d1b10ced5ca923a1fcb8d03e96b8d3268065d724548c0211415ff6ac6bac4"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "tempfile"
version = "3.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15b61f8f20e3a6f7e0649d825294eaf317edce30f82cf6026e7e4cb9222a7d1e"
dependencies = [
 "fastrand",
 "getrandom 0.3.3",
 "once_cell",
 "rustix",
 "windows-sys 0.60.2",
]

[[package]]
name = "thiserror"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tokio"
version = "1.46.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cc3a2344dafbe23a245241fe8b09735b521110d30fcefbbd5feb1797ca35d17"
dependencies = [
 "backtrace",
 "bytes",
 "io-uring",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "slab",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "tokio-rustls"
version = "0.26.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e727b36a1a0e8b74c376ac2211e40c2c8af09fb4013c60d910495810f008e9b"
dependencies = [
 "rustls",
 "tokio",
]

[[package]]
name = "tokio-util"
version = "0.7.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "66a539a9ad6d5d281510d5bd368c973d636c02dbf8a67300bfb6b950696ad7df"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "tower"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d039ad9159c98b70ecfd540b2573b97f7f52c3e8d9f8ad57a24b916a536975f9"
dependencies = [
 "futures-core",
 "futures-util",
 "pin-project-lite",
 "sync_wrapper",
 "tokio",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-http"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adc82fd73de2a9722ac5da747f12383d2bfdb93591ee6c58486e0097890f05f2"
dependencies = [
 "bitflags",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "iri-string",
 "pin-project-lite",
 "tower",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-layer"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"

[[package]]
name = "tower-service"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8189decb5ac0fa7bc8b96b7cb9b2701d60d48805aca84a238004d665fcc4008"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "tracing-test"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "557b891436fe0d5e0e363427fc7f217abf9ccd510d5136549847bdcbcd011d68"
dependencies = [
 "tracing-core",
 "tracing-subscriber",
 "tracing-test-macro",
]

[[package]]
name = "tracing-test-macro"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04659ddb06c87d233c566112c1c9c5b9e98256d9af50ec3bc9c8327f873a7568"
dependencies = [
 "quote",
 "syn",
]

[[package]]
name = "try-lock"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"

[[package]]
name = "typed-builder"
version = "0.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce63bcaf7e9806c206f7d7b9c1f38e0dce8bb165a80af0898161058b19248534"
dependencies = [
 "typed-builder-macro",
]

[[package]]
name = "typed-builder-macro"
version = "0.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60d8d828da2a3d759d3519cdf29a5bac49c77d039ad36d0782edadbf9cd5415b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "untrusted"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"

[[package]]
name = "ureq"
version = "2.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02d1a66277ed75f640d608235660df48c8e3c19f3b4edb6a263315626cc3c01d"
dependencies = [
 "base64",
 "flate2",
 "log",
 "once_cell",
 "rustls",
 "rustls-pki-types",
 "url",
 "webpki-roots 0.26.11",
]

[[package]]
name = "url"
version = "2.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "uuid"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f33196643e165781c20a5ead5582283a7dacbb87855d867fbc2df3f81eddc1be"
dependencies = [
 "getrandom 0.3.3",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "want"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
dependencies = [
 "try-lock",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.2+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
dependencies = [
 "wit-bindgen-rt",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
dependencies = [
 "cfg-if",
 "js-sys",
 "once_cell",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "web-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webpki-roots"
version = "0.26.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "521bc38abb08001b01866da9f51eb7c5d647a19260e00054a8c7fd5f9e57f7a9"
dependencies = [
 "webpki-roots 1.0.2",
]

[[package]]
name = "webpki-roots"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e8983c3ab33d6fb807cfcdad2491c4ea8cbc8ed839181c7dfd9c67c83e261b2"
dependencies = [
 "rustls-pki-types",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-registry"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b8a9ed28765efc97bbc954883f4e6796c33a06546ebafacbabee9696967499e"
dependencies = [
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.3",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm 0.52.6",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.53.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d5fe6031c4041849d7c496a8ded650796e7b6ecc19df1a431c1a363342e5dc91"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm 0.53.0",
 "windows_aarch64_msvc 0.53.0",
 "windows_i686_gnu 0.53.0",
 "windows_i686_gnullvm 0.53.0",
 "windows_i686_msvc 0.53.0",
 "windows_x86_64_gnu 0.53.0",
 "windows_x86_64_gnullvm 0.53.0",
 "windows_x86_64_msvc 0.53.0",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86b8d5f90ddd19cb4a147a5fa63ca848db3df085e25fee3cc10b39b6eebae764"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7651a1f62a11b8cbd5e0d42526e55f2c99886c77e007179efff86c2b137e66c"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1dc67659d35f387f5f6c479dc4e28f1d4bb90ddd1a5d3da2e5d97b42d6272c3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce6ccbdedbf6d6354471319e781c0dfef054c81fbc7cf83f338a4296c0cae11"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_i686_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "581fee95406bb13382d2f65cd4a908ca7b1e4c2f1917f143ba16efe98a589b5d"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e55b5ac9ea33f2fc1716d1742db15574fd6fc8dadc51caab1c16a3d3b4190ba"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a6e035dd0599267ce1ee132e51c27dd29437f63325753051e71dd9e42406c57"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"

[[package]]
name = "wit-bindgen-rt"
version = "0.39.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
dependencies = [
 "bitflags",
]

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "xml"
version = "0.1.0"
dependencies = [
 "roxmltree",
 "thiserror",
 "tracing",
]

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a05eb080e015ba39cc9e23bbe5e7fb04d5fb040350f99f34e338d5fdd294428"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]


--- File: Cargo.toml ---
[workspace]
resolver = "3"
# Define the members of the workspace. Currently, it includes the main crate.
members = ["crates/*"]


--- File: crates/ironposh-client-tokio/Cargo.toml ---
[package]
name = "ironposh-client-tokio"
version = "0.1.0"
edition = "2021"

[dependencies]
powershell-async = { version = "0.1.0", path = "../powershell-async" }
pwsh-core = { version = "0.1.0", path = "../pwsh-core" }
protocol-powershell-remoting = { version = "0.1.0", path = "../protocol-powershell-remoting" }
tokio = { version = "1.0", features = ["full"] }
anyhow = "1.0"
clap = { version = "4.5", features = ["derive"] }
tracing = "0.1.41"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }
reqwest = { version = "0.12", features = ["json"] }
uuid = { version = "1.18.0", features = ["v4"] }
futures = "0.3"


--- File: crates/ironposh-client-tokio/README.md ---
# IronPosh Client (Tokio)

An async PowerShell remoting client built with Tokio that provides both interactive and non-interactive modes for executing PowerShell commands on remote Windows machines.

## Features

- **Async/Await**: Built on Tokio for high-performance async operations
- **Interactive Mode**: REPL-style interface for interactive PowerShell sessions
- **Non-Interactive Mode**: Execute single commands and exit
- **WinRM Protocol**: Full WinRM and PowerShell Remoting protocol support
- **Structured Logging**: Comprehensive tracing with configurable verbosity levels

## Usage

### Interactive Mode

```bash
cargo run --bin ironposh-client-tokio -- -s 192.168.1.100 -u Administrator -P MyPassword
```

This starts an interactive PowerShell session where you can execute commands:

```
IronPosh Interactive PowerShell Client
Enter PowerShell commands or 'exit' to quit
PS> Get-ComputerInfo
PS> Get-Process | Select-Object -First 5
PS> exit
```

### Non-Interactive Mode

Execute a single command and exit:

```bash
cargo run --bin ironposh-client-tokio -- -s 192.168.1.100 -u Administrator -P MyPassword -c "Get-ComputerInfo"
```

### Command Line Options

- `-s, --server <IP>`: Server IP address (default: 10.10.0.3)
- `-p, --port <PORT>`: Server port (default: 5985)  
- `-u, --username <USER>`: Username for authentication (default: Administrator)
- `-P, --password <PASS>`: Password for authentication (default: DevoLabs123!)
- `--https`: Use HTTPS instead of HTTP
- `-v, --verbose`: Increase logging verbosity (can be repeated)
- `-c, --command <CMD>`: Command to execute in non-interactive mode

## Architecture

This client uses the `powershell-async` crate as its engine, which provides:

- `RemoteAsyncPowershellClient`: Main async PowerShell client
- Async HTTP client integration via `HttpClient` trait
- Connection management and message handling
- Pipeline operations for PowerShell command execution

The implementation follows the same patterns as `powershell-sync-client` but uses async/await throughout for better concurrency and performance.

## Logging

Logs are written to `ironposh_client.log` with different verbosity levels:

- `-v`: Debug level logging
- `-vv`: Trace level logging  
- `-vvv`: Full trace logging for all components

## Dependencies

- `tokio`: Async runtime
- `reqwest`: HTTP client for WinRM requests
- `powershell-async`: Async PowerShell client engine
- `pwsh-core`: Core PowerShell protocol support
- `clap`: Command line argument parsing
- `tracing`: Structured logging

--- File: crates/ironposh-client-tokio/src/config.rs ---
use std::net::IpAddr;

use clap::Parser;
use pwsh_core::connector::{http::ServerAddress, Authentication, ConnectorConfig, Scheme};
use tracing_subscriber::{fmt, prelude::*, registry::Registry, EnvFilter};

/// PowerShell Remoting Client (Async/Tokio)
#[derive(Parser)]
#[command(version, about, long_about = None)]
pub struct Args {
    /// Server IP address to connect to
    #[arg(short, long, default_value = "10.10.0.3", help = "Server IP address")]
    pub server: IpAddr,

    /// Server port to connect to
    #[arg(short, long, default_value = "5985", help = "Server port")]
    pub port: u16,

    /// Username for authentication
    #[arg(
        short,
        long,
        default_value = "Administrator",
        help = "Username for authentication"
    )]
    pub username: String,

    /// Password for authentication
    #[arg(
        short = 'P',
        long,
        default_value = "DevoLabs123!",
        help = "Password for authentication"
    )]
    pub password: String,

    /// Use HTTPS instead of HTTP
    #[arg(long, help = "Use HTTPS (default: HTTP)")]
    pub https: bool,

    /// Verbose logging (can be repeated for more verbosity)
    #[arg(short, long, action = clap::ArgAction::Count, help = "Increase logging verbosity")]
    pub verbose: u8,

    /// Command to execute (if provided, runs in non-interactive mode)
    #[arg(short = 'c', long, help = "Command to execute")]
    pub command: Option<String>,
}

/// Initialize logging with file output and proper structured logging
pub fn init_logging(verbose_level: u8) -> anyhow::Result<()> {
    let log_file = std::fs::File::create("ironposh_client.log")?;

    // Determine log level based on verbosity using structured filters
    let log_level = match verbose_level {
        0 => "ironposh_client_tokio=info,powershell_async=info,pwsh_core=info,protocol_powershell_remoting=info,protocol_winrm=warn,reqwest=error",
        1 => "ironposh_client_tokio=debug,powershell_async=debug,pwsh_core=debug,protocol_powershell_remoting=debug,protocol_winrm=info,reqwest=error",
        2 => "ironposh_client_tokio=trace,powershell_async=trace,pwsh_core=trace,protocol_powershell_remoting=trace,protocol_winrm=debug,reqwest=warn",
        _ => "trace",
    };

    let env_filter = EnvFilter::new(log_level);

    let subscriber = Registry::default().with(env_filter).with(
        fmt::layer()
            .with_writer(log_file)
            .with_target(true)
            .with_line_number(true)
            .with_file(true)
            .compact(),
    );

    tracing::subscriber::set_global_default(subscriber)?;
    Ok(())
}

/// Create connector configuration from command line arguments
pub fn create_connector_config(args: &Args) -> ConnectorConfig {
    let server = ServerAddress::Ip(args.server);
    let scheme = if args.https {
        Scheme::Https
    } else {
        Scheme::Http
    };
    let auth = Authentication::Basic {
        username: args.username.clone(),
        password: args.password.clone(),
    };

    ConnectorConfig {
        server: (server, args.port),
        scheme,
        authentication: auth,
        host_info: protocol_powershell_remoting::HostInfo::builder()
            .is_host_null(false)
            .is_host_ui_null(true)
            .is_host_raw_ui_null(true)
            .build(),
    }
}


--- File: crates/ironposh-client-tokio/src/http_client.rs ---
use anyhow::Context;
use powershell_async::HttpClient;
use pwsh_core::connector::http::{HttpRequest, HttpResponse, Method};

pub struct ReqwestHttpClient {
    client: reqwest::Client,
}

impl ReqwestHttpClient {
    pub fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }
}

impl HttpClient for ReqwestHttpClient {
    async fn send_request(
        &self,
        request: HttpRequest<String>,
    ) -> anyhow::Result<HttpResponse<String>> {
        let mut req_builder = match request.method {
            Method::Get => self.client.get(&request.url),
            Method::Post => self.client.post(&request.url),
            Method::Put => self.client.put(&request.url),
            Method::Delete => self.client.delete(&request.url),
        };

        // Add headers
        for (key, value) in &request.headers {
            req_builder = req_builder.header(key, value);
        }

        // Add body if present
        if let Some(body) = &request.body {
            req_builder = req_builder.body(body.clone());
        }

        let response = req_builder
            .send()
            .await
            .context("Failed to send HTTP request")?;

        let status_code = response.status().as_u16();
        let headers: Vec<(String, String)> = response
            .headers()
            .iter()
            .map(|(k, v)| (k.to_string(), v.to_str().unwrap_or("").to_string()))
            .collect();

        let body = response
            .text()
            .await
            .context("Failed to read response body")?;

        Ok(HttpResponse {
            status_code,
            headers,
            body: Some(body),
        })
    }
}


--- File: crates/ironposh-client-tokio/src/main.rs ---
mod config;
mod http_client;

use anyhow::Context;
use clap::Parser;
use powershell_async::remote_client::RemoteAsyncPowershellClient;
use tracing::{error, info, instrument};

use config::{create_connector_config, init_logging, Args};
use http_client::ReqwestHttpClient;

#[tokio::main]
#[instrument(name = "main", level = "info")]
async fn main() -> anyhow::Result<()> {
    // Parse command line arguments
    let args = Args::parse();

    // Initialize logging with the specified verbosity level
    init_logging(args.verbose)?;
    info!("Starting WinRM PowerShell client (Async/Tokio)");

    // Display connection information
    info!(
        server = %args.server,
        port = args.port,
        username = %args.username,
        scheme = %if args.https { "HTTPS" } else { "HTTP" },
        "connecting to server"
    );

    // Create configuration and HTTP client
    let config = create_connector_config(&args);
    let http_client = ReqwestHttpClient::new();

    // Create the PowerShell client
    let (mut client, connection_task) = RemoteAsyncPowershellClient::open_task(config, http_client);

    // Spawn the connection task (no tracing in spawned task to avoid Send issues)
    let connection_handle = tokio::spawn(async move {
        if let Err(e) = connection_task.await {
            eprintln!("Connection task failed: {e}");
        }
    });

    info!("Runspace pool is now open and ready for operations!");

    // Check if we have a command to execute
    if let Some(command) = args.command {
        // Non-interactive mode: execute command and exit
        info!(command = %command, "executing command in non-interactive mode");

        match client.send_command(command.clone()).await {
            Ok(output) => {
                println!("{output}");
                info!("Command executed successfully");
            }
            Err(e) => {
                error!(error = %e, "Failed to execute command");
                eprintln!("Error executing command: {e}");
                std::process::exit(1);
            }
        }
    } else {
        // Interactive mode: start REPL
        info!("starting interactive mode");
        if let Err(e) = run_interactive_mode(&mut client).await {
            error!(error = %e, "Interactive mode failed");
            eprintln!("Interactive mode failed: {e}");
            std::process::exit(1);
        }
    }

    // Clean up
    connection_handle.abort();
    info!("Exiting main function");
    Ok(())
}

/// Run interactive REPL mode
async fn run_interactive_mode(client: &mut RemoteAsyncPowershellClient) -> anyhow::Result<()> {
    use tokio::io::{self, AsyncBufReadExt, BufReader};

    println!("IronPosh Interactive PowerShell Client");
    println!("Enter PowerShell commands or 'exit' to quit");
    println!("PS> ");

    let stdin = io::stdin();
    let reader = BufReader::new(stdin);
    let mut lines = reader.lines();

    while let Some(line) = lines
        .next_line()
        .await
        .context("Failed to read from stdin")?
    {
        let command = line.trim();

        if command.is_empty() {
            print!("PS> ");
            continue;
        }

        if command.eq_ignore_ascii_case("exit") || command.eq_ignore_ascii_case("quit") {
            info!("User requested exit");
            break;
        }

        info!(command = %command, "executing user command");

        match client.send_command(command.to_string()).await {
            Ok(output) => {
                print!("{output}");
                if !output.ends_with('\n') {
                    println!();
                }
            }
            Err(e) => {
                error!(error = %e, "Failed to execute command");
                eprintln!("Error: {e}");
            }
        }

        print!("PS> ");
    }

    Ok(())
}


--- File: crates/powershell-async/Cargo.toml ---
[package]
name = "powershell-async"
version = "0.1.0"
edition = "2024"

[dependencies]
anyhow = "1.0.99"
crossbeam = { version = "0.8.4", features = ["crossbeam-channel"] }
futures = { version = "0.3.31", default-features = false, features = ["async-await", "std"] }
pwsh-core = { version = "0.1.0", path = "../pwsh-core" }
tracing = "0.1"
uuid = "1.0"


--- File: crates/powershell-async/src/lib.rs ---
use pwsh_core::connector::http::{HttpRequest, HttpResponse};
use std::future::Future;

pub mod remote_client;

pub trait AsyncPowershellClient {
    fn open_task(&self, client: impl HttpClient) -> impl Future<Output = anyhow::Result<()>>
    where
        Self: Sized;

    fn send_command(&self, command: String) -> impl Future<Output = anyhow::Result<String>>;
}

pub trait HttpClient: Send + Sync + 'static {
    fn send_request(
        &self,
        request: HttpRequest<String>,
    ) -> impl Future<Output = anyhow::Result<HttpResponse<String>>> + Send;
}


--- File: crates/powershell-async/src/remote_client.rs ---
use anyhow::Context;
use futures::channel::mpsc;
use futures::{SinkExt, StreamExt};
use pwsh_core::connector::active_session::UserEvent;
use pwsh_core::{
    connector::{Connector, ConnectorStepResult, UserOperation, http::HttpRequest},
    pipeline::PipelineCommand,
};
use tracing::{info, warn};

use crate::HttpClient;

pub struct RemoteAsyncPowershellClient {
    user_input_tx: mpsc::UnboundedSender<UserOperation>,
    user_output_rx: mpsc::UnboundedReceiver<pwsh_core::connector::active_session::UserEvent>,
    message_cache: std::collections::HashMap<uuid::Uuid, Vec<UserEvent>>,
}

impl RemoteAsyncPowershellClient {
    async fn start_active_session_loop(
        mut active_session: pwsh_core::connector::active_session::ActiveSession,
        client: impl HttpClient,
        mut user_input_rx: mpsc::UnboundedReceiver<pwsh_core::connector::UserOperation>,
        mut user_output_tx: mpsc::UnboundedSender<pwsh_core::connector::active_session::UserEvent>,
        mut user_input_tx: mpsc::UnboundedSender<pwsh_core::connector::UserOperation>,
    ) -> anyhow::Result<()> {
        use tracing::{error, info};

        // Create channels for network request/response handling
        let (mut network_request_tx, mut network_request_rx) = mpsc::unbounded();
        let (mut network_response_tx, mut network_response_rx) = mpsc::unbounded();

        // Network task - handles HTTP requests/responses
        let network_task = async move {
            while let Some(http_request) = network_request_rx.next().await {
                match client.send_request(http_request).await {
                    Ok(response) => {
                        if network_response_tx.send(response).await.is_err() {
                            break; // Channel closed
                        }
                    }
                    Err(e) => {
                        error!(target: "network", error = %e, "HTTP request failed");
                        break;
                    }
                }
            }
        };

        // Session task - handles the main event loop
        let session_task = async move {
            loop {
                // Handle both network responses and user requests like the sync version
                futures::select! {
                    network_response = network_response_rx.next() => {
                        match network_response {
                            Some(http_response) => {
                                info!(
                                    target: "network",
                                    body_length = http_response.body.as_ref().map(|b| b.len()).unwrap_or(0),
                                    "processing network response"
                                );

                                let step_results = active_session
                                    .accept_server_response(http_response)
                                    .map_err(|e| {
                                        error!(target: "network", error = %e, "failed to accept server response");
                                        e
                                    })
                                    .context("Failed to accept server response")?;

                                Self::process_session_outputs(step_results, &mut network_request_tx, &mut user_output_tx, &mut user_input_tx).await?;
                            }
                            None => {
                                error!("Network response channel disconnected");
                                return Err(anyhow::anyhow!("Network response channel disconnected"));
                            }
                        }
                    }
                    user_operation = user_input_rx.next() => {
                        match user_operation {
                            Some(user_operation) => {
                                info!(target: "user", operation = ?user_operation, "processing user operation");

                                let step_result = active_session
                                    .accept_client_operation(user_operation)
                                    .map_err(|e| {
                                        error!(target: "user", error = %e, "failed to accept user operation");
                                        e
                                    })
                                    .context("Failed to accept user operation")?;

                                Self::process_session_outputs(vec![step_result], &mut network_request_tx, &mut user_output_tx, &mut user_input_tx).await?;
                            }
                            None => {
                                info!("User input channel disconnected");
                                return Ok(());
                            }
                        }
                    }
                }
            }
        };

        // Use futures::join! to run both tasks concurrently
        let (session_result, _network_result) = futures::join!(session_task, network_task);
        session_result
    }

    async fn process_session_outputs(
        step_results: Vec<pwsh_core::connector::active_session::ActiveSessionOutput>,
        network_request_tx: &mut mpsc::UnboundedSender<HttpRequest<String>>,
        user_output_tx: &mut mpsc::UnboundedSender<pwsh_core::connector::active_session::UserEvent>,
        user_input_tx: &mut mpsc::UnboundedSender<UserOperation>,
    ) -> anyhow::Result<()> {
        use pwsh_core::connector::active_session::ActiveSessionOutput;
        use pwsh_core::host::{HostCallMethodReturn, RawUIMethodReturn};
        use tracing::{error, info, warn};

        for step_result in step_results {
            info!(step_result = ?step_result, "processing step result");

            match step_result {
                ActiveSessionOutput::SendBack(http_requests) => {
                    info!(
                        target: "network",
                        request_count = http_requests.len(),
                        "sending HTTP requests to network task"
                    );
                    for http_request in http_requests {
                        if let Err(e) = network_request_tx.send(http_request).await {
                            error!(target: "network", error = %e, "failed to send HTTP request to network task");
                            return Err(anyhow::anyhow!(
                                "Failed to send HTTP request to network task: {}",
                                e
                            ));
                        }
                    }
                }
                ActiveSessionOutput::SendBackError(e) => {
                    error!(target: "session", error = %e, "session step failed");
                    return Err(anyhow::anyhow!("Session step failed: {}", e));
                }
                ActiveSessionOutput::UserEvent(event) => {
                    info!(target: "user", event = ?event, "sending user event");
                    if let Err(e) = user_output_tx.send(event).await {
                        error!(target: "user", error = %e, "failed to send user event");
                    }
                }
                /*
                    This is the complex part - handling host calls
                    TODO: Implement more host call methods as needed
                */
                ActiveSessionOutput::HostCall(host_call) => {
                    info!(
                        target: "host",
                        method_name = %host_call.method_name,
                        call_id = host_call.call_id,
                        "received host call"
                    );

                    let method = host_call.get_param().map_err(|e| {
                        error!(target: "host", error = %e, "failed to parse host call parameters");
                        e
                    })?;

                    info!(target: "host", method = ?method, "processing host call method");

                    let response = match method {
                        pwsh_core::host::HostCallMethodWithParams::RawUIMethod(
                            pwsh_core::host::RawUIMethodParams::GetBufferSize,
                        ) => {
                            info!(target: "host", method = "GetBufferSize", "returning default console size");
                            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferSize(
                                120, 30,
                            ))
                        }
                        pwsh_core::host::HostCallMethodWithParams::UIMethod(
                            pwsh_core::host::UIMethodParams::WriteProgress(source_id, record),
                        ) => {
                            info!(
                                target: "host",
                                method = "WriteProgress",
                                source_id = source_id,
                                record = %record,
                                "handling write progress"
                            );
                            HostCallMethodReturn::UIMethod(
                                pwsh_core::host::UIMethodReturn::WriteProgress,
                            )
                        }
                        other => {
                            warn!(target: "host", method = ?other, "host call method not implemented");
                            HostCallMethodReturn::Error(pwsh_core::host::HostError::NotImplemented)
                        }
                    };

                    let host_response = host_call.submit_result(response);
                    info!(
                        target: "host",
                        call_id = host_response.call_id,
                        "created host call response"
                    );

                    let user_event = UserOperation::SubmitHostResponse {
                        response: host_response,
                    };

                    user_input_tx
                        .send(user_event)
                        .await
                        .map_err(|e| {
                            error!(target: "host", error = %e, "failed to send host response to user input");
                            e
                        })
                        .context("Failed to send host response to user input")?;
                }
                ActiveSessionOutput::OperationSuccess => {
                    info!(target: "session", "operation completed successfully");
                }
            }
        }

        Ok(())
    }
}

impl RemoteAsyncPowershellClient {
    pub fn open_task(
        config: pwsh_core::connector::ConnectorConfig,
        client: impl HttpClient,
    ) -> (Self, impl std::future::Future<Output = anyhow::Result<()>>)
    where
        Self: Sized,
    {
        let (user_input_tx, user_input_rx) = mpsc::unbounded();
        let (user_output_tx, user_output_rx) = mpsc::unbounded();

        let user_input_tx_clone = user_input_tx.clone();
        let task = async move {
            let mut connector = Connector::new(config);
            info!("Created connector, starting connection...");

            let mut response = None;

            let (active_session, next_request) = loop {
                let step_result = connector
                    .step(response.take())
                    .context("Failed to step through connector")?;

                info!(step_result = ?step_result.name(), "Processing step result");

                match step_result {
                    ConnectorStepResult::SendBack(http_request) => {
                        // Make the HTTP request (using ureq for simplicity in example)
                        response = Some(client.send_request(http_request).await?);
                    }
                    ConnectorStepResult::SendBackError(e) => {
                        warn!("Connection step failed: {}", e);
                        anyhow::bail!("Connection failed: {}", e);
                    }
                    ConnectorStepResult::Connected {
                        active_session,
                        next_receive_request,
                    } => {
                        break (active_session, next_receive_request);
                    }
                }
            };

            client.send_request(next_request).await?;

            Self::start_active_session_loop(
                active_session,
                client,
                user_input_rx,
                user_output_tx,
                user_input_tx_clone,
            )
            .await?;

            Ok(())
        };

        (
            Self {
                user_input_tx,
                user_output_rx,
                message_cache: std::collections::HashMap::new(),
            },
            task,
        )
    }

    pub async fn send_command(&mut self, command: String) -> anyhow::Result<String> {
        let new_pipeline_id = uuid::Uuid::new_v4();

        self.user_input_tx
            .send(UserOperation::CreatePipeline {
                uuid: new_pipeline_id,
            })
            .await
            .context("Failed to send create pipeline operation")?;

        self.user_input_tx
            .send(UserOperation::OperatePipeline {
                powershell: pwsh_core::powershell::PipelineHandle::new(new_pipeline_id),
                operation: pwsh_core::connector::active_session::PowershellOperations::AddCommand {
                    command: PipelineCommand::new_script(command),
                },
            })
            .await
            .context("Failed to send add command operation")?;

        let mut pipeline_ended = false;
        let mut output = String::new();
        while !pipeline_ended {
            let events = self.receive_from_pipeline(new_pipeline_id).await?;

            for event in events {
                match event {
                    UserEvent::PipelineOutput { output: out, .. } => {
                        output.push_str(
                            &out.format_as_ps_string()
                                .context("Failed to format pipeline output")?,
                        );
                    }
                    UserEvent::PipelineFinished { .. } => {
                        pipeline_ended = true;
                    }
                    _ => {}
                }
            }
        }

        Ok(output)
    }

    async fn receive_from_pipeline(
        &mut self,
        pipeline_id: uuid::Uuid,
    ) -> anyhow::Result<Vec<UserEvent>> {
        if let Some(events) = self.message_cache.remove(&pipeline_id) {
            return Ok(events);
        }

        loop {
            if let Some(event) = self.user_output_rx.next().await {
                if event.pipeline_id() == pipeline_id {
                    return Ok(vec![event]);
                } else {
                    self.message_cache
                        .entry(event.pipeline_id())
                        .or_default()
                        .push(event);
                }
            }
        }
    }
}


--- File: crates/powershell-sync-client/Cargo.toml ---
[[bin]]
name = "powershell-sync-client"
path = "src/main.rs"

[package]
name = "powershell-sync"
version = "0.1.0"
edition = "2021"

[dependencies]
pwsh-core = { version = "0.1.0", path = "../pwsh-core" }
protocol-powershell-remoting = { version = "0.1.0", path = "../protocol-powershell-remoting" }
ureq = "2.10"
anyhow = "1.0"
regex = "1.0"
tracing = "0.1.41"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }
clap = { version = "4.5", features = ["derive"] }
uuid = { version = "1.18.0", features = ["v4"] }


--- File: crates/powershell-sync-client/src/config.rs ---
use std::net::IpAddr;

use clap::Parser;
use pwsh_core::connector::{http::ServerAddress, Authentication, ConnectorConfig, Scheme};
use tracing_subscriber::{fmt, prelude::*, registry::Registry, EnvFilter};

/// PowerShell Remoting Client (Synchronous)
#[derive(Parser)]
#[command(version, about, long_about = None)]
pub struct Args {
    /// Server IP address to connect to
    #[arg(short, long, default_value = "10.10.0.3", help = "Server IP address")]
    pub server: IpAddr,

    /// Server port to connect to
    #[arg(short, long, default_value = "5985", help = "Server port")]
    pub port: u16,

    /// Username for authentication
    #[arg(
        short,
        long,
        default_value = "Administrator",
        help = "Username for authentication"
    )]
    pub username: String,

    /// Password for authentication
    #[arg(
        short = 'P',
        long,
        default_value = "DevoLabs123!",
        help = "Password for authentication"
    )]
    pub password: String,

    /// Use HTTPS instead of HTTP
    #[arg(long, help = "Use HTTPS (default: HTTP)")]
    pub https: bool,

    /// Verbose logging (can be repeated for more verbosity)
    #[arg(short, long, action = clap::ArgAction::Count, help = "Increase logging verbosity")]
    pub verbose: u8,
}

/// Initialize logging with file output and proper structured logging
pub fn init_logging(verbose_level: u8) -> anyhow::Result<()> {
    let log_file = std::fs::File::create("winrm_client.log")?;

    // Determine log level based on verbosity using structured filters
    let log_level = match verbose_level {
        0 => "powershell_sync_client=info,pwsh_core=info,protocol_powershell_remoting=info,protocol_winrm=warn,ureq=error",
        1 => "powershell_sync_client=debug,pwsh_core=debug,protocol_powershell_remoting=debug,protocol_winrm=info,ureq=error",
        2 => "powershell_sync_client=trace,pwsh_core=trace,protocol_powershell_remoting=trace,protocol_winrm=debug,ureq=warn",
        _ => "trace",
    };

    let env_filter = EnvFilter::new(log_level);

    let subscriber = Registry::default().with(env_filter).with(
        fmt::layer()
            .with_writer(log_file)
            .with_target(true)
            .with_line_number(true)
            .with_file(true)
            .compact(),
    );

    tracing::subscriber::set_global_default(subscriber)?;
    Ok(())
}

/// Create connector configuration from command line arguments
pub fn create_connector_config(args: &Args) -> ConnectorConfig {
    let server = ServerAddress::Ip(args.server);
    let scheme = if args.https {
        Scheme::Https
    } else {
        Scheme::Http
    };
    let auth = Authentication::Basic {
        username: args.username.clone(),
        password: args.password.clone(),
    };

    ConnectorConfig {
        server: (server, args.port),
        scheme,
        authentication: auth,
        host_info: protocol_powershell_remoting::HostInfo::builder()
            .is_host_null(false)
            .is_host_ui_null(true)
            .is_host_raw_ui_null(true)
            .build(),
    }
}


--- File: crates/powershell-sync-client/src/connection.rs ---
use anyhow::Context;
use pwsh_core::connector::active_session::ActiveSession;
use pwsh_core::connector::{Connector, ConnectorConfig, ConnectorStepResult};
use tracing::{info, info_span, warn};

use crate::http_client::make_http_request;

/// Establish connection to the PowerShell remote server
pub fn establish_connection(
    config: ConnectorConfig,
) -> anyhow::Result<(
    ActiveSession,
    pwsh_core::connector::http::HttpRequest<String>,
)> {
    let mut connector = Connector::new(config);
    info!("Created connector, starting connection...");

    let mut response = None;
    let _span = info_span!("ConnectionLoop").entered();

    let (active_session, next_request) = loop {
        let step_result = connector
            .step(response.take())
            .context("Failed to step through connector")?;

        info!(step_result = ?step_result.name(), "Processing step result");

        match step_result {
            ConnectorStepResult::SendBack(http_request) => {
                // Make the HTTP request (using ureq for simplicity in example)
                response = Some(make_http_request(&http_request)?);
            }
            ConnectorStepResult::SendBackError(e) => {
                warn!("Connection step failed: {}", e);
                anyhow::bail!("Connection failed: {}", e);
            }
            ConnectorStepResult::Connected {
                active_session,
                next_receive_request,
            } => {
                break (active_session, next_receive_request);
            }
        }
    };

    drop(_span);
    Ok((active_session, next_request))
}


--- File: crates/powershell-sync-client/src/http_client.rs ---
use tracing::{debug, info};

/// Make an HTTP request using ureq (synchronous)
pub fn make_http_request(
    request: &pwsh_core::connector::http::HttpRequest<String>,
) -> Result<pwsh_core::connector::http::HttpResponse<String>, anyhow::Error> {
    info!("Making HTTP request to: {}", request.url);
    debug!("Request headers: {:?}", request.headers);
    debug!(
        "Request body length: {:?}",
        request.body.as_ref().map(|b| b.len())
    );

    // Build the HTTP client request
    let mut ureq_request = match request.method {
        pwsh_core::connector::http::Method::Post => ureq::post(&request.url),
        pwsh_core::connector::http::Method::Get => ureq::get(&request.url),
        pwsh_core::connector::http::Method::Put => ureq::put(&request.url),
        pwsh_core::connector::http::Method::Delete => ureq::delete(&request.url),
    };

    // Add headers
    for (name, value) in &request.headers {
        ureq_request = ureq_request.set(name, value);
    }

    // Add cookie if present
    if let Some(cookie) = &request.cookie {
        ureq_request = ureq_request.set("Cookie", cookie);
    }

    // Make the request
    let response = if let Some(body) = &request.body {
        ureq_request.send_string(body)?
    } else {
        ureq_request.call()?
    };

    // Read response
    let response_body = response.into_string()?;
    debug!("Response body length: {}", response_body.len());

    // Return as HttpResponse with proper response format
    Ok(pwsh_core::connector::http::HttpResponse {
        status_code: 200,
        headers: vec![],
        body: Some(response_body),
    })
}


--- File: crates/powershell-sync-client/src/main.rs ---
mod config;
mod connection;
mod http_client;
mod network;
mod types;
mod user_input;

use anyhow::Context;
use clap::Parser;
use pwsh_core::connector::active_session::UserEvent;
use pwsh_core::connector::ActiveSessionOutput;
use std::sync::mpsc;
use std::thread;
use tracing::{error, info, instrument, warn};

use config::{create_connector_config, init_logging, Args};
use connection::establish_connection;
use network::NetworkHandler;
use types::NextStep;
use user_input::UserInputHandler;

#[instrument(name = "main", level = "info")]
fn main() -> anyhow::Result<()> {
    // Parse command line arguments
    let args = Args::parse();

    // Initialize logging with the specified verbosity level
    init_logging(args.verbose)?;
    info!("Starting WinRM PowerShell client (Synchronous)");

    // Display connection information
    info!(
        server = %args.server,
        port = args.port,
        username = %args.username,
        scheme = %if args.https { "HTTPS" } else { "HTTP" },
        "connecting to server"
    );

    // Create configuration and establish connection
    let config = create_connector_config(&args);
    let (active_session, next_request) = establish_connection(config)?;
    info!("Runspace pool is now open and ready for operations!");

    // Set up communication channels
    let (network_request_tx, network_request_rx) = mpsc::channel();
    let (network_response_tx, network_response_rx) = mpsc::channel();
    let (user_request_tx, user_request_rx) = mpsc::channel();
    let (user_event_tx, user_event_rx) = mpsc::channel();

    // Spawn network handler
    let mut network_handler = NetworkHandler::new(network_request_rx, network_response_tx);
    let network_handle = thread::spawn(move || {
        network_handler.run();
    });

    // Spawn user input/UI handler
    let mut user_input_handler = UserInputHandler::new(user_request_tx.clone(), user_event_rx);
    let user_handle = thread::spawn(move || {
        user_input_handler.run();
    });

    // Send initial network request
    network_request_tx
        .send(next_request)
        .context("Failed to send initial request")?;

    // Run the main event loop
    run_event_loop(
        active_session,
        network_response_rx,
        user_request_rx,
        network_request_tx,
        user_event_tx,
    )
    .inspect_err(|e| error!("Error in main event loop: {}", e))?;

    info!("Exiting main function");
    // Clean up threads (they will exit when channels are dropped)
    drop(network_handle);
    drop(user_handle);
    Ok(())
}

/// Main event loop that processes network responses and user requests
#[instrument(level = "info", skip_all, fields(iterations = 0u64))]
fn run_event_loop(
    mut active_session: pwsh_core::connector::active_session::ActiveSession,
    network_response_rx: mpsc::Receiver<pwsh_core::connector::http::HttpResponse<String>>,
    user_request_rx: mpsc::Receiver<pwsh_core::connector::UserOperation>,
    network_request_tx: mpsc::Sender<pwsh_core::connector::http::HttpRequest<String>>,
    user_event_tx: mpsc::Sender<UserEvent>,
) -> anyhow::Result<()> {
    let span = tracing::Span::current();
    let mut iteration_count = 0u64;

    loop {
        iteration_count += 1;
        span.record("iterations", iteration_count);

        // Use select! equivalent for synchronous channels
        let next_step = select_sync(&network_response_rx, &user_request_rx)?;

        info!(next_step = %next_step, "processing step");

        let step_results = match next_step {
            NextStep::NetworkResponse(http_response) => {
                info!(
                    target: "network",
                    body_length = http_response.body.as_ref().map(|b| b.len()).unwrap_or(0),
                    "processing network response"
                );

                active_session
                    .accept_server_response(http_response)
                    .map_err(|e| {
                        error!(target: "network", error = %e, "failed to accept server response");
                        e
                    })
                    .context("Failed to accept server response")?
            }
            NextStep::UserRequest(user_operation) => {
                info!(target: "user", operation = ?user_operation, "processing user operation");

                vec![active_session
                    .accept_client_operation(*user_operation)
                    .map_err(|e| {
                        error!(target: "user", error = %e, "failed to accept user operation");
                        e
                    })
                    .context("Failed to accept user operation")?]
            }
        };

        info!(
            step_result_count = step_results.len(),
            "received server response, processing step results"
        );

        for step_result in step_results {
            info!(step_result = ?step_result, "processing step result");
            match step_result {
                ActiveSessionOutput::SendBack(http_requests) => {
                    info!(
                        target: "network",
                        request_count = http_requests.len(),
                        "sending HTTP requests"
                    );
                    for http_request in http_requests {
                        network_request_tx
                            .send(http_request)
                            .context("Failed to send HTTP request")?;
                    }
                }
                ActiveSessionOutput::SendBackError(e) => {
                    error!(target: "session", error = %e, "session step failed");
                    return Err(anyhow::anyhow!("Session step failed: {}", e));
                }
                ActiveSessionOutput::UserEvent(event) => {
                    info!(target: "user", event = ?event, "sending user event");
                    // Send all user events to the UI thread
                    if let Err(e) = user_event_tx.send(event) {
                        error!(target: "user", error = %e, "failed to send user event");
                    }
                }
                ActiveSessionOutput::HostCall(host_call) => {
                    info!(
                        target: "host",
                        method_name = %host_call.method_name,
                        call_id = host_call.call_id,
                        "received host call"
                    );

                    let method = host_call.get_param().map_err(|e| {
                        error!(target: "host", error = %e, "failed to parse host call parameters");
                        e
                    })?;

                    info!(target: "host", method = ?method, "processing host call method");

                    // Handle the host call and create a response
                    use pwsh_core::host::{HostCallMethodReturn, RawUIMethodReturn};

                    let response = match method {
                        // For GetBufferSize, return a default console buffer size
                        pwsh_core::host::HostCallMethodWithParams::RawUIMethod(
                            pwsh_core::host::RawUIMethodParams::GetBufferSize,
                        ) => {
                            info!(target: "host", method = "GetBufferSize", "returning default console size");
                            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferSize(
                                120, 30,
                            ))
                        }

                        // For WriteProgress, just acknowledge (void return)
                        pwsh_core::host::HostCallMethodWithParams::UIMethod(
                            pwsh_core::host::UIMethodParams::WriteProgress(source_id, record),
                        ) => {
                            info!(
                                target: "host",
                                method = "WriteProgress",
                                source_id = source_id,
                                record = %record,
                                "handling write progress"
                            );
                            HostCallMethodReturn::UIMethod(
                                pwsh_core::host::UIMethodReturn::WriteProgress,
                            )
                        }

                        // For other methods, return not implemented error for now
                        other => {
                            warn!(target: "host", method = ?other, "host call method not implemented");
                            HostCallMethodReturn::Error(pwsh_core::host::HostError::NotImplemented)
                        }
                    };

                    // Submit the response
                    let host_response = host_call.submit_result(response);
                    info!(
                        target: "host",
                        call_id = host_response.call_id,
                        "created host call response"
                    );

                    // For now, we're not sending the response back yet - that requires more infrastructure
                    // TODO: Implement sending host call responses back to the server
                }
                ActiveSessionOutput::OperationSuccess => {
                    info!(target: "session", "operation completed successfully");
                }
            }
        }
    }
}

/// Synchronous select equivalent for two receivers
fn select_sync(
    network_rx: &mpsc::Receiver<pwsh_core::connector::http::HttpResponse<String>>,
    user_rx: &mpsc::Receiver<pwsh_core::connector::UserOperation>,
) -> anyhow::Result<NextStep> {
    use std::sync::mpsc::TryRecvError;

    loop {
        // Try to receive from network first
        match network_rx.try_recv() {
            Ok(response) => return Ok(NextStep::NetworkResponse(response)),
            Err(TryRecvError::Empty) => {
                // Try user channel
                match user_rx.try_recv() {
                    Ok(request) => return Ok(NextStep::UserRequest(Box::new(request))),
                    Err(TryRecvError::Empty) => {
                        // Both channels empty, wait a bit and try again
                        thread::sleep(std::time::Duration::from_millis(10));
                        continue;
                    }
                    Err(TryRecvError::Disconnected) => {
                        return Err(anyhow::anyhow!("User request channel disconnected"));
                    }
                }
            }
            Err(TryRecvError::Disconnected) => {
                return Err(anyhow::anyhow!("Network response channel disconnected"));
            }
        }
    }
}


--- File: crates/powershell-sync-client/src/network.rs ---
use std::sync::mpsc;
use std::thread;
use tracing::{error, info_span};

use crate::http_client::make_http_request;

/// Network request handler (synchronous)
pub struct NetworkHandler {
    network_request_rx: mpsc::Receiver<pwsh_core::connector::http::HttpRequest<String>>,
    network_response_tx: mpsc::Sender<pwsh_core::connector::http::HttpResponse<String>>,
}

impl NetworkHandler {
    pub fn new(
        network_request_rx: mpsc::Receiver<pwsh_core::connector::http::HttpRequest<String>>,
        network_response_tx: mpsc::Sender<pwsh_core::connector::http::HttpResponse<String>>,
    ) -> Self {
        Self {
            network_request_rx,
            network_response_tx,
        }
    }

    pub fn run(&mut self) {
        let _span = info_span!("NetworkRequestHandler").entered();

        while let Ok(request) = self.network_request_rx.recv() {
            let network_response_tx = self.network_response_tx.clone();

            // Handle request in a separate thread to avoid blocking
            thread::spawn(move || match make_http_request(&request) {
                Ok(response) => {
                    if let Err(e) = network_response_tx.send(response) {
                        error!("Failed to send network response: {}", e);
                    }
                }
                Err(e) => {
                    error!("HTTP request failed: {}", e);
                }
            });
        }
    }
}


--- File: crates/powershell-sync-client/src/types.rs ---
use std::fmt;

use pwsh_core::connector::UserOperation;

/// Represents the next step in the event loop
#[derive(Debug)]
pub enum NextStep {
    NetworkResponse(pwsh_core::connector::http::HttpResponse<String>),
    UserRequest(Box<UserOperation>),
}

impl fmt::Display for NextStep {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            NextStep::NetworkResponse(_) => write!(f, "NetworkResponse"),
            NextStep::UserRequest(_) => write!(f, "UserRequest"),
        }
    }
}


--- File: crates/powershell-sync-client/src/user_input.rs ---
use protocol_powershell_remoting::PipelineOutput;
use pwsh_core::connector::active_session::PowershellOperations;
use pwsh_core::pipeline::PipelineCommand;
use pwsh_core::powershell::PipelineHandle;
use pwsh_core::{connector::UserOperation, powershell::PipelineOutputType};
use regex::Regex;
use std::io::{self, Write};
use std::sync::mpsc;
use std::time::Duration;
use tracing::{error, info, instrument};
use uuid::Uuid;

/// Handle user input for PowerShell commands (synchronous)
pub struct UserInputHandler {
    user_request_tx: mpsc::Sender<UserOperation>,
    user_event_rx: mpsc::Receiver<pwsh_core::connector::active_session::UserEvent>,
}

impl UserInputHandler {
    pub fn new(
        user_request_tx: mpsc::Sender<UserOperation>,
        user_event_rx: mpsc::Receiver<pwsh_core::connector::active_session::UserEvent>,
    ) -> Self {
        Self {
            user_request_tx,
            user_event_rx,
        }
    }

    #[instrument(skip_all, name = "user_input_handler")]
    pub fn run(&mut self) {
        let stdin = io::stdin();
        let mut stdout = io::stdout();
        let mut pipeline: Option<PipelineHandle> = None;

        info!("starting user input handler");
        self.user_request_tx
            .send(UserOperation::CreatePipeline {
                uuid: uuid::Uuid::new_v4(),
            })
            .expect("Failed to send create pipeline request");

        loop {
            // Check for user events
            match self.process_user_events(&mut pipeline) {
                PipelineOperated::Continue => continue,
                PipelineOperated::KeepGoing => {}
            }

            print!("> ");
            stdout.flush().unwrap();
            let mut line = String::new();
            match stdin.read_line(&mut line) {
                Ok(0) => break, // EOF
                Ok(_) => {
                    let command = line.trim().to_string();
                    if command.to_lowercase() == "exit" {
                        info!("user requested exit");
                        break;
                    }

                    if command.is_empty() {
                        continue;
                    }
                    // Ensure we have a pipeline before executing the command

                    if let Some(pipeline_handle) = pipeline {
                        // Add the script to the pipeline
                        if let Err(e) = self.user_request_tx.send(UserOperation::OperatePipeline {
                            powershell: pipeline_handle,
                            operation: PowershellOperations::AddCommand {
                                command: PipelineCommand::new_script(command),
                            },
                        }) {
                            error!(error = %e, "failed to send operation");
                            break;
                        }

                        // Invoke the pipeline
                        if let Err(e) = self.user_request_tx.send(UserOperation::InvokePipeline {
                            powershell: pipeline_handle,
                            output_type: PipelineOutputType::Streamed,
                        }) {
                            error!(error = %e, "failed to send invoke");
                            break;
                        }
                    }
                }
                Err(e) => {
                    error!(error = %e, "failed to read input");
                    break;
                }
            }
        }
    }

    #[instrument(skip_all)]
    fn process_user_events(&mut self, pipeline: &mut Option<PipelineHandle>) -> PipelineOperated {
        while let Ok(event) = self.user_event_rx.recv_timeout(Duration::from_millis(100)) {
            match event {
                pwsh_core::connector::active_session::UserEvent::PipelineCreated { powershell } => {
                    info!(pipeline_id = %powershell.id(), "pipeline created");
                    *pipeline = Some(powershell);
                    return PipelineOperated::KeepGoing;
                }
                pwsh_core::connector::active_session::UserEvent::PipelineFinished {
                    powershell,
                } => {
                    info!(pipeline_id = %powershell.id(), "pipeline finished");
                    if let Some(current_pipeline) = pipeline {
                        if *current_pipeline == powershell {
                            *pipeline = None;
                            self.user_request_tx
                                .send(UserOperation::CreatePipeline {
                                    uuid: Uuid::new_v4(),
                                })
                                .expect("Failed to send create pipeline request");
                        }
                    }
                }
                pwsh_core::connector::active_session::UserEvent::PipelineOutput {
                    output,
                    powershell,
                } => {
                    info!(pipeline_id = %powershell.id(), "pipeline output: {:?}", output);
                    if let Some(current_pipeline) = pipeline {
                        if *current_pipeline == powershell {
                            println!(
                                "{}",
                                format_pipeline_output(&output).unwrap_or_else(|e| {
                                    error!(error = %e, "failed to format pipeline output");
                                    "Error formatting output".to_string()
                                })
                            );
                        }
                    }
                }
            }
        }
        PipelineOperated::Continue
    }
}

fn format_pipeline_output(output: &PipelineOutput) -> Result<String, anyhow::Error> {
    let Some(output_str) = output.data.as_string() else {
        return Err(anyhow::anyhow!("Pipeline output is not a string"));
    };

    decode_escaped_ps_string(&output_str)
}

/// Decode PowerShell Remoting Protocol escape sequences, like _x000A_
/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/301404a9-232f-439c-8644-1a213675bfac
fn decode_escaped_ps_string(input: &str) -> Result<String, anyhow::Error> {
    if input.is_empty() {
        return Ok(String::new());
    }

    // Split with capturing parentheses to include the separator in the resulting array
    let regex =
        Regex::new(r"(_x[0-9A-F]{4}_)").map_err(|e| anyhow::anyhow!("Regex error: {}", e))?;
    let parts: Vec<&str> = regex.split(input).collect();

    if parts.len() <= 1 {
        return Ok(input.to_string());
    }

    let mut result = String::new();
    let mut high_surrogate: Option<u16> = None;

    // We need to manually handle the split parts and captures
    let mut current_pos = 0;
    for captures in regex.find_iter(input) {
        // Add the text before the match
        if captures.start() > current_pos {
            result.push_str(&input[current_pos..captures.start()]);
            high_surrogate = None;
        }

        // Process the escaped sequence
        let escaped = captures.as_str();
        if let Some(hex_str) = escaped.strip_prefix("_x").and_then(|s| s.strip_suffix("_")) {
            match u16::from_str_radix(hex_str, 16) {
                Ok(code_unit) => {
                    if let Some(high) = high_surrogate {
                        // We have a high surrogate from before, try to form a surrogate pair
                        if (0xDC00..=0xDFFF).contains(&code_unit) {
                            // This is a low surrogate, form the pair
                            let code_point = 0x10000
                                + ((high as u32 - 0xD800) << 10)
                                + (code_unit as u32 - 0xDC00);
                            if let Some(ch) = char::from_u32(code_point) {
                                result.push(ch);
                            } else {
                                // Invalid code point, add the escaped sequence as-is
                                result.push_str(escaped);
                            }
                            high_surrogate = None;
                        } else {
                            // Not a low surrogate, add the previous high surrogate as-is and process this one
                            result.push_str("_x");
                            result.push_str(&format!("{high:04X}"));
                            result.push('_');

                            if (0xD800..=0xDBFF).contains(&code_unit) {
                                high_surrogate = Some(code_unit);
                            } else {
                                if let Some(ch) = char::from_u32(code_unit as u32) {
                                    result.push(ch);
                                } else {
                                    result.push_str(escaped);
                                }
                                high_surrogate = None;
                            }
                        }
                    } else if (0xD800..=0xDBFF).contains(&code_unit) {
                        // High surrogate, save it for the next iteration
                        high_surrogate = Some(code_unit);
                    } else {
                        // Regular character or low surrogate without high surrogate
                        if let Some(ch) = char::from_u32(code_unit as u32) {
                            result.push(ch);
                        } else {
                            // Invalid character, add the escaped sequence as-is
                            result.push_str(escaped);
                        }
                        high_surrogate = None;
                    }
                }
                Err(_) => {
                    // Invalid hex, add the escaped sequence as-is
                    result.push_str(escaped);
                    high_surrogate = None;
                }
            }
        } else {
            // Not a valid escape sequence, add as-is
            result.push_str(escaped);
            high_surrogate = None;
        }

        current_pos = captures.end();
    }

    // Add any remaining text after the last match
    if current_pos < input.len() {
        result.push_str(&input[current_pos..]);
    }

    // If we have an unmatched high surrogate at the end, add it as-is
    if let Some(high) = high_surrogate {
        result.push_str("_x");
        result.push_str(&format!("{high:04X}"));
        result.push('_');
    }

    Ok(result)
}

pub enum PipelineOperated {
    Continue,
    KeepGoing,
}


--- File: crates/protocol-macros/Cargo.toml ---
[package]
name = "protocol-macros"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true

[dependencies]
proc-macro2 = "1.0"
quote = "1.0"
syn = { version = "2.0", features = ["full", "extra-traits"] }


--- File: crates/protocol-macros/src/lib.rs ---
use proc_macro::TokenStream;
use proc_macro2::{Ident, TokenStream as TokenStream2};
use quote::{format_ident, quote};
use syn::{parse_macro_input, Data, DeriveInput, Fields, Generics, Type, TypePath};

/// Derives TagValue implementation for structs where all fields are `Option<Tag<'a, ValueType, TagName>>`
///
/// This macro assumes that all fields in the struct are optional Tag fields and generates
/// a TagValue implementation that converts each Some(tag) to an element and adds it to the
/// XML element's children.
#[proc_macro_derive(SimpleTagValue)]
pub fn derive_simple_tag_value(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let expanded = impl_simple_tag_value(&input);
    TokenStream::from(expanded)
}

/// Derives XmlDeserialize implementation for structs where all fields are `Option<Tag<'a, ValueType, TagName>>`
///
/// This macro assumes that all fields in the struct are optional Tag fields and generates
/// a complete XmlDeserialize implementation with visitor pattern that can parse XML nodes
/// into the struct by matching tag names to field names.
#[proc_macro_derive(SimpleXmlDeserialize)]
pub fn derive_simple_xml_deserialize(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let expanded = impl_simple_xml_deserialize(&input);
    TokenStream::from(expanded)
}

fn impl_simple_tag_value(input: &DeriveInput) -> TokenStream2 {
    let name = &input.ident;
    let generics = &input.generics;
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => panic!("SimpleTagValue can only be derived for structs with named fields"),
        },
        _ => panic!("SimpleTagValue can only be derived for structs"),
    };

    // Classify fields as required (Tag<..>) or optional (Option<Tag<..>>)
    let field_info: Vec<FieldInfo> = fields
        .iter()
        .map(|field| {
            let field_name = field.ident.as_ref().unwrap();
            let is_optional = is_option_type(&field.ty);
            FieldInfo {
                name: field_name,
                is_optional,
            }
        })
        .collect();

    let field_list = {
        let field_names: Vec<&Ident> = field_info.iter().map(|f| f.name).collect();
        quote! { #(#field_names),* }
    };

    // Generate code for each field based on whether it's optional or required
    let field_additions: Vec<TokenStream2> = field_info
        .iter()
        .map(|field| {
            let field_name = field.name;
            if field.is_optional {
                quote! {
                    if let Some(tag) = #field_name {
                        array.push(tag.into_element());
                    }
                }
            } else {
                quote! {
                    array.push(#field_name.into_element());
                }
            }
        })
        .collect();

    quote! {
        impl #impl_generics crate::cores::TagValue<'a> for #name #ty_generics #where_clause {
            fn append_to_element(self, element: xml::builder::Element<'a>) -> xml::builder::Element<'a> {
                let Self { #field_list } = self;

                let mut array = Vec::new();

                #(#field_additions)*

                element.add_children(array)
            }
        }
    }
}

fn impl_simple_xml_deserialize(input: &DeriveInput) -> TokenStream2 {
    let name = &input.ident;
    let generics = &input.generics;

    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => panic!("RegularXmlDeserialize can only be derived for structs with named fields"),
        },
        _ => panic!("RegularXmlDeserialize can only be derived for structs"),
    };

    let visitor_name = format_ident!("{}Visitor", name);

    // Extract field information - handle both Tag<..> and Option<Tag<..>>
    let field_entries: Vec<SimpleFieldEntry> = fields
        .iter()
        .map(|field| {
            let field_name = field.ident.as_ref().unwrap().clone();
            let field_type = field.ty.clone();
            let is_optional = is_option_type(&field_type);
            let tag_name_type = extract_tag_name_type(&field_type);

            SimpleFieldEntry {
                field_name,
                field_type,
                tag_name_type,
                is_optional,
            }
        })
        .collect();

    // Generate Visitor struct
    let visitor_struct = generate_simple_visitor_struct(&visitor_name, generics, &field_entries);

    // Generate XmlVisitor implementation
    let xml_visitor_impl =
        generate_simple_xml_visitor_impl(&visitor_name, name, generics, &field_entries);

    // Generate XmlDeserialize implementation
    let xml_deserialize_impl = generate_xml_deserialize_impl(name, &visitor_name, generics);

    quote! {
        #visitor_struct
        #xml_visitor_impl
        #xml_deserialize_impl
    }
}

struct SimpleFieldEntry {
    field_name: Ident,
    field_type: Type,
    tag_name_type: Option<Ident>,
    is_optional: bool,
}

struct FieldInfo<'a> {
    name: &'a Ident,
    is_optional: bool,
}

fn generate_simple_visitor_struct(
    visitor_name: &Ident,
    generics: &Generics,
    field_entries: &[SimpleFieldEntry],
) -> TokenStream2 {
    let (impl_generics, _ty_generics, where_clause) = generics.split_for_impl();

    let visitor_fields: Vec<TokenStream2> = field_entries
        .iter()
        .map(|entry| {
            let field_name = &entry.field_name;
            let field_type = &entry.field_type;
            if entry.is_optional {
                // Optional fields stay as Option<Tag<..>> in visitor
                quote! { pub #field_name: #field_type }
            } else {
                // Required fields are stored as Option<Tag<..>> during parsing, then validated
                quote! { pub #field_name: Option<#field_type> }
            }
        })
        .collect();

    quote! {
        #[derive(Debug, Clone, Default)]
        pub struct #visitor_name #impl_generics #where_clause {
            #(#visitor_fields),*
        }
    }
}

fn generate_simple_xml_visitor_impl(
    visitor_name: &Ident,
    struct_name: &Ident,
    generics: &Generics,
    field_entries: &[SimpleFieldEntry],
) -> TokenStream2 {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    // Generate match arms for each field
    let match_arms: Vec<TokenStream2> = field_entries
        .iter()
        .filter_map(|entry| {
            if let Some(tag_name_type) = &entry.tag_name_type {
                let field_name = &entry.field_name;
                Some(quote! {
                    crate::cores::#tag_name_type::TAG_NAME => {
                        self.#field_name = Some(xml::parser::XmlDeserialize::from_node(child)?);
                    }
                })
            } else {
                None
            }
        })
        .collect();

    // Generate field list for finish method
    let field_names: Vec<&Ident> = field_entries.iter().map(|f| &f.field_name).collect();
    let field_list = quote! { #(#field_names),* };

    // Separate required and optional fields for finish method
    let required_fields: Vec<&SimpleFieldEntry> =
        field_entries.iter().filter(|f| !f.is_optional).collect();
    let _optional_fields: Vec<&SimpleFieldEntry> =
        field_entries.iter().filter(|f| f.is_optional).collect();

    // Generate required field checks - use different variable names to avoid conflicts
    let required_field_checks: Vec<TokenStream2> = required_fields
        .iter()
        .map(|entry| {
            let field_name = &entry.field_name;
            let checked_field_name = format_ident!("{}_checked", field_name);
            quote! {
                let #checked_field_name = #field_name.ok_or_else(|| {
                    xml::XmlError::InvalidXml(format!(
                        "Missing {} in {}",
                        stringify!(#field_name),
                        stringify!(#struct_name)
                    ))
                })?;
            }
        })
        .collect();

    // Generate field assignments for struct construction
    let field_assignments: Vec<TokenStream2> = field_entries
        .iter()
        .map(|entry| {
            let field_name = &entry.field_name;
            if entry.is_optional {
                // Optional fields pass through as-is
                quote! { #field_name }
            } else {
                // Required fields use the checked version
                let checked_field_name = format_ident!("{}_checked", field_name);
                quote! { #field_name: #checked_field_name }
            }
        })
        .collect();

    // Generate final field list for struct construction
    let _final_field_list: Vec<&Ident> = field_entries.iter().map(|f| &f.field_name).collect();

    quote! {
        impl #impl_generics xml::parser::XmlVisitor<'a> for #visitor_name #ty_generics #where_clause {
            type Value = #struct_name #ty_generics;

            fn visit_children(
                &mut self,
                children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
            ) -> Result<(), xml::XmlError> {
                for child in children {
                    if !child.is_element() {
                        continue; // Skip non-element nodes like text/whitespace
                    }

                    let tag_name = child.tag_name().name();
                    let namespace = child.tag_name().namespace();

                    match tag_name {
                        #(#match_arms)*
                        _ => {
                            return Err(xml::XmlError::InvalidXml(format!(
                                "Unknown tag in {}: {tag_name}", stringify!(#struct_name)
                            )));
                        }
                    }
                }

                Ok(())
            }

            fn visit_node(&mut self, node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
                // Get the children and process them
                let children: Vec<_> = node.children().collect();

                self.visit_children(children.into_iter())?;
                Ok(())
            }

            fn finish(self) -> Result<Self::Value, xml::XmlError> {
                let Self { #field_list } = self;

                // Check required fields and extract values
                #(#required_field_checks)*

                Ok(#struct_name {
                    #(#field_assignments),*
                })
            }
        }
    }
}

fn is_option_type(ty: &Type) -> bool {
    if let Type::Path(TypePath { path, .. }) = ty {
        if let Some(segment) = path.segments.first() {
            return segment.ident == "Option";
        }
    }
    false
}

fn extract_tag_name_type(ty: &Type) -> Option<Ident> {
    // Try to extract TagName from Tag<'a, ValueType, TagName> or Option<Tag<'a, ValueType, TagName>>
    if let Type::Path(TypePath { path, .. }) = ty {
        for segment in &path.segments {
            if segment.ident == "Tag" || segment.ident == "Option" {
                if let syn::PathArguments::AngleBracketed(args) = &segment.arguments {
                    // For Option<Tag<...>>, we need to look at the inner type
                    for arg in &args.args {
                        if let syn::GenericArgument::Type(inner_type) = arg {
                            if let Some(tag_name) = extract_tag_name_from_tag_type(inner_type) {
                                return Some(tag_name);
                            }
                        }
                    }

                    // For Tag<'a, ValueType, TagName>, the third argument is TagName
                    if segment.ident == "Tag" && args.args.len() >= 3 {
                        if let syn::GenericArgument::Type(Type::Path(TypePath { path, .. })) =
                            &args.args[2]
                        {
                            if let Some(segment) = path.segments.last() {
                                return Some(segment.ident.clone());
                            }
                        }
                    }
                }
            }
        }
    }
    None
}

fn extract_tag_name_from_tag_type(ty: &Type) -> Option<Ident> {
    if let Type::Path(TypePath { path, .. }) = ty {
        for segment in &path.segments {
            if segment.ident == "Tag" {
                if let syn::PathArguments::AngleBracketed(args) = &segment.arguments {
                    if args.args.len() >= 3 {
                        if let syn::GenericArgument::Type(Type::Path(TypePath { path, .. })) =
                            &args.args[2]
                        {
                            if let Some(segment) = path.segments.last() {
                                return Some(segment.ident.clone());
                            }
                        }
                    }
                }
            }
        }
    }
    None
}

fn generate_xml_deserialize_impl(
    struct_name: &Ident,
    visitor_name: &Ident,
    generics: &Generics,
) -> TokenStream2 {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    quote! {
        impl #impl_generics xml::parser::XmlDeserialize<'a> for #struct_name #ty_generics #where_clause {
            type Visitor = #visitor_name #ty_generics;

            fn visitor() -> Self::Visitor {
                #visitor_name::default()
            }

            fn from_node(node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
                xml::parser::NodeDeserializer::new(node).deserialize(Self::visitor())
            }
        }
    }
}


--- File: crates/protocol-powershell-remoting/Cargo.toml ---
[package]
name = "protocol-powershell-remoting"
version = "0.1.0"
edition = "2024"

[dependencies]
base64 = "0.22.1"
byteorder = "1.5.0"
quick-xml = { version = "0.38.0", features = [
    "serde",
    "serde-types",
    "serialize",
] }
regex = "1.11.2"
serde = { version = "1.0.219", features = ["derive"] }
thiserror = "2.0.12"
tracing = "0.1.41"
typed-builder = "0.21.0"
uuid = { version = "1.17.0", features = ["v4"] }
xml = { version = "0.1.0", path = "../xml" }

[dev-dependencies]
tracing-test = { version = "0.2.4", features = ["no-env-filter"] }
tracing-subscriber = { version = "0.3.17", features = ["fmt", "env-filter"] }


--- File: crates/protocol-powershell-remoting/examples/analyze.rs ---
use base64::Engine;
use protocol_powershell_remoting::{
    ComplexObject, DefragmentResult, Defragmenter,
    messages::deserialize::{DeserializationContext, PsXmlDeserialize},
};
use std::env;
use std::fs;
use std::io::{self, Write};
use std::path::Path;

fn print_usage() {
    eprintln!("PowerShell Remoting Protocol Analyzer");
    eprintln!();
    eprintln!("Usage:");
    eprintln!(
        "  {} <base64_encoded_message>",
        env::args().next().unwrap_or_else(|| "analyze".to_string())
    );
    eprintln!(
        "  {} --file <file_path>",
        env::args().next().unwrap_or_else(|| "analyze".to_string())
    );
    eprintln!(
        "  {} --multi <fragment1> <fragment2> ...",
        env::args().next().unwrap_or_else(|| "analyze".to_string())
    );
    eprintln!(
        "  echo '<base64_encoded_message>' | {}",
        env::args().next().unwrap_or_else(|| "analyze".to_string())
    );
    eprintln!();
    eprintln!("Description:");
    eprintln!(
        "  Parses and displays PowerShell remoting protocol messages in a human-readable format."
    );
    eprintln!("  Input should be a base64-encoded PowerShell remoting message or fragment.");
    eprintln!("  Use --multi flag to defragment multiple fragments into complete messages.");
    eprintln!();
    eprintln!("Examples:");
    eprintln!(
        "  {} 'AAAAAAAAAAEAAAAAAAAAAAMAAADKAgAAAAIAAQDQ...'",
        env::args().next().unwrap_or_else(|| "analyze".to_string())
    );
    eprintln!(
        "  {} --file message.txt",
        env::args().next().unwrap_or_else(|| "analyze".to_string())
    );
    eprintln!(
        "  {} --multi 'fragment1_base64' 'fragment2_base64' 'fragment3_base64'",
        env::args().next().unwrap_or_else(|| "analyze".to_string())
    );
    eprintln!(
        "  cat message.txt | {}",
        env::args().next().unwrap_or_else(|| "analyze".to_string())
    );
}

fn get_input() -> Result<String, Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();

    if args.len() > 1 {
        if args[1] == "--help" || args[1] == "-h" {
            print_usage();
            std::process::exit(0);
        }

        // Handle --file flag
        if args[1] == "--file" && args.len() > 2 {
            let file_path = &args[2];
            println!("📁 Reading from file: {}", file_path);

            if !Path::new(file_path).exists() {
                return Err(format!("File not found: {}", file_path).into());
            }

            let file_content = fs::read_to_string(file_path)?;
            let content = file_content.trim().to_string();

            if content.is_empty() {
                return Err("File is empty".into());
            }

            println!(
                "✅ Successfully read {} characters from file",
                content.len()
            );
            return Ok(content);
        }

        // Use command line argument as base64 message
        Ok(args[1].clone())
    } else {
        // Interactive mode - prompt user for input
        println!("PowerShell Remoting Protocol Analyzer");
        println!("=====================================");
        println!();
        println!("Please paste your base64-encoded PowerShell remoting message:");
        println!("(Press Enter when done, or type 'exit' to quit)");
        println!();
        print!("> ");
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let input = input.trim().to_string();

        if input.is_empty() {
            return Err("No input provided".into());
        }

        if input.to_lowercase() == "exit" {
            println!("Goodbye!");
            std::process::exit(0);
        }

        Ok(input)
    }
}

fn print_separator(title: &str) {
    println!("\n{}", "=".repeat(80));
    println!("{:^80}", title);
    println!("{}", "=".repeat(80));
}

fn print_section(title: &str) {
    println!("\n{}", "-".repeat(60));
    println!("{}", title);
    println!("{}", "-".repeat(60));
}

fn try_defragment_multiple_messages(
    messages: &[&str],
) -> Result<Vec<protocol_powershell_remoting::PowerShellRemotingMessage>, Box<dyn std::error::Error>>
{
    print_section("Multi-Fragment Defragmentation");
    println!(
        "📦 Processing {} fragment(s) for reassembly...",
        messages.len()
    );

    let mut defragmenter = Defragmenter::new();
    let mut completed_messages = Vec::new();
    let engine = base64::engine::general_purpose::STANDARD;

    for (i, msg) in messages.iter().enumerate() {
        let fragment_data = engine.decode(msg.trim())?;
        println!(
            "🔍 Fragment {}: Decoded {} bytes from base64",
            i + 1,
            fragment_data.len()
        );

        match defragmenter.defragment(&fragment_data) {
            Ok(DefragmentResult::Complete(mut msgs)) => {
                if msgs.is_empty() {
                    println!("⏳ Fragment {} processed, no complete messages yet", i + 1);
                } else {
                    println!("✅ Fragment {} completed {} message(s)!", i + 1, msgs.len());
                }
                completed_messages.append(&mut msgs);
            }
            Ok(DefragmentResult::Incomplete) => {
                println!(
                    "⏳ Fragment {} processed, waiting for more fragments to complete message(s)",
                    i + 1
                );
            }
            Err(e) => {
                println!("❌ Error processing fragment {}: {}", i + 1, e);
                return Err(e.into());
            }
        }
    }

    if defragmenter.pending_count() > 0 {
        println!(
            "⚠️  Warning: {} incomplete message(s) still in buffer (may need more fragments)",
            defragmenter.pending_count()
        );
    }

    if completed_messages.is_empty() {
        println!(
            "ℹ️  No complete messages assembled - fragments may be incomplete or out of order"
        );
    } else {
        println!(
            "🎉 Defragmentation successful! Assembled {} complete PowerShell remoting message(s)",
            completed_messages.len()
        );
    }
    Ok(completed_messages)
}

fn analyze_message(base64_message: &str) -> Result<(), Box<dyn std::error::Error>> {
    print_separator("POWERSHELL REMOTING PROTOCOL ANALYZER");

    // Decode base64
    print_section("1. Base64 Decoding");
    let engine = base64::engine::general_purpose::STANDARD;
    let message = engine.decode(base64_message.trim())?;
    println!(
        "✅ Successfully decoded {} bytes from base64 input",
        message.len()
    );

    // Parse PowerShell Fragment
    print_section("2. PowerShell Remoting Message Parsing");
    let message_slice = message.as_slice();
    let mut defragmenter = Defragmenter::new();
    let messages = match defragmenter.defragment(message_slice)? {
        DefragmentResult::Incomplete => {
            println!(
                "⚠️  This appears to be a fragment that requires additional fragments to complete"
            );
            println!(
                "💡 Try using the --multi flag with all fragments to reassemble the complete message"
            );
            return Err("Incomplete message, waiting for more fragments".into());
        }
        DefragmentResult::Complete(power_shell_remoting_messages) => power_shell_remoting_messages,
    };

    println!(
        "🎉 Successfully parsed {} complete PowerShell remoting message(s)",
        messages.len()
    );

    print_section("3. Message Summary");
    for (i, msg) in messages.iter().enumerate() {
        println!("📨 Message {} Details:", i + 1);
        println!("   📋 Type: {:?}", msg.message_type);
        println!("   🎯 Destination: {:?}", msg.destination);
        println!("   🆔 Runspace Pool ID: {}", msg.rpid);
        if let Some(pid) = msg.pid {
            println!("   🔗 Pipeline ID: {}", pid);
        }
        println!("   📏 Data Size: {} bytes", msg.data.len());
        println!();
    }

    for (msg_idx, pwsh_remoting_message) in messages.iter().enumerate() {
        if messages.len() > 1 {
            print_separator(&format!("ANALYZING MESSAGE {}", msg_idx + 1));
        }
        print_section("4. Data Extraction & UTF-8 Decoding");
        let parsed_string_data = match str::from_utf8(&pwsh_remoting_message.data) {
            Ok(s) => s,
            Err(e) => {
                println!("⚠️  Warning: Message data is not valid UTF-8: {}", e);
                println!(
                    "🔍 Raw binary data (first 100 bytes): {:?}",
                    &pwsh_remoting_message.data
                        [..std::cmp::min(100, pwsh_remoting_message.data.len())]
                );
                println!("💡 This might be binary data or use a different encoding");
                continue;
            }
        };

        println!(
            "✅ Successfully decoded UTF-8 string ({} characters)",
            parsed_string_data.len()
        );

        println!("📄 Complete XML Data:");
        println!("{}", parsed_string_data);

        // Parse XML
        print_section("5. XML Structure Analysis");
        let xml_representation = match xml::parser::parse(parsed_string_data) {
            Ok(xml) => xml,
            Err(e) => {
                println!("❌ Failed to parse XML structure: {}", e);
                println!("💡 The data may not be valid XML or may be corrupted");
                continue;
            }
        };

        println!("✅ Successfully parsed XML structure");
        let root_element = xml_representation.root_element();
        println!("🏷️  Root XML element: <{}>", root_element.tag_name().name());

        // Parse PowerShell Object
        print_section("6. PowerShell Object Conversion");
        let mut context = DeserializationContext::new();
        let ps_object = match ComplexObject::from_node_with_context(root_element, &mut context) {
            Ok(obj) => obj,
            Err(e) => {
                println!("❌ Failed to convert XML to PowerShell object: {}", e);
                println!("🔍 Available XML attributes:");
                for attr in root_element.attributes() {
                    println!("   • {}: {}", attr.name(), attr.value());
                }
                println!("💡 The XML structure may not match expected PowerShell object format");
                continue;
            }
        };

        println!("✅ Successfully converted to PowerShell object representation");

        // Display formatted PowerShell Object
        print_section("7. PowerShell Object Details");
        println!("{}", ps_object);
    }

    print_separator("ANALYSIS COMPLETE");
    println!("🎉 Successfully analyzed all PowerShell remoting messages!");

    Ok(())
}

pub fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();

    // Check for --multi flag for defragmentation
    if args.len() > 2 && args[1] == "--multi" {
        print_separator("MULTI-FRAGMENT DEFRAGMENTATION MODE");
        let fragments: Vec<&str> = args[2..].iter().map(|s| s.as_str()).collect();

        match try_defragment_multiple_messages(&fragments) {
            Ok(messages) => {
                if messages.is_empty() {
                    println!(
                        "ℹ️  No complete messages could be assembled from the provided fragments"
                    );
                    println!(
                        "💡 This may indicate fragments are missing, out of order, or corrupted"
                    );
                    std::process::exit(1);
                }

                for (i, message) in messages.iter().enumerate() {
                    print_separator(&format!("DEFRAGMENTED MESSAGE {} SUMMARY", i + 1));
                    println!("📨 Message Type: {:?}", message.message_type);
                    println!("🎯 Destination: {:?}", message.destination);
                    println!("🆔 Runspace Pool ID: {}", message.rpid);
                    if let Some(pid) = message.pid {
                        println!("🔗 Pipeline ID: {}", pid);
                    }
                    println!("📏 Data Size: {} bytes", message.data.len());
                    println!("✅ Message successfully reconstructed from fragments!");
                }

                println!(
                    "\n💡 Use single message mode to perform detailed analysis of each message"
                );
                std::process::exit(0);
            }
            Err(e) => {
                eprintln!("\n❌ Error during defragmentation: {}", e);
                eprintln!("💡 Tips for troubleshooting:");
                eprintln!("   • Ensure all fragments are valid base64-encoded data");
                eprintln!("   • Check that fragments are provided in the correct order");
                eprintln!("   • Verify that no fragments are missing from the sequence");
                eprintln!("   • Make sure fragments belong to the same original message");
                std::process::exit(1);
            }
        }
    }

    // If command line argument provided, analyze once and exit
    if args.len() > 1 {
        match get_input() {
            Ok(input) => match analyze_message(&input) {
                Ok(()) => std::process::exit(0),
                Err(e) => {
                    eprintln!("\n❌ Analysis failed: {}", e);
                    eprintln!("💡 Troubleshooting suggestions:");
                    eprintln!("   • Verify the input is valid base64-encoded data");
                    eprintln!(
                        "   • Check if this is a fragment that needs other fragments (try --multi)"
                    );
                    eprintln!("   • Ensure the data represents a PowerShell remoting message");
                    std::process::exit(1);
                }
            },
            Err(e) => {
                eprintln!("❌ Input error: {}", e);
                eprintln!("💡 Use --help for usage information");
                std::process::exit(1);
            }
        }
    } else {
        // Interactive mode - continuous loop
        println!("🔍 PowerShell Remoting Protocol Analyzer - Interactive Mode");
        println!("============================================================");
        println!();
        println!("📝 Commands:");
        println!("   • Enter base64-encoded PowerShell remoting messages to analyze");
        println!("   • Type 'multi' to enter multi-fragment defragmentation mode");
        println!("   • Type 'help' for usage information");
        println!("   • Type 'exit' or 'quit' to end the session");
        println!();

        loop {
            print!("> ");
            io::stdout().flush()?;

            let mut input = String::new();
            match io::stdin().read_line(&mut input) {
                Ok(_) => {
                    let input = input.trim().to_string();

                    if input.is_empty() {
                        continue;
                    }

                    if input.to_lowercase() == "exit" || input.to_lowercase() == "quit" {
                        println!("Goodbye!");
                        break;
                    }

                    if input == "help" || input == "--help" || input == "-h" {
                        print_usage();
                        continue;
                    }

                    if input == "multi" {
                        println!("🔧 Entering multi-fragment defragmentation mode");
                        println!("📝 Instructions:");
                        println!("   • Enter each fragment as base64-encoded data");
                        println!("   • Type 'done' when all fragments are entered");
                        println!("   • Type 'cancel' to abort and return to main mode");
                        println!();

                        let mut fragments = Vec::new();

                        loop {
                            print!("fragment {}> ", fragments.len() + 1);
                            io::stdout().flush()?;

                            let mut fragment_input = String::new();
                            io::stdin().read_line(&mut fragment_input)?;
                            let fragment_input = fragment_input.trim();

                            if fragment_input.is_empty() {
                                continue;
                            }

                            if fragment_input == "done" {
                                if fragments.is_empty() {
                                    println!(
                                        "⚠️  No fragments entered. Please add at least one fragment or type 'cancel'."
                                    );
                                    continue;
                                }
                                break;
                            }

                            if fragment_input == "cancel" {
                                println!("❌ Multi-fragment mode cancelled");
                                fragments.clear();
                                break;
                            }

                            fragments.push(fragment_input.to_string());
                            println!(
                                "✅ Added fragment {} (base64 length: {} characters)",
                                fragments.len(),
                                fragment_input.len()
                            );
                        }

                        if !fragments.is_empty() {
                            let fragment_refs: Vec<&str> =
                                fragments.iter().map(|s| s.as_str()).collect();
                            match try_defragment_multiple_messages(&fragment_refs) {
                                Ok(messages) => {
                                    if messages.is_empty() {
                                        println!(
                                            "ℹ️  No complete messages assembled from fragments"
                                        );
                                    } else {
                                        for (i, message) in messages.iter().enumerate() {
                                            print_separator(&format!(
                                                "DEFRAGMENTED MESSAGE {}",
                                                i + 1
                                            ));
                                            println!("📨 Message Type: {:?}", message.message_type);
                                            println!("🎯 Destination: {:?}", message.destination);
                                            println!("🆔 Runspace Pool ID: {}", message.rpid);
                                            if let Some(pid) = message.pid {
                                                println!("🔗 Pipeline ID: {}", pid);
                                            }
                                            println!("📏 Data Size: {} bytes", message.data.len());
                                        }
                                    }
                                }
                                Err(e) => {
                                    eprintln!("❌ Defragmentation error: {}", e);
                                    eprintln!(
                                        "💡 Check that fragments are valid and in correct order"
                                    );
                                }
                            }
                        }

                        println!("\n{}", "=".repeat(80));
                        println!("🔄 Ready for next message or command...");
                        continue;
                    }

                    match analyze_message(&input) {
                        Ok(()) => {
                            println!("\n{}", "=".repeat(80));
                            println!("🔄 Ready for next message or command...");
                        }
                        Err(e) => {
                            eprintln!("\n❌ Analysis failed: {}", e);
                            eprintln!("💡 Troubleshooting tips:");
                            eprintln!("   • Ensure input is valid base64-encoded data");
                            eprintln!(
                                "   • Try 'multi' mode if this is a fragment needing reassembly"
                            );
                            eprintln!("   • Type 'help' for more information");
                            println!("\n🔄 Try again or type 'exit' to quit.");
                        }
                    }
                }
                Err(e) => {
                    eprintln!("❌ Input error: {}", e);
                    eprintln!("💡 Please try again or restart the application");
                    break;
                }
            }
        }

        Ok(())
    }
}


--- File: crates/protocol-powershell-remoting/examples/defragment_multiple.rs ---
use core::error;

use base64::Engine;
use protocol_powershell_remoting::Defragmenter;

fn main() -> Result<(), Box<dyn error::Error>> {
    tracing_subscriber::fmt::Subscriber::builder()
        .with_ansi(true)
        .with_max_level(tracing::Level::TRACE)
        .with_line_number(true)
        .init();

    // From python impl, this works
    // let stream1 = "AAAAAAAAAAEAAAAAAAAAAAMAAADKAQAAAAIAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAO+7vzxPYmogUmVmSWQ9IjAiPjxNUz48VmVyc2lvbiBOPSJwcm90b2NvbHZlcnNpb24iPjIuMzwvVmVyc2lvbj48VmVyc2lvbiBOPSJQU1ZlcnNpb24iPjIuMDwvVmVyc2lvbj48VmVyc2lvbiBOPSJTZXJpYWxpemF0aW9uVmVyc2lvbiI+MS4xLjAuMTwvVmVyc2lvbj48L01TPjwvT2JqPg==";
    // let stream2 = "AAAAAAAAAAIAAAAAAAAAAAMAAAStAQAAAAkQAgCStLb+3RzgRpdmArnwUEalAAAAAAAAAAAAAAAAAAAAAO+7vzxPYmogUmVmSWQ9IjAiPjxNUz48T2JqIE49IkFwcGxpY2F0aW9uUHJpdmF0ZURhdGEiIFJlZklkPSIxIj48VE4gUmVmSWQ9IjAiPjxUPlN5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uUFNQcmltaXRpdmVEaWN0aW9uYXJ5PC9UPjxUPlN5c3RlbS5Db2xsZWN0aW9ucy5IYXNodGFibGU8L1Q+PFQ+U3lzdGVtLk9iamVjdDwvVD48L1ROPjxEQ1Q+PEVuPjxTIE49IktleSI+UFNWZXJzaW9uVGFibGU8L1M+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjIiPjxUTlJlZiBSZWZJZD0iMCIgLz48RENUPjxFbj48UyBOPSJLZXkiPlBTVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+NS4xLjIwMzQ4LjE4NTA8L1ZlcnNpb24+PC9Fbj48RW4+PFMgTj0iS2V5Ij5QU0VkaXRpb248L1M+PFMgTj0iVmFsdWUiPkRlc2t0b3A8L1M+PC9Fbj48RW4+PFMgTj0iS2V5Ij5QU0NvbXBhdGlibGVWZXJzaW9uczwvUz48T2JqIE49IlZhbHVlIiBSZWZJZD0iMyI+PFROIFJlZklkPSIxIj48VD5TeXN0ZW0uVmVyc2lvbltdPC9UPjxUPlN5c3RlbS5BcnJheTwvVD48VD5TeXN0ZW0uT2JqZWN0PC9UPjwvVE4+PExTVD48VmVyc2lvbj4xLjA8L1ZlcnNpb24+PFZlcnNpb24+Mi4wPC9WZXJzaW9uPjxWZXJzaW9uPjMuMDwvVmVyc2lvbj48VmVyc2lvbj40LjA8L1ZlcnNpb24+PFZlcnNpb24+NS4wPC9WZXJzaW9uPjxWZXJzaW9uPjUuMS4yMDM0OC4xODUwPC9WZXJzaW9uPjwvTFNUPjwvT2JqPjwvRW4+PEVuPjxTIE49IktleSI+Q0xSVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+NC4wLjMwMzE5LjQyMDAwPC9WZXJzaW9uPjwvRW4+PEVuPjxTIE49IktleSI+QnVpbGRWZXJzaW9uPC9TPjxWZXJzaW9uIE49IlZhbHVlIj4xMC4wLjIwMzQ4LjE4NTA8L1ZlcnNpb24+PC9Fbj48RW4+PFMgTj0iS2V5Ij5XU01hblN0YWNrVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+My4wPC9WZXJzaW9uPjwvRW4+PEVuPjxTIE49IktleSI+UFNSZW1vdGluZ1Byb3RvY29sVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+Mi4zPC9WZXJzaW9uPjwvRW4+PEVuPjxTIE49IktleSI+U2VyaWFsaXphdGlvblZlcnNpb248L1M+PFZlcnNpb24gTj0iVmFsdWUiPjEuMS4wLjE8L1ZlcnNpb24+PC9Fbj48L0RDVD48L09iaj48L0VuPjwvRENUPjwvT2JqPjwvTVM+PC9PYmo+";

    // From rust connect example, this does not work
    let stream1 = "AAAAAAAAAAEAAAAAAAAAAAMAAADKAQAAAAIAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAO+7vzxPYmogUmVmSWQ9IjAiPjxNUz48VmVyc2lvbiBOPSJwcm90b2NvbHZlcnNpb24iPjIuMzwvVmVyc2lvbj48VmVyc2lvbiBOPSJQU1ZlcnNpb24iPjIuMDwvVmVyc2lvbj48VmVyc2lvbiBOPSJTZXJpYWxpemF0aW9uVmVyc2lvbiI+MS4xLjAuMTwvVmVyc2lvbj48L01TPjwvT2JqPg==";
    let stream2 = "AAAAAAAAAAIAAAAAAAAAAAMAAAStAQAAAAkQAgAain8iY9hOWIKxIVo7YqjvAAAAAAAAAAAAAAAAAAAAAO+7vzxPYmogUmVmSWQ9IjAiPjxNUz48T2JqIE49IkFwcGxpY2F0aW9uUHJpdmF0ZURhdGEiIFJlZklkPSIxIj48VE4gUmVmSWQ9IjAiPjxUPlN5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uUFNQcmltaXRpdmVEaWN0aW9uYXJ5PC9UPjxUPlN5c3RlbS5Db2xsZWN0aW9ucy5IYXNodGFibGU8L1Q+PFQ+U3lzdGVtLk9iamVjdDwvVD48L1ROPjxEQ1Q+PEVuPjxTIE49IktleSI+UFNWZXJzaW9uVGFibGU8L1M+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjIiPjxUTlJlZiBSZWZJZD0iMCIgLz48RENUPjxFbj48UyBOPSJLZXkiPlBTVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+NS4xLjIwMzQ4LjE4NTA8L1ZlcnNpb24+PC9Fbj48RW4+PFMgTj0iS2V5Ij5QU0VkaXRpb248L1M+PFMgTj0iVmFsdWUiPkRlc2t0b3A8L1M+PC9Fbj48RW4+PFMgTj0iS2V5Ij5QU0NvbXBhdGlibGVWZXJzaW9uczwvUz48T2JqIE49IlZhbHVlIiBSZWZJZD0iMyI+PFROIFJlZklkPSIxIj48VD5TeXN0ZW0uVmVyc2lvbltdPC9UPjxUPlN5c3RlbS5BcnJheTwvVD48VD5TeXN0ZW0uT2JqZWN0PC9UPjwvVE4+PExTVD48VmVyc2lvbj4xLjA8L1ZlcnNpb24+PFZlcnNpb24+Mi4wPC9WZXJzaW9uPjxWZXJzaW9uPjMuMDwvVmVyc2lvbj48VmVyc2lvbj40LjA8L1ZlcnNpb24+PFZlcnNpb24+NS4wPC9WZXJzaW9uPjxWZXJzaW9uPjUuMS4yMDM0OC4xODUwPC9WZXJzaW9uPjwvTFNUPjwvT2JqPjwvRW4+PEVuPjxTIE49IktleSI+Q0xSVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+NC4wLjMwMzE5LjQyMDAwPC9WZXJzaW9uPjwvRW4+PEVuPjxTIE49IktleSI+QnVpbGRWZXJzaW9uPC9TPjxWZXJzaW9uIE49IlZhbHVlIj4xMC4wLjIwMzQ4LjE4NTA8L1ZlcnNpb24+PC9Fbj48RW4+PFMgTj0iS2V5Ij5XU01hblN0YWNrVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+My4wPC9WZXJzaW9uPjwvRW4+PEVuPjxTIE49IktleSI+UFNSZW1vdGluZ1Byb3RvY29sVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+Mi4zPC9WZXJzaW9uPjwvRW4+PEVuPjxTIE49IktleSI+U2VyaWFsaXphdGlvblZlcnNpb248L1M+PFZlcnNpb24gTj0iVmFsdWUiPjEuMS4wLjE8L1ZlcnNpb24+PC9Fbj48L0RDVD48L09iaj48L0VuPjwvRENUPjwvT2JqPjwvTVM+PC9PYmo+";

    let stream1 = base64::engine::general_purpose::STANDARD.decode(stream1.trim())?;
    let stream2 = base64::engine::general_purpose::STANDARD.decode(stream2.trim())?;
    let stream = [stream1, stream2].concat();

    println!(
        "stream = \n\n {}",
        stream
            .iter()
            .map(|b| format!("{:02X}", b))
            .collect::<Vec<_>>()
            .join(" ")
    );

    let mut defragmenter = Defragmenter::new();
    let result = defragmenter.defragment(&stream)?;

    println!("Defragmentation result: {:?}", result);
    Ok(())
}


--- File: crates/protocol-powershell-remoting/src/cores.rs ---
use std::io::Read;

use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};
use tracing::instrument;
use uuid::Uuid;

use crate::ps_value::{DeserializationContext, PsObjectWithType, PsValue, PsXmlDeserialize};

#[derive(Debug, Clone, Copy)]
pub enum Destination {
    Client = 0x0000_0001,
    Server = 0x0000_0002,
}

impl TryFrom<u32> for Destination {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x0000_0001 => Ok(Destination::Client),
            0x0000_0002 => Ok(Destination::Server),
            _ => Err(crate::PowerShellRemotingError::InvalidMessage(format!(
                "Unknown Destination value: 0x{value:08x}"
            ))),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum MessageType {
    SessionCapability,
    InitRunspacepool,
    PublicKey,
    EncryptedSessionKey,
    PublicKeyRequest,
    ConnectRunspacepool,
    RunspacepoolInitData,
    ResetRunspaceState,
    SetMaxRunspaces,
    SetMinRunspaces,
    RunspaceAvailability,
    RunspacepoolState,
    CreatePipeline,
    GetAvailableRunspaces,
    UserEvent,
    ApplicationPrivateData,
    GetCommandMetadata,
    RunspacepoolHostCall,
    RunspacepoolHostResponse,
    PipelineInput,
    EndOfPipelineInput,
    PipelineOutput,
    ErrorRecord,
    PipelineState,
    DebugRecord,
    VerboseRecord,
    WarningRecord,
    ProgressRecord,
    InformationRecord,
    PipelineHostCall,
    PipelineHostResponse,
}

impl MessageType {
    pub fn value(&self) -> u32 {
        match self {
            MessageType::SessionCapability => 0x00010002,
            MessageType::InitRunspacepool => 0x00010004,
            MessageType::PublicKey => 0x00010005,
            MessageType::EncryptedSessionKey => 0x00010006,
            MessageType::PublicKeyRequest => 0x00010007,
            MessageType::ConnectRunspacepool => 0x00010008,
            MessageType::RunspacepoolInitData => 0x0002100B,
            MessageType::ResetRunspaceState => 0x0002100C,
            MessageType::SetMaxRunspaces => 0x00021002,
            MessageType::SetMinRunspaces => 0x00021003,
            MessageType::RunspaceAvailability => 0x00021004,
            MessageType::RunspacepoolState => 0x00021005,
            MessageType::CreatePipeline => 0x00021006,
            MessageType::GetAvailableRunspaces => 0x00021007,
            MessageType::UserEvent => 0x00021008,
            MessageType::ApplicationPrivateData => 0x00021009,
            MessageType::GetCommandMetadata => 0x0002100A,
            MessageType::RunspacepoolHostCall => 0x00021100,
            MessageType::RunspacepoolHostResponse => 0x00021101,
            MessageType::PipelineInput => 0x00041002,
            MessageType::EndOfPipelineInput => 0x00041003,
            MessageType::PipelineOutput => 0x00041004,
            MessageType::ErrorRecord => 0x00041005,
            MessageType::PipelineState => 0x00041006,
            MessageType::DebugRecord => 0x00041007,
            MessageType::VerboseRecord => 0x00041008,
            MessageType::WarningRecord => 0x00041009,
            MessageType::ProgressRecord => 0x00041010,
            MessageType::InformationRecord => 0x00041011,
            MessageType::PipelineHostCall => 0x00041100,
            MessageType::PipelineHostResponse => 0x00041101,
        }
    }
}

impl TryFrom<u32> for MessageType {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x00010002 => Ok(MessageType::SessionCapability),
            0x00010004 => Ok(MessageType::InitRunspacepool),
            0x00010005 => Ok(MessageType::PublicKey),
            0x00010006 => Ok(MessageType::EncryptedSessionKey),
            0x00010007 => Ok(MessageType::PublicKeyRequest),
            0x00010008 => Ok(MessageType::ConnectRunspacepool),
            0x0002100B => Ok(MessageType::RunspacepoolInitData),
            0x0002100C => Ok(MessageType::ResetRunspaceState),
            0x00021002 => Ok(MessageType::SetMaxRunspaces),
            0x00021003 => Ok(MessageType::SetMinRunspaces),
            0x00021004 => Ok(MessageType::RunspaceAvailability),
            0x00021005 => Ok(MessageType::RunspacepoolState),
            0x00021006 => Ok(MessageType::CreatePipeline),
            0x00021007 => Ok(MessageType::GetAvailableRunspaces),
            0x00021008 => Ok(MessageType::UserEvent),
            0x00021009 => Ok(MessageType::ApplicationPrivateData),
            0x0002100A => Ok(MessageType::GetCommandMetadata),
            0x00021100 => Ok(MessageType::RunspacepoolHostCall),
            0x00021101 => Ok(MessageType::RunspacepoolHostResponse),
            0x00041002 => Ok(MessageType::PipelineInput),
            0x00041003 => Ok(MessageType::EndOfPipelineInput),
            0x00041004 => Ok(MessageType::PipelineOutput),
            0x00041005 => Ok(MessageType::ErrorRecord),
            0x00041006 => Ok(MessageType::PipelineState),
            0x00041007 => Ok(MessageType::DebugRecord),
            0x00041008 => Ok(MessageType::VerboseRecord),
            0x00041009 => Ok(MessageType::WarningRecord),
            0x00041010 => Ok(MessageType::ProgressRecord),
            0x00041011 => Ok(MessageType::InformationRecord),
            0x00041100 => Ok(MessageType::PipelineHostCall),
            0x00041101 => Ok(MessageType::PipelineHostResponse),
            _ => Err(crate::PowerShellRemotingError::InvalidMessage(format!(
                "Unknown MessageType value: 0x{value:08x}"
            ))),
        }
    }
}

#[derive(Debug, Clone)]
pub struct RPID {
    pub value: [u8; 16],
}

#[derive(Debug, Clone)]
pub struct PID {
    pub value: [u8; 16],
}

#[derive(Debug, Clone)]
///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/497ac440-89fb-4cb3-9cc1-3434c1aa74c3
pub struct PowerShellRemotingMessage {
    pub destination: Destination,
    pub message_type: MessageType,
    /// Runspace Pool ID (RPID)
    pub rpid: Uuid,
    /// PowerShell Process ID (PID)
    pub pid: Option<Uuid>,
    pub data: Vec<u8>, // This will hold the serialized PsObject data
}

impl PowerShellRemotingMessage {
    pub fn parse<T>(cursor: &mut std::io::Cursor<T>) -> Result<Self, crate::PowerShellRemotingError>
    where
        T: AsRef<[u8]>,
    {
        let destination = cursor.read_u32::<LittleEndian>()?;
        let message_type = cursor
            .read_u32::<LittleEndian>()
            .map(MessageType::try_from)??;

        let mut rpid_bytes = [0u8; 16];
        cursor.read_exact(&mut rpid_bytes)?;

        let mut pid_bytes = [0u8; 16];
        cursor.read_exact(&mut pid_bytes)?;

        let mut rest = vec![];
        cursor.read_to_end(&mut rest)?;

        Ok(Self {
            destination: Destination::try_from(destination).map_err(|e| {
                crate::PowerShellRemotingError::InvalidMessage(format!(
                    "Invalid destination value: {e}"
                ))
            })?,
            message_type,
            rpid: Uuid::from_bytes(rpid_bytes),
            pid: pid_bytes
                .iter()
                .all(|&b| b == 0)
                .then_some(Uuid::from_bytes(pid_bytes)),
            data: rest,
        })
    }

    pub fn from_ps_message(
        message: &dyn PsObjectWithType,
        rpid: Uuid,
        pid: Option<Uuid>,
    ) -> Result<PowerShellRemotingMessage, crate::PowerShellRemotingError> {
        let message_type = message.message_type();
        let data = message.to_ps_object();

        Self::new(Destination::Server, message_type, rpid, pid, &data)
    }

    pub fn new(
        destination: Destination,
        message_type: MessageType,
        rpid: Uuid,
        pid: Option<Uuid>,
        data: &PsValue,
    ) -> Result<Self, crate::PowerShellRemotingError> {
        Ok(Self {
            destination,
            message_type,
            rpid,
            pid,
            data: data.to_element_as_root()?.to_xml_string()?.into_bytes(),
        })
    }

    pub fn pack(self) -> Vec<u8> {
        let mut buffer = Vec::new();
        buffer
            .write_u32::<LittleEndian>(self.destination as u32)
            .unwrap();
        buffer
            .write_u32::<LittleEndian>(self.message_type.value())
            .unwrap();
        buffer.extend_from_slice(self.rpid.as_bytes());
        buffer.extend_from_slice(self.pid.unwrap_or_default().as_bytes());
        buffer.extend_from_slice(&self.data);
        buffer
    }

    #[instrument(skip(self), level = "debug")]
    pub fn parse_ps_message(&self) -> Result<PsValue, crate::PowerShellRemotingError> {
        let xml = str::from_utf8(&self.data)?;

        let parsed = xml::parser::parse(xml)?;
        let root = parsed.root_element();

        let ps_object =
            PsValue::from_node_with_context(root, &mut DeserializationContext::default())?;
        Ok(ps_object)
    }
}

/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/3610dae4-67f7-4175-82da-a3fab83af288
#[derive(Debug, Clone, typed_builder::TypedBuilder)]
pub struct PowerShellFragment {
    pub object_id: u64,
    pub fragment_id: u64,
    pub end_of_fragment: bool,
    pub start_of_fragment: bool,
    pub blob_length: u32,
    pub blob: Vec<u8>, // This will hold the serialized PsObject data
}

impl PowerShellFragment {
    pub fn parse(
        cursor: &mut std::io::Cursor<&[u8]>,
    ) -> Result<Self, crate::PowerShellRemotingError> {
        let object_id = cursor.read_u64::<BigEndian>()?;
        let fragment_id = cursor.read_u64::<BigEndian>()?;
        let flags = cursor.read_u8()?;
        let end_of_fragment = (flags & 0b0000_0010) != 0;
        let start_of_fragment = (flags & 0b0000_0001) != 0;

        let blob_length = cursor.read_u32::<byteorder::BigEndian>()?;

        let current_pos = cursor.position() as usize;
        let data = cursor.get_ref();
        if current_pos + (blob_length as usize) > data.len() {
            return Err(crate::PowerShellRemotingError::InvalidMessage(format!(
                "Not enough data for PowerShell fragment at position {}: expected {}, got {}",
                current_pos,
                blob_length,
                data.len() - current_pos
            )));
        }

        let blob = &cursor.get_ref()[current_pos..current_pos + blob_length as usize];
        cursor.set_position(current_pos as u64 + blob_length as u64);

        Ok(Self {
            object_id,
            fragment_id,
            end_of_fragment,
            start_of_fragment,
            blob_length,
            blob: blob.to_vec(),
        })
    }

    pub fn new(
        object_id: u64,
        fragment_id: u64,
        end_of_fragment: bool,
        start_of_fragment: bool,
        blob: PowerShellRemotingMessage,
    ) -> Self {
        let blob_length = blob.data.len() as u32;
        Self {
            object_id,
            fragment_id,
            end_of_fragment,
            start_of_fragment,
            blob_length,
            blob: blob.pack(),
        }
    }

    pub fn into_vec(self) -> Vec<u8> {
        let mut buffer = Vec::new();
        buffer.write_u64::<BigEndian>(self.object_id).unwrap();
        buffer.write_u64::<BigEndian>(self.fragment_id).unwrap();
        let flags = (self.end_of_fragment as u8) << 1 | (self.start_of_fragment as u8);
        buffer.write_u8(flags).unwrap();
        buffer.write_u32::<BigEndian>(self.blob_length).unwrap();
        buffer.extend_from_slice(&self.blob);
        buffer
    }
}

impl std::fmt::Display for PowerShellFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PowerShellFragment {{ object_id: {:?}, fragment_id: {:?}, end_of_fragment: {}, start_of_fragment: {}, blob_length: {:?}, blob: [{}] }}",
            self.object_id,
            self.fragment_id,
            self.end_of_fragment,
            self.start_of_fragment,
            self.blob_length,
            self.blob
                .iter()
                .map(|b| format!("{b:02x}"))
                .collect::<Vec<String>>()
                .join(" ")
        )
    }
}


--- File: crates/protocol-powershell-remoting/src/fragmentation/defragmenter.rs ---
use tracing::trace;

use super::{DefragmentResult, fragment::Fragment};
use crate::{PowerShellRemotingError, PowerShellRemotingMessage};
use std::collections::HashMap;

/// Buffer for accumulating fragments during defragmentation
#[derive(Debug)]
struct FragmentBuffer {
    fragments: Vec<Fragment>,
    is_complete: bool,
}

impl FragmentBuffer {
    fn new() -> Self {
        Self {
            fragments: Vec::new(),
            is_complete: false,
        }
    }

    /// Add a fragment to this buffer if it's the expected next fragment
    fn add_fragment(&mut self, fragment: Fragment) -> Result<(), PowerShellRemotingError> {
        if fragment.end {
            self.is_complete = true;
        }

        self.fragments.push(fragment);

        Ok(())
    }

    /// Reassemble all fragments into complete message data
    fn reassemble(&self) -> Vec<u8> {
        let mut frags = self.fragments.clone();
        frags.sort_by(|a, b| a.fragment_id.cmp(&b.fragment_id));
        let total_len: usize = frags.iter().map(|f| f.data.len()).sum();
        let mut out = Vec::with_capacity(total_len);

        for f in frags {
            out.extend_from_slice(&f.data);
        }
        out
    }
}

/// Defragmenter handles defragmentation of incoming PowerShell remoting message fragments
/// with internal state management
#[derive(Debug)]
pub struct Defragmenter {
    buffers: HashMap<u64, FragmentBuffer>,
}

impl Defragmenter {
    /// Create a new defragmenter
    pub fn new() -> Self {
        Self {
            buffers: HashMap::new(),
        }
    }

    /// Process incoming packet data containing one or more fragments
    /// Returns complete messages if any are ready, or Incomplete if still waiting
    pub fn defragment(
        &mut self,
        packet_data: &[u8],
    ) -> Result<DefragmentResult, PowerShellRemotingError> {
        let mut remaining_data = packet_data;
        let mut completed_messages = Vec::new();

        // Parse all fragments from the packet data
        while !remaining_data.is_empty() {
            let (fragment, rest) = Fragment::unpack(remaining_data)?;
            trace!(
                fragment = ?fragment,
                "Defragmenter unpacked fragment"
            );

            remaining_data = rest;
            trace!(
                remaining_data_len = remaining_data.len(),
                "Remaining data after unpacking fragment"
            );

            let object_id = fragment.object_id;

            // Handle complete single-fragment message
            if fragment.start && fragment.end {
                let message = self.parse_message(fragment.data)?;
                completed_messages.push(message);
                continue;
            }

            // Get or create buffer for this object
            let buffer = self
                .buffers
                .entry(object_id)
                .or_insert_with(FragmentBuffer::new);

            // Handle start fragment - reset buffer
            if fragment.start {
                *buffer = FragmentBuffer::new();
            }

            // Add fragment to buffer
            buffer.add_fragment(fragment)?;

            // Check if message is complete
            if buffer.is_complete {
                let complete_data = buffer.reassemble();
                let message = self.parse_message(complete_data)?;
                completed_messages.push(message);
                self.buffers.remove(&object_id);
            }
        }

        if completed_messages.is_empty() {
            Ok(DefragmentResult::Incomplete)
        } else {
            Ok(DefragmentResult::Complete(completed_messages))
        }
    }

    /// Get the number of incomplete message buffers
    pub fn pending_count(&self) -> usize {
        self.buffers.len()
    }

    /// Clear all incomplete buffers (useful for error recovery)
    pub fn clear_buffers(&mut self) {
        self.buffers.clear();
    }

    /// Parse a complete message from reassembled data
    fn parse_message(
        &self,
        data: Vec<u8>,
    ) -> Result<PowerShellRemotingMessage, PowerShellRemotingError> {
        let mut cursor = std::io::Cursor::new(data);
        PowerShellRemotingMessage::parse(&mut cursor)
    }
}

impl Default for Defragmenter {
    fn default() -> Self {
        Self::new()
    }
}


--- File: crates/protocol-powershell-remoting/src/fragmentation/fragment.rs ---
use std::io::Cursor;

use crate::PowerShellRemotingError;
use base64::Engine;
use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
use tracing::trace;

/// Fragment represents a single fragment of a PowerShell remoting message
#[derive(Debug, Clone)]
pub struct Fragment {
    pub object_id: u64,
    pub fragment_id: u64,
    pub start: bool,
    pub end: bool,
    pub data: Vec<u8>,
}

impl Fragment {
    pub fn new(object_id: u64, fragment_id: u64, data: Vec<u8>, start: bool, end: bool) -> Self {
        Self {
            object_id,
            fragment_id,
            start,
            end,
            data,
        }
    }

    pub fn encode_multiple(fragments: &[Self]) -> Result<String, PowerShellRemotingError> {
        let mut encoded_fragments = Vec::new();
        for fragment in fragments {
            encoded_fragments.push(fragment.pack_as_base64());
        }
        Ok(encoded_fragments.join(""))
    }

    /// Pack the fragment into wire format bytes
    pub fn pack(&self) -> Vec<u8> {
        let mut buffer = Vec::new();

        // Object ID (8 bytes, big endian)
        buffer.write_u64::<BigEndian>(self.object_id).unwrap();

        // Fragment ID (8 bytes, big endian)
        buffer.write_u64::<BigEndian>(self.fragment_id).unwrap();

        // Start/End flags (1 byte)
        let mut flags = 0u8;
        if self.start {
            flags |= 0x01;
        }
        if self.end {
            flags |= 0x02;
        }
        buffer.push(flags);

        // Data length (4 bytes, big endian)
        buffer
            .write_u32::<BigEndian>(self.data.len() as u32)
            .unwrap();

        // Data payload
        buffer.extend_from_slice(&self.data);

        buffer
    }

    pub fn pack_as_base64(&self) -> String {
        let packed = self.pack();
        base64::engine::general_purpose::STANDARD.encode(packed)
    }

    /// Unpack a fragment from wire format bytes
    pub fn unpack(data: &[u8]) -> Result<(Self, &[u8]), PowerShellRemotingError> {
        if data.len() < 21 {
            return Err(PowerShellRemotingError::InvalidMessage(
                "Fragment too short, need at least 21 bytes".to_string(),
            ));
        }

        let mut cursor = Cursor::new(data);

        let object_id = cursor.read_u64::<BigEndian>()?;

        trace!(object_id, "Unpacking fragment with object ID");

        let fragment_id = cursor.read_u64::<BigEndian>()?;

        trace!(fragment_id, "Unpacking fragment with fragment ID");

        let flags = cursor.read_u8()?;
        let start = (flags & 0x01) != 0;
        let end = (flags & 0x02) != 0;

        trace!(start, end, "Unpacking fragment with start and end flags");

        // let length = u32::from_be_bytes([data[17], data[18], data[19], data[20]]) as usize;
        let length = cursor.read_u32::<BigEndian>()? as usize;

        trace!(length, "Unpacking fragment with data length");
        if data.len() < 21 + length {
            return Err(PowerShellRemotingError::InvalidMessage(format!(
                "Fragment data truncated: expected {} bytes, got {}",
                21 + length,
                data.len()
            )));
        }

        let fragment_data = data[21..21 + length].to_vec();
        let remaining = &data[21 + length..];

        let fragment = Fragment::new(object_id, fragment_id, fragment_data, start, end);

        Ok((fragment, remaining))
    }
}


--- File: crates/protocol-powershell-remoting/src/fragmentation/fragmenter.rs ---
use tracing::{debug, trace};
use uuid::Uuid;

use super::fragment::Fragment;
use crate::{PowerShellRemotingError, PowerShellRemotingMessage, ps_value::PsObjectWithType};

/// Fragmenter handles fragmentation of outgoing PowerShell remoting messages
#[derive(Debug)]
pub struct Fragmenter {
    max_fragment_size: usize,
    outgoing_counter: u64,
}

fn safe_split_at(data: &[u8], size: usize) -> (&[u8], &[u8]) {
    if data.len() <= size {
        (data, &[])
    } else {
        data.split_at(size)
    }
}

impl Fragmenter {
    pub fn new(max_fragment_size: usize) -> Self {
        // Subtract header size (21 bytes) from max fragment size
        let actual_max_size = max_fragment_size.saturating_sub(21);

        Self {
            max_fragment_size: actual_max_size,
            outgoing_counter: 1,
        }
    }

    /// Fragment a single message into multiple fragments
    pub fn fragment(
        &mut self,
        ps_object: &dyn PsObjectWithType,
        rpid: Uuid,
        pid: Option<Uuid>,
        remaining_size: Option<usize>,
    ) -> Result<Vec<Vec<u8>>, PowerShellRemotingError> {
        let message = PowerShellRemotingMessage::from_ps_message(ps_object, rpid, pid)?;
        let message_bytes_source = message.pack();
        let mut remaining_bytes = message_bytes_source.as_slice();
        let max_size = self.max_fragment_size;
        let mut start = true;
        let mut fragment_id = 0;
        let mut fragments = Vec::new();

        if let Some(remaining_size) = remaining_size {
            let (fragment1, remaining) = safe_split_at(remaining_bytes, remaining_size);
            let end = remaining.is_empty();

            remaining_bytes = remaining;

            let fragment = Fragment::new(
                self.outgoing_counter,
                fragment_id,
                fragment1.to_vec(),
                start,
                end,
            );

            fragments.push(fragment.pack());
            fragment_id += 1;
            start = false;
        }

        for chunk in remaining_bytes.chunks(max_size) {
            let end = chunk.len() < max_size;
            let fragment = Fragment::new(
                self.outgoing_counter,
                fragment_id,
                chunk.to_vec(),
                start,
                end,
            );

            fragments.push(fragment.pack());
            fragment_id += 1;
            start = false;

            if end {
                break;
            }
        }

        self.outgoing_counter += 1;

        Ok(fragments)
    }

    /// Fragment multiple messages, grouping them by WSMAN request boundaries
    /// Returns a Vec where each inner Vec contains fragments that should be sent in one WSMAN request
    pub fn fragment_multiple(
        &mut self,
        messages: &[&dyn PsObjectWithType],
        rpid: Uuid,
        pid: Option<Uuid>,
    ) -> Result<Vec<Vec<u8>>, PowerShellRemotingError> {
        let mut remaing_size = self.max_fragment_size;
        // Here we perhaps should not call it fragments anymore
        // Because we are grouping multiple fragments together into one Vec<u8>
        let mut fragements: Vec<Vec<u8>> = Vec::new();

        for message in messages {
            let mut message_fragments = self.fragment(*message, rpid, pid, Some(remaing_size))?;
            trace!(
                "Fragmented message {:?} into {} fragments",
                message.message_type(),
                message_fragments.len()
            );

            // If we have remaining space, append the next message to the last fragment
            // This can save some space if the last fragment is not full
            if remaing_size != self.max_fragment_size && !fragements.is_empty() {
                debug!(
                    "Appending to last fragment, remaining size: {}",
                    remaing_size
                );
                if let Some(last) = fragements.last_mut() {
                    last.extend(message_fragments.remove(0));
                }
            }

            fragements.extend(message_fragments);

            remaing_size = self.max_fragment_size - fragements.last().map_or(0, |last| last.len());
            if remaing_size == 0 {
                remaing_size = self.max_fragment_size; // Reset for next message
            }
        }

        Ok(fragements)
    }
}


--- File: crates/protocol-powershell-remoting/src/fragmentation/mod.rs ---
pub mod defragmenter;
pub mod fragment;
pub mod fragmenter;

#[cfg(test)]
mod tests;

pub use defragmenter::*;
pub use fragment::*;
pub use fragmenter::*;

/// Result of defragmentation operation
#[derive(Debug)]
pub enum DefragmentResult {
    /// No complete messages available yet, waiting for more fragments
    Incomplete,
    /// One or more complete messages have been assembled
    Complete(Vec<crate::PowerShellRemotingMessage>),
}


--- File: crates/protocol-powershell-remoting/src/fragmentation/tests.rs ---
use super::*;
use crate::{
    messages::{ApartmentState, InitRunspacePool, PSThreadOptions, SessionCapability},
    ps_value::PsObjectWithType,
};
use std::collections::BTreeMap;
use tracing::info;
use tracing_test::traced_test;
use uuid::Uuid;

#[cfg(test)]
mod tests {
    use crate::HostInfo;

    use super::*;

    /// Test fragmenter/defragmenter roundtrip with single small message
    #[test]
    #[traced_test]
    fn test_single_message_roundtrip() {
        let session_capability = SessionCapability {
            protocol_version: "2.3".to_string(),
            ps_version: "2.0".to_string(),
            serialization_version: "1.1.0.1".to_string(),
            time_zone: None,
        };

        let runspace_id = Uuid::new_v4();
        let mut fragmenter = Fragmenter::new(32768); // Large buffer

        // Fragment the message
        let fragment_bytes = fragmenter
            .fragment(&session_capability, runspace_id, None, None)
            .unwrap();
        assert_eq!(
            fragment_bytes.len(),
            1,
            "Small message should fit in one fragment"
        );

        // Defragment it back
        let mut defragmenter = Defragmenter::new();
        let result = defragmenter.defragment(&fragment_bytes[0]).unwrap();

        match result {
            DefragmentResult::Complete(messages) => {
                assert_eq!(messages.len(), 1, "Should get back exactly one message");
                info!("Successfully roundtripped single SessionCapability message");
            }
            DefragmentResult::Incomplete => panic!("Single fragment should be complete"),
        }
    }

    /// Test fragmenter/defragmenter with artificially small fragment size to force multi-fragment
    #[test]
    #[traced_test]
    fn test_multi_fragment_roundtrip() {
        let init_runspace_pool = InitRunspacePool {
            min_runspaces: 1,
            max_runspaces: 1,
            thread_options: PSThreadOptions::Default,
            apartment_state: ApartmentState::Unknown,
            host_info: HostInfo::builder().build(),
            application_arguments: BTreeMap::new(),
        };

        let runspace_id = Uuid::new_v4();
        let mut fragmenter = Fragmenter::new(200); // Very small fragments to force multi-fragment

        // Fragment the message (should create multiple fragments)
        let fragment_bytes = fragmenter
            .fragment(&init_runspace_pool, runspace_id, None, None)
            .unwrap();
        info!("Created {} fragments", fragment_bytes.len());
        assert!(
            fragment_bytes.len() > 1,
            "Small fragment size should create multiple fragments"
        );

        // Defragment each piece individually (simulating network arrival)
        let mut defragmenter = Defragmenter::new();
        let mut completed_messages = Vec::new();

        for (i, fragment) in fragment_bytes.iter().enumerate() {
            let result = defragmenter.defragment(fragment).unwrap();
            match result {
                DefragmentResult::Complete(mut messages) => {
                    completed_messages.append(&mut messages);
                    info!("Fragment {} completed the message", i);
                }
                DefragmentResult::Incomplete => {
                    info!("Fragment {} added to buffer", i);
                }
            }
        }

        assert_eq!(
            completed_messages.len(),
            1,
            "Should reassemble into exactly one message"
        );
        info!("Successfully roundtripped multi-fragment InitRunspacePool message");
    }

    /// Test multiple messages like RunspacePool::open() does
    #[test]
    #[traced_test]
    fn test_multiple_messages_roundtrip() {
        let session_capability = SessionCapability {
            protocol_version: "2.3".to_string(),
            ps_version: "2.0".to_string(),
            serialization_version: "1.1.0.1".to_string(),
            time_zone: None,
        };

        let init_runspace_pool = InitRunspacePool {
            min_runspaces: 1,
            max_runspaces: 1,
            thread_options: PSThreadOptions::Default,
            apartment_state: ApartmentState::Unknown,
            host_info: HostInfo::builder().build(),
            application_arguments: BTreeMap::new(),
        };

        let runspace_id = Uuid::new_v4();
        let mut fragmenter = Fragmenter::new(32768);

        // Fragment both messages
        let messages = vec![
            &session_capability as &dyn crate::PsObjectWithType,
            &init_runspace_pool,
        ];
        let all_fragment_bytes = fragmenter
            .fragment_multiple(&messages, runspace_id, None)
            .unwrap();

        info!(
            "Created {} total fragments for 2 messages",
            all_fragment_bytes.len()
        );

        // Concatenate all fragments as they would be sent over wire
        let mut wire_data = Vec::new();
        for fragment_bytes in &all_fragment_bytes {
            wire_data.extend_from_slice(fragment_bytes);
        }

        // Defragment the combined data
        let mut defragmenter = Defragmenter::new();
        let result = defragmenter.defragment(&wire_data).unwrap();

        match result {
            DefragmentResult::Complete(messages) => {
                assert_eq!(
                    messages.len(),
                    2,
                    "Should get back both messages (SessionCapability + InitRunspacePool)"
                );
                info!(
                    "Successfully roundtripped {} PowerShell remoting messages",
                    messages.len()
                );
            }
            DefragmentResult::Incomplete => {
                panic!("All fragments should be complete when sent together")
            }
        }
    }

    /// Test the exact RunspacePool::open() scenario with Microsoft-compatible UUIDs
    #[test]
    #[traced_test]
    fn test_runspace_pool_open_scenario() {
        // Use the same UUID as Microsoft examples for consistency
        let runspace_id = Uuid::parse_str("d034652d-126b-e340-b773-cba26459cfa8").unwrap();

        let session_capability = SessionCapability {
            protocol_version: "2.3".to_string(),
            ps_version: "2.0".to_string(),
            serialization_version: "1.1.0.1".to_string(),
            time_zone: None,
        };

        let init_runspace_pool = InitRunspacePool {
            min_runspaces: 1,
            max_runspaces: 1,
            thread_options: PSThreadOptions::Default,
            apartment_state: ApartmentState::Unknown,
            host_info: HostInfo::builder().build(),
            application_arguments: BTreeMap::new(),
        };

        // This mimics the exact call in RunspacePool::open()
        let mut fragmenter = Fragmenter::new(143600); // Default WS-Management max envelope size
        let messages = vec![
            &session_capability as &dyn crate::PsObjectWithType,
            &init_runspace_pool,
        ];
        let fragment_bytes = fragmenter
            .fragment_multiple(&messages, runspace_id, None)
            .unwrap();

        info!(
            "RunspacePool::open() scenario generated {} fragments",
            fragment_bytes.len()
        );

        // Concatenate as would be sent in single WSMAN request
        let mut creation_xml_data = Vec::new();
        for fragment in &fragment_bytes {
            creation_xml_data.extend_from_slice(fragment);
        }

        info!("Total creationXml size: {} bytes", creation_xml_data.len());

        // Parse it back like the server would
        let mut defragmenter = Defragmenter::new();
        let result = defragmenter.defragment(&creation_xml_data).unwrap();

        match result {
            DefragmentResult::Complete(messages) => {
                assert_eq!(
                    messages.len(),
                    2,
                    "RunspacePool::open() should produce 2 messages"
                );
                info!("✅ RunspacePool::open() fragmentation/defragmentation successful!");

                // TODO: Verify message types and content match expected values
            }
            DefragmentResult::Incomplete => {
                panic!("RunspacePool::open() fragments should be complete")
            }
        }
    }
}


--- File: crates/protocol-powershell-remoting/src/lib.rs ---
pub mod cores;
pub mod fragmentation;
pub mod messages;
pub mod ps_value;

use std::str::Utf8Error;

pub use cores::*;
pub use fragmentation::*;
pub use messages::*;
pub use ps_value::PsObjectWithType;

#[cfg(test)]
mod tests;

#[derive(Debug, thiserror::Error)]
pub enum PowerShellRemotingError {
    #[error("Invalid PowerShell remoting message: {0}")]
    InvalidMessage(String),

    #[error("PowerShell remoting error: {0}")]
    RemotingError(String),

    #[error("IO Error: {0}")]
    IoError(String),

    #[error("Serialization Error: {0}")]
    SerializationError(&'static str),

    #[error("PsFragment cannot be read as a valid XML message: {0}")]
    Utf8Error(#[from] Utf8Error),

    #[error("Failed to parse XML: {0}")]
    XmlError(#[from] xml::XmlError),

    #[error("Output formatting error: {0}")]
    OutputFormattingError(&'static str),
}

impl From<std::io::Error> for PowerShellRemotingError {
    fn from(err: std::io::Error) -> Self {
        PowerShellRemotingError::IoError(err.to_string())
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/create_pipeline/command.rs ---
use super::{CommandParameter, PipelineResultTypes};
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, Container, PsPrimitiveValue, PsProperty, PsType, PsValue,
};
use std::{collections::BTreeMap, ops::Index};

#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct Command {
    #[builder(setter(into))]
    pub cmd: String,
    #[builder(default = false)]
    pub is_script: bool,
    #[builder(default)]
    pub args: Vec<CommandParameter>,
    #[builder(default)]
    pub use_local_scope: Option<bool>,
    #[builder(default)]
    pub merge_my_result: PipelineResultTypes,
    #[builder(default)]
    pub merge_to_result: PipelineResultTypes,
    #[builder(default)]
    pub merge_previous_results: PipelineResultTypes,
    #[builder(default)]
    pub merge_debug: PipelineResultTypes,
    #[builder(default)]
    pub merge_error: PipelineResultTypes,
    #[builder(default)]
    pub merge_information: PipelineResultTypes,
    #[builder(default)]
    pub merge_verbose: PipelineResultTypes,
    #[builder(default)]
    pub merge_warning: PipelineResultTypes,
}

impl From<Command> for ComplexObject {
    fn from(command: Command) -> Self {
        let mut extended_properties = BTreeMap::new();

        let cmd_str = command.cmd.clone();

        extended_properties.insert(
            "Cmd".to_string(),
            PsProperty {
                name: "Cmd".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Str(command.cmd)),
            },
        );

        extended_properties.insert(
            "IsScript".to_string(),
            PsProperty {
                name: "IsScript".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(command.is_script)),
            },
        );

        // Args as ArrayList of CommandParameter objects
        let args_values: Vec<PsValue> = command
            .args
            .into_iter()
            .map(|param| PsValue::Object(param.into()))
            .collect();

        let args_obj = ComplexObject {
            type_def: Some(PsType::array_list()),
            to_string: None,
            content: ComplexObjectContent::Container(Container::List(args_values)),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        extended_properties.insert(
            "Args".to_string(),
            PsProperty {
                name: "Args".to_string(),
                value: PsValue::Object(args_obj),
            },
        );

        extended_properties.insert(
            "UseLocalScope".to_string(),
            PsProperty {
                name: "UseLocalScope".to_string(),
                value: match command.use_local_scope {
                    Some(use_local_scope) => {
                        PsValue::Primitive(PsPrimitiveValue::Bool(use_local_scope))
                    }
                    None => PsValue::Primitive(PsPrimitiveValue::Nil),
                },
            },
        );

        extended_properties.insert(
            "MergeMyResult".to_string(),
            PsProperty {
                name: "MergeMyResult".to_string(),
                value: PsValue::Object(command.merge_my_result.into()),
            },
        );

        extended_properties.insert(
            "MergeToResult".to_string(),
            PsProperty {
                name: "MergeToResult".to_string(),
                value: PsValue::Object(command.merge_to_result.into()),
            },
        );

        extended_properties.insert(
            "MergePreviousResults".to_string(),
            PsProperty {
                name: "MergePreviousResults".to_string(),
                value: PsValue::Object(command.merge_previous_results.into()),
            },
        );

        extended_properties.insert(
            "MergeDebug".to_string(),
            PsProperty {
                name: "MergeDebug".to_string(),
                value: PsValue::Object(command.merge_debug.into()),
            },
        );

        extended_properties.insert(
            "MergeError".to_string(),
            PsProperty {
                name: "MergeError".to_string(),
                value: PsValue::Object(command.merge_error.into()),
            },
        );

        extended_properties.insert(
            "MergeInformation".to_string(),
            PsProperty {
                name: "MergeInformation".to_string(),
                value: PsValue::Object(command.merge_information.into()),
            },
        );

        extended_properties.insert(
            "MergeVerbose".to_string(),
            PsProperty {
                name: "MergeVerbose".to_string(),
                value: PsValue::Object(command.merge_verbose.into()),
            },
        );

        extended_properties.insert(
            "MergeWarning".to_string(),
            PsProperty {
                name: "MergeWarning".to_string(),
                value: PsValue::Object(command.merge_warning.into()),
            },
        );

        ComplexObject {
            type_def: None,
            to_string: Some(cmd_str),
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for Command {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let get_property = |name: &str| -> Result<&PsProperty, Self::Error> {
            value
                .extended_properties
                .get(name)
                .ok_or_else(|| Self::Error::InvalidMessage(format!("Missing property: {name}")))
        };

        let cmd = match &get_property("Cmd")?.value {
            PsValue::Primitive(PsPrimitiveValue::Str(s)) => s.clone(),
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "Cmd must be a string".to_string(),
                ));
            }
        };

        let is_script = match &get_property("IsScript")?.value {
            PsValue::Primitive(PsPrimitiveValue::Bool(b)) => *b,
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "IsScript must be a bool".to_string(),
                ));
            }
        };

        let args = match &get_property("Args")?.value {
            PsValue::Object(obj) => match &obj.content {
                ComplexObjectContent::Container(Container::List(list)) => {
                    let mut command_params = Vec::new();
                    for item in list {
                        if let PsValue::Object(param_obj) = item {
                            match CommandParameter::try_from(param_obj.clone()) {
                                Ok(param) => command_params.push(param),
                                Err(_) => continue,
                            }
                        }
                    }
                    command_params
                }
                _ => vec![],
            },
            _ => vec![],
        };

        let use_local_scope = match value.extended_properties.get("UseLocalScope") {
            Some(prop) => match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::Bool(b)) => Some(*b),
                PsValue::Primitive(PsPrimitiveValue::Nil) => None,
                _ => None,
            },
            None => None,
        };

        let get_merge_property = |name: &str| -> PipelineResultTypes {
            match value.extended_properties.get(name) {
                Some(prop) => match &prop.value {
                    PsValue::Object(obj) => {
                        PipelineResultTypes::try_from(obj.clone()).unwrap_or_default()
                    }
                    _ => PipelineResultTypes::default(),
                },
                None => PipelineResultTypes::default(),
            }
        };

        let merge_my_result = get_merge_property("MergeMyResult");
        let merge_to_result = get_merge_property("MergeToResult");
        let merge_previous_results = get_merge_property("MergePreviousResults");
        let merge_debug = get_merge_property("MergeDebug");
        let merge_error = get_merge_property("MergeError");
        let merge_information = get_merge_property("MergeInformation");
        let merge_verbose = get_merge_property("MergeVerbose");
        let merge_warning = get_merge_property("MergeWarning");

        Ok(Command {
            cmd,
            is_script,
            args,
            use_local_scope,
            merge_my_result,
            merge_to_result,
            merge_previous_results,
            merge_debug,
            merge_error,
            merge_information,
            merge_verbose,
            merge_warning,
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Commands {
    cmds: Vec<Command>,
}

impl Commands {
    // Garentees to have at least one command
    pub fn new(cmds: Command) -> Self {
        Commands { cmds: vec![cmds] }
    }

    pub fn len(&self) -> usize {
        self.cmds.len()
    }

    pub fn is_empty(&self) -> bool {
        self.cmds.is_empty()
    }
}

impl Index<usize> for Commands {
    type Output = Command;

    fn index(&self, index: usize) -> &Self::Output {
        &self.cmds[index]
    }
}

impl IntoIterator for Commands {
    type Item = Command;
    type IntoIter = std::vec::IntoIter<Command>;

    fn into_iter(self) -> Self::IntoIter {
        self.cmds.into_iter()
    }
}

impl TryFrom<Vec<Command>> for Commands {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: Vec<Command>) -> Result<Self, Self::Error> {
        if value.is_empty() {
            return Err(crate::PowerShellRemotingError::InvalidMessage(
                "Commands cannot be empty".to_string(),
            ));
        }
        Ok(Commands { cmds: value })
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/create_pipeline/command_parameter.rs ---
use crate::ps_value::{ComplexObject, ComplexObjectContent, PsPrimitiveValue, PsProperty, PsValue};
use std::collections::BTreeMap;

#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct CommandParameter {
    #[builder(default, setter(into, strip_option))]
    pub name: Option<String>,
    pub value: PsValue,
}

impl From<CommandParameter> for ComplexObject {
    fn from(param: CommandParameter) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "N".to_string(),
            PsProperty {
                name: "N".to_string(),
                value: match param.name {
                    Some(name) => PsValue::Primitive(PsPrimitiveValue::Str(name)),
                    None => PsValue::Primitive(PsPrimitiveValue::Nil),
                },
            },
        );

        extended_properties.insert(
            "V".to_string(),
            PsProperty {
                name: "V".to_string(),
                value: param.value,
            },
        );

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for CommandParameter {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let get_property = |name: &str| -> Result<&PsProperty, Self::Error> {
            value
                .extended_properties
                .get(name)
                .ok_or_else(|| Self::Error::InvalidMessage(format!("Missing property: {name}")))
        };

        let name = match &get_property("N")?.value {
            PsValue::Primitive(PsPrimitiveValue::Str(s)) => Some(s.clone()),
            PsValue::Primitive(PsPrimitiveValue::Nil) => None,
            _ => None,
        };

        let value = get_property("V")?.value.clone();

        Ok(CommandParameter { name, value })
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/create_pipeline/mod.rs ---
mod command;
mod command_parameter;
mod pipeline_result_types;
mod powershell_pipeline;
mod remote_stream_options;
#[cfg(test)]
mod test;

pub use command::{Command, Commands};
pub use command_parameter::CommandParameter;
pub use pipeline_result_types::PipelineResultTypes;
pub use powershell_pipeline::PowerShellPipeline;
pub use remote_stream_options::RemoteStreamOptions;

use super::init_runspace_pool::{ApartmentState, HostInfo};
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, PsEnums, PsObjectWithType, PsPrimitiveValue, PsProperty,
    PsType, PsValue,
};
use std::{borrow::Cow, collections::BTreeMap};

#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct CreatePipeline {
    #[builder(default = true)]
    pub no_input: bool,
    #[builder(default = ApartmentState::Unknown)]
    pub apartment_state: ApartmentState,
    #[builder(default = RemoteStreamOptions::None)]
    pub remote_stream_options: RemoteStreamOptions,
    #[builder(default = false)]
    pub add_to_history: bool,
    pub host_info: HostInfo,
    pub power_shell: PowerShellPipeline,
    #[builder(default = false)]
    pub is_nested: bool,
}

impl PsObjectWithType for CreatePipeline {
    fn message_type(&self) -> MessageType {
        MessageType::CreatePipeline
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<CreatePipeline> for ComplexObject {
    fn from(create_pipeline: CreatePipeline) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "NoInput".to_string(),
            PsProperty {
                name: "NoInput".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(create_pipeline.no_input)),
            },
        );

        extended_properties.insert(
            "ApartmentState".to_string(),
            PsProperty {
                name: "ApartmentState".to_string(),
                value: PsValue::Object(ComplexObject::from(create_pipeline.apartment_state)),
            },
        );

        extended_properties.insert(
            "RemoteStreamOptions".to_string(),
            PsProperty {
                name: "RemoteStreamOptions".to_string(),
                value: PsValue::Object(ComplexObject::from(create_pipeline.remote_stream_options)),
            },
        );

        extended_properties.insert(
            "AddToHistory".to_string(),
            PsProperty {
                name: "AddToHistory".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(create_pipeline.add_to_history)),
            },
        );

        extended_properties.insert(
            "HostInfo".to_string(),
            PsProperty {
                name: "HostInfo".to_string(),
                value: PsValue::Object(ComplexObject::from(create_pipeline.host_info)),
            },
        );

        extended_properties.insert(
            "PowerShell".to_string(),
            PsProperty {
                name: "PowerShell".to_string(),
                value: PsValue::Object(ComplexObject::from(create_pipeline.power_shell)),
            },
        );

        extended_properties.insert(
            "IsNested".to_string(),
            PsProperty {
                name: "IsNested".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(create_pipeline.is_nested)),
            },
        );

        ComplexObject {
            type_def: Some(PsType {
                type_names: vec![Cow::Borrowed("System.Object")],
            }),
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for CreatePipeline {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let get_property = |name: &str| -> Result<&PsProperty, Self::Error> {
            value
                .extended_properties
                .get(name)
                .ok_or_else(|| Self::Error::InvalidMessage(format!("Missing property: {name}")))
        };

        let no_input = match &get_property("NoInput")?.value {
            PsValue::Primitive(PsPrimitiveValue::Bool(b)) => *b,
            _ => true,
        };

        let apartment_state = match &get_property("ApartmentState")?.value {
            PsValue::Object(obj) => match &obj.content {
                ComplexObjectContent::PsEnums(PsEnums { value }) => match *value {
                    0 => ApartmentState::STA,
                    1 => ApartmentState::MTA,
                    2 => ApartmentState::Unknown,
                    _ => ApartmentState::Unknown,
                },
                _ => ApartmentState::Unknown,
            },
            _ => ApartmentState::Unknown,
        };

        let remote_stream_options = match &get_property("RemoteStreamOptions")?.value {
            PsValue::Object(obj) => RemoteStreamOptions::try_from(obj.clone())?,
            _ => RemoteStreamOptions::None,
        };

        let add_to_history = match &get_property("AddToHistory")?.value {
            PsValue::Primitive(PsPrimitiveValue::Bool(b)) => *b,
            _ => false,
        };

        let host_info = match &get_property("HostInfo")?.value {
            PsValue::Object(obj) => HostInfo::try_from(obj.clone())
                .map_err(|_| Self::Error::InvalidMessage("Failed to parse HostInfo".to_string()))?,
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "HostInfo must be an object".to_string(),
                ));
            }
        };

        let power_shell = match &get_property("PowerShell")?.value {
            PsValue::Object(obj) => PowerShellPipeline::try_from(obj.clone())?,
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "PowerShell must be an object".to_string(),
                ));
            }
        };

        let is_nested = match &get_property("IsNested")?.value {
            PsValue::Primitive(PsPrimitiveValue::Bool(b)) => *b,
            _ => false,
        };

        Ok(CreatePipeline {
            no_input,
            apartment_state,
            remote_stream_options,
            add_to_history,
            host_info,
            power_shell,
            is_nested,
        })
    }
}

impl CreatePipeline {
    pub fn simple_command(command: &str) -> Self {
        let cmd = Command::builder().cmd(command.to_string()).build();

        let pipeline = PowerShellPipeline::builder()
            .cmds(Commands::new(cmd))
            .build();

        let host_info = HostInfo::builder().use_runspace_host(true).build();

        CreatePipeline::builder()
            .host_info(host_info)
            .power_shell(pipeline)
            .build()
    }

    pub fn script_command(script: &str) -> Self {
        let cmd = Command::builder()
            .cmd(script.to_string())
            .is_script(true)
            .build();

        let pipeline = PowerShellPipeline::builder()
            .cmds(Commands::new(cmd))
            .build();

        let host_info = HostInfo::builder().build();

        CreatePipeline::builder()
            .host_info(host_info)
            .power_shell(pipeline)
            .build()
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/create_pipeline/pipeline_result_types.rs ---
use crate::ps_value::{ComplexObject, ComplexObjectContent, PsEnums, PsType};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum PipelineResultTypes {
    #[default]
    None = 0x00,
    Output = 0x01,
    Error = 0x02,
    Warning = 0x04,
    Verbose = 0x08,
    Debug = 0x10,
    All = 0x20,
    Null = 0x40,
}

impl PipelineResultTypes {
    pub fn value(self) -> i32 {
        self as i32
    }
}

impl From<i32> for PipelineResultTypes {
    fn from(value: i32) -> Self {
        match value {
            0x00 => PipelineResultTypes::None,
            0x01 => PipelineResultTypes::Output,
            0x02 => PipelineResultTypes::Error,
            0x04 => PipelineResultTypes::Warning,
            0x08 => PipelineResultTypes::Verbose,
            0x10 => PipelineResultTypes::Debug,
            0x20 => PipelineResultTypes::All,
            0x40 => PipelineResultTypes::Null,
            _ => PipelineResultTypes::None,
        }
    }
}

impl From<PipelineResultTypes> for ComplexObject {
    fn from(result_type: PipelineResultTypes) -> Self {
        ComplexObject {
            type_def: Some(PsType::pipeline_result_types()),
            to_string: None,
            content: ComplexObjectContent::PsEnums(PsEnums {
                value: result_type.value(),
            }),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        }
    }
}

impl TryFrom<ComplexObject> for PipelineResultTypes {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, crate::PowerShellRemotingError> {
        match value.content {
            ComplexObjectContent::PsEnums(PsEnums { value: val }) => {
                Ok(PipelineResultTypes::from(val))
            }
            _ => Err(crate::PowerShellRemotingError::InvalidMessage(
                "PipelineResultTypes must be an enum".to_string(),
            )),
        }
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/create_pipeline/powershell_pipeline.rs ---
use super::command::Command;
use crate::Commands;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, Container, PsPrimitiveValue, PsProperty, PsType, PsValue,
};
use std::collections::BTreeMap;

#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct PowerShellPipeline {
    #[builder(default = false)]
    pub is_nested: bool,
    pub cmds: Commands,
    #[builder(default)]
    pub history: String,
    #[builder(default = false)]
    pub redirect_shell_error_output_pipe: bool,
}

impl From<PowerShellPipeline> for ComplexObject {
    fn from(pipeline: PowerShellPipeline) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "IsNested".to_string(),
            PsProperty {
                name: "IsNested".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(pipeline.is_nested)),
            },
        );

        // Commands as ArrayList
        let cmds: Vec<PsValue> = pipeline
            .cmds
            .into_iter()
            .map(|cmd| PsValue::Object(ComplexObject::from(cmd)))
            .collect();

        let cmds_obj = ComplexObject {
            type_def: Some(PsType::array_list()),
            to_string: None,
            content: ComplexObjectContent::Container(Container::List(cmds)),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        extended_properties.insert(
            "Cmds".to_string(),
            PsProperty {
                name: "Cmds".to_string(),
                value: PsValue::Object(cmds_obj),
            },
        );

        extended_properties.insert(
            "History".to_string(),
            PsProperty {
                name: "History".to_string(),
                value: if pipeline.history.is_empty() {
                    PsValue::Primitive(PsPrimitiveValue::Nil)
                } else {
                    PsValue::Primitive(PsPrimitiveValue::Str(pipeline.history))
                },
            },
        );

        extended_properties.insert(
            "RedirectShellErrorOutputPipe".to_string(),
            PsProperty {
                name: "RedirectShellErrorOutputPipe".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(
                    pipeline.redirect_shell_error_output_pipe,
                )),
            },
        );

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for PowerShellPipeline {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let get_property = |name: &str| -> Result<&PsProperty, Self::Error> {
            value
                .extended_properties
                .get(name)
                .ok_or_else(|| Self::Error::InvalidMessage(format!("Missing property: {name}")))
        };

        let is_nested = match &get_property("IsNested")?.value {
            PsValue::Primitive(PsPrimitiveValue::Bool(b)) => *b,
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "IsNested must be a bool".to_string(),
                ));
            }
        };

        let cmds = match &get_property("Cmds")?.value {
            PsValue::Object(obj) => match &obj.content {
                ComplexObjectContent::Container(Container::List(list)) => {
                    let mut commands = Vec::new();
                    for item in list {
                        if let PsValue::Object(cmd_obj) = item {
                            commands.push(Command::try_from(cmd_obj.clone())?);
                        }
                    }
                    commands
                }
                _ => {
                    return Err(Self::Error::InvalidMessage(
                        "Cmds must be a list".to_string(),
                    ));
                }
            },
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "Cmds must be an object".to_string(),
                ));
            }
        };

        let history = match value.extended_properties.get("History") {
            Some(prop) => match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::Str(s)) => s.clone(),
                PsValue::Primitive(PsPrimitiveValue::Nil) => String::new(),
                _ => String::new(),
            },
            None => String::new(),
        };

        let redirect_shell_error_output_pipe =
            match &get_property("RedirectShellErrorOutputPipe")?.value {
                PsValue::Primitive(PsPrimitiveValue::Bool(b)) => *b,
                _ => false,
            };

        Ok(PowerShellPipeline {
            is_nested,
            cmds: Commands::try_from(cmds)?,
            history,
            redirect_shell_error_output_pipe,
        })
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/create_pipeline/remote_stream_options.rs ---
use crate::ps_value::{ComplexObject, ComplexObjectContent, PsEnums, PsType};
use std::{borrow::Cow, collections::BTreeMap};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RemoteStreamOptions {
    None = 0,
    AddInvocationInfo = 1,
}

impl From<RemoteStreamOptions> for ComplexObject {
    fn from(options: RemoteStreamOptions) -> Self {
        let type_def = PsType {
            type_names: vec![
                Cow::Borrowed("System.Management.Automation.RemoteStreamOptions"),
                Cow::Borrowed("System.Enum"),
                Cow::Borrowed("System.ValueType"),
                Cow::Borrowed("System.Object"),
            ],
        };

        let to_string = match options {
            RemoteStreamOptions::None => "None".to_string(),
            RemoteStreamOptions::AddInvocationInfo => "AddInvocationInfo".to_string(),
        };

        ComplexObject {
            type_def: Some(type_def),
            to_string: Some(to_string),
            content: ComplexObjectContent::PsEnums(PsEnums {
                value: options as i32,
            }),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        }
    }
}

impl TryFrom<ComplexObject> for RemoteStreamOptions {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        match value.content {
            ComplexObjectContent::PsEnums(PsEnums { value }) => match value {
                0 => Ok(RemoteStreamOptions::None),
                1 => Ok(RemoteStreamOptions::AddInvocationInfo),
                _ => Err(Self::Error::InvalidMessage(format!(
                    "Invalid RemoteStreamOptions value: {value}"
                ))),
            },
            _ => Err(Self::Error::InvalidMessage(
                "RemoteStreamOptions must be an enum".to_string(),
            )),
        }
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/create_pipeline/test.rs ---
use uuid::Uuid;

use super::*;
use crate::{
    Fragmenter,
    ps_value::deserialize::{DeserializationContext, PsXmlDeserialize},
    ps_value::serialize::RefIdMap,
};

const REAL_CREATE_PIPELINE: &str = r#"
<Obj RefId="0">
   <TN RefId="0">
      <T>System.Object</T>
   </TN>
   <MS>
      <B N="NoInput">true</B>
      <Obj RefId="1" N="ApartmentState">
         <I32>2</I32>
         <TN RefId="1">
            <T>System.Threading.ApartmentState</T>
            <T>System.Enum</T>
            <T>System.ValueType</T>
            <T>System.Object</T>
         </TN>
         <ToString>Unknown</ToString>
      </Obj>
      <Obj RefId="2" N="RemoteStreamOptions">
         <I32>0</I32>
         <TN RefId="2">
            <T>System.Management.Automation.RemoteStreamOptions</T>
            <T>System.Enum</T>
            <T>System.ValueType</T>
            <T>System.Object</T>
         </TN>
         <ToString>None</ToString>
      </Obj>
      <B N="AddToHistory">false</B>
      <Obj RefId="3" N="HostInfo">
         <MS>
            <B N="_isHostNull">true</B>
            <B N="_isHostUINull">true</B>
            <B N="_isHostRawUINull">true</B>
            <B N="_useRunspaceHost">true</B>
         </MS>
      </Obj>
      <Obj RefId="4" N="PowerShell">
         <MS>
            <Obj RefId="5" N="Cmds">
               <TN RefId="3">
                  <T>System.Collections.ArrayList</T>
                  <T>System.Object</T>
               </TN>
               <LST>
                  <Obj RefId="6">
                     <MS>
                        <S N="Cmd">Write-Host "Remote System: $($env:COMPUTERNAME) - $(Get-Date)"</S>
                        <Obj RefId="7" N="Args">
                           <TNRef RefId="3" />
                           <LST />
                        </Obj>
                        <B N="IsScript">true</B>
                        <Nil N="UseLocalScope" />
                        <Obj RefId="8" N="MergeMyResult">
                           <I32>0</I32>
                           <TN RefId="4">
                              <T>System.Management.Automation.Runspaces.PipelineResultTypes</T>
                              <T>System.Enum</T>
                              <T>System.ValueType</T>
                              <T>System.Object</T>
                           </TN>
                           <ToString>None</ToString>
                        </Obj>
                        <Ref RefId="8" N="MergeToResult" />
                        <Ref RefId="8" N="MergePreviousResults" />
                        <Ref RefId="8" N="MergeError" />
                        <Ref RefId="8" N="MergeWarning" />
                        <Ref RefId="8" N="MergeVerbose" />
                        <Ref RefId="8" N="MergeDebug" />
                        <Ref RefId="8" N="MergeInformation" />
                     </MS>
                     <ToString>Write-Host "Remote System: $($env:COMPUTERNAME) - $(Get-Date)"</ToString>
                  </Obj>
               </LST>
            </Obj>
            <B N="IsNested">false</B>
            <Nil N="History" />
            <B N="RedirectShellErrorOutputPipe">true</B>
         </MS>
      </Obj>
      <B N="IsNested">false</B>
   </MS>
</Obj>
    "#;

#[test]
#[tracing_test::traced_test]
fn test_deserialize_real_create_pipeline() {
    let parsed = xml::parser::parse(REAL_CREATE_PIPELINE).unwrap();
    let root = parsed.root_element();

    let ps_value =
        PsValue::from_node_with_context(root, &mut DeserializationContext::default()).unwrap();

    if let PsValue::Object(complex_obj) = ps_value {
        let create_pipeline = CreatePipeline::try_from(complex_obj).unwrap();

        // Verify top-level CreatePipeline properties (lines 16, 37, 90)
        assert_eq!(create_pipeline.no_input, true, "NoInput should be true");
        assert_eq!(
            create_pipeline.add_to_history, false,
            "AddToHistory should be false"
        );
        assert_eq!(create_pipeline.is_nested, false, "IsNested should be false");

        // Verify ApartmentState (lines 17-26)
        assert_eq!(
            create_pipeline.apartment_state,
            ApartmentState::Unknown,
            "ApartmentState should be Unknown (2)"
        );

        // Verify RemoteStreamOptions (lines 27-36)
        assert_eq!(
            create_pipeline.remote_stream_options,
            RemoteStreamOptions::None,
            "RemoteStreamOptions should be None (0)"
        );

        // Verify HostInfo properties (lines 38-45)
        assert_eq!(
            create_pipeline.host_info.is_host_null, true,
            "_isHostNull should be true"
        );
        assert_eq!(
            create_pipeline.host_info.is_host_ui_null, true,
            "_isHostUINull should be true"
        );
        assert_eq!(
            create_pipeline.host_info.is_host_raw_ui_null, true,
            "_isHostRawUINull should be true"
        );
        assert_eq!(
            create_pipeline.host_info.use_runspace_host, true,
            "_useRunspaceHost should be true"
        );

        // Verify PowerShell pipeline properties (lines 46-88)
        assert_eq!(
            create_pipeline.power_shell.is_nested, false,
            "PowerShell.IsNested should be false"
        );
        assert_eq!(
            create_pipeline.power_shell.redirect_shell_error_output_pipe, true,
            "RedirectShellErrorOutputPipe should be true"
        );
        assert_eq!(
            create_pipeline.power_shell.history, "",
            "History should be empty string (Nil in XML)"
        );

        // Verify Commands array (line 53-83)
        assert_eq!(
            create_pipeline.power_shell.cmds.len(),
            1,
            "Should have exactly 1 command"
        );

        // Verify Command properties (lines 54-82)
        let cmd = &create_pipeline.power_shell.cmds[0];
        assert_eq!(
            cmd.cmd, r#"Write-Host "Remote System: $($env:COMPUTERNAME) - $(Get-Date)""#,
            "Command text should match"
        );
        assert_eq!(cmd.is_script, true, "IsScript should be true");
        assert_eq!(
            cmd.use_local_scope, None,
            "UseLocalScope should be None (Nil in XML)"
        );
        assert_eq!(cmd.args.len(), 0, "Args should be empty list");

        // Verify merge properties all reference the same PipelineResultTypes::None (0)
        assert_eq!(
            cmd.merge_my_result,
            PipelineResultTypes::None,
            "MergeMyResult should be None (0)"
        );
        assert_eq!(
            cmd.merge_to_result,
            PipelineResultTypes::None,
            "MergeToResult should be None (0)"
        );
        assert_eq!(
            cmd.merge_previous_results,
            PipelineResultTypes::None,
            "MergePreviousResults should be None (0)"
        );
        assert_eq!(
            cmd.merge_error,
            PipelineResultTypes::None,
            "MergeError should be None (0)"
        );
        assert_eq!(
            cmd.merge_warning,
            PipelineResultTypes::None,
            "MergeWarning should be None (0)"
        );
        assert_eq!(
            cmd.merge_verbose,
            PipelineResultTypes::None,
            "MergeVerbose should be None (0)"
        );
        assert_eq!(
            cmd.merge_debug,
            PipelineResultTypes::None,
            "MergeDebug should be None (0)"
        );
        assert_eq!(
            cmd.merge_information,
            PipelineResultTypes::None,
            "MergeInformation should be None (0)"
        );
    } else {
        panic!("Expected ComplexObject");
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/information_record.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, PsObjectWithType, PsPrimitiveValue, PsProperty, PsType,
    PsValue,
};
use std::{borrow::Cow, collections::BTreeMap};

#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct InformationRecord {
    pub message_data: String,
    #[builder(default = false)]
    pub serialize_invocation_info: bool,
    #[builder(default)]
    pub source: Option<String>,
    #[builder(default)]
    pub time_generated: Option<String>,
    #[builder(default)]
    pub tags: Option<Vec<String>>,
    #[builder(default)]
    pub user: Option<String>,
    #[builder(default)]
    pub computer: Option<String>,
    #[builder(default)]
    pub process_id: Option<i32>,
    #[builder(default)]
    pub native_thread_id: Option<i32>,
    #[builder(default)]
    pub managed_thread_id: Option<i32>,
}

impl PsObjectWithType for InformationRecord {
    fn message_type(&self) -> MessageType {
        MessageType::InformationRecord
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<InformationRecord> for ComplexObject {
    fn from(record: InformationRecord) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "InformationalRecord_Message".to_string(),
            PsProperty {
                name: "InformationalRecord_Message".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Str(record.message_data.clone())),
            },
        );

        extended_properties.insert(
            "InformationalRecord_SerializeInvocationInfo".to_string(),
            PsProperty {
                name: "InformationalRecord_SerializeInvocationInfo".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(record.serialize_invocation_info)),
            },
        );

        if let Some(source) = record.source {
            extended_properties.insert(
                "InformationalRecord_Source".to_string(),
                PsProperty {
                    name: "InformationalRecord_Source".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::Str(source)),
                },
            );
        }

        if let Some(time) = record.time_generated {
            extended_properties.insert(
                "InformationalRecord_TimeGenerated".to_string(),
                PsProperty {
                    name: "InformationalRecord_TimeGenerated".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::Str(time)),
                },
            );
        }

        if let Some(tags) = record.tags
            && !tags.is_empty()
        {
            let tag_values: Vec<PsValue> = tags
                .into_iter()
                .map(|tag| PsValue::Primitive(PsPrimitiveValue::Str(tag)))
                .collect();

            // Create array-like structure for tags
            let tags_obj = ComplexObject {
                type_def: Some(PsType {
                    type_names: vec![
                        Cow::Borrowed("System.String[]"),
                        Cow::Borrowed("System.Array"),
                        Cow::Borrowed("System.Object"),
                    ],
                }),
                to_string: None,
                content: ComplexObjectContent::Standard,
                adapted_properties: BTreeMap::new(),
                extended_properties: tag_values
                    .into_iter()
                    .enumerate()
                    .map(|(i, val)| {
                        (
                            i.to_string(),
                            PsProperty {
                                name: i.to_string(),
                                value: val,
                            },
                        )
                    })
                    .collect(),
            };

            extended_properties.insert(
                "InformationalRecord_Tags".to_string(),
                PsProperty {
                    name: "InformationalRecord_Tags".to_string(),
                    value: PsValue::Object(tags_obj),
                },
            );
        }

        if let Some(user) = record.user {
            extended_properties.insert(
                "InformationalRecord_User".to_string(),
                PsProperty {
                    name: "InformationalRecord_User".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::Str(user)),
                },
            );
        }

        if let Some(computer) = record.computer {
            extended_properties.insert(
                "InformationalRecord_Computer".to_string(),
                PsProperty {
                    name: "InformationalRecord_Computer".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::Str(computer)),
                },
            );
        }

        if let Some(pid) = record.process_id {
            extended_properties.insert(
                "InformationalRecord_ProcessId".to_string(),
                PsProperty {
                    name: "InformationalRecord_ProcessId".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::I32(pid)),
                },
            );
        }

        if let Some(native_tid) = record.native_thread_id {
            extended_properties.insert(
                "InformationalRecord_NativeThreadId".to_string(),
                PsProperty {
                    name: "InformationalRecord_NativeThreadId".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::I32(native_tid)),
                },
            );
        }

        if let Some(managed_tid) = record.managed_thread_id {
            extended_properties.insert(
                "InformationalRecord_ManagedThreadId".to_string(),
                PsProperty {
                    name: "InformationalRecord_ManagedThreadId".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::I32(managed_tid)),
                },
            );
        }

        ComplexObject {
            type_def: Some(PsType {
                type_names: vec![
                    Cow::Borrowed("System.Management.Automation.InformationRecord"),
                    Cow::Borrowed("System.Management.Automation.InformationalRecord"),
                    Cow::Borrowed("System.Object"),
                ],
            }),
            to_string: Some(record.message_data),
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for InformationRecord {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let message_data = value
            .extended_properties
            .get("InformationalRecord_Message")
            .ok_or_else(|| {
                Self::Error::InvalidMessage(
                    "Missing InformationalRecord_Message property".to_string(),
                )
            })?;
        let message_data = match &message_data.value {
            PsValue::Primitive(PsPrimitiveValue::Str(s)) => s.clone(),
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "InformationalRecord_Message property is not a string".to_string(),
                ));
            }
        };

        let serialize_invocation_info = value
            .extended_properties
            .get("InformationalRecord_SerializeInvocationInfo")
            .map(|prop| match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::Bool(b)) => *b,
                _ => false,
            })
            .unwrap_or(false);

        let source = value
            .extended_properties
            .get("InformationalRecord_Source")
            .and_then(|prop| match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::Str(s)) => Some(s.clone()),
                _ => None,
            });

        let time_generated = value
            .extended_properties
            .get("InformationalRecord_TimeGenerated")
            .and_then(|prop| match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::Str(s)) => Some(s.clone()),
                _ => None,
            });

        let tags = value
            .extended_properties
            .get("InformationalRecord_Tags")
            .and_then(|prop| match &prop.value {
                PsValue::Object(obj) => {
                    let mut tags = Vec::new();
                    for prop in obj.extended_properties.values() {
                        if let PsValue::Primitive(PsPrimitiveValue::Str(s)) = &prop.value {
                            tags.push(s.clone());
                        }
                    }
                    if tags.is_empty() { None } else { Some(tags) }
                }
                _ => None,
            });

        let user = value
            .extended_properties
            .get("InformationalRecord_User")
            .and_then(|prop| match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::Str(s)) => Some(s.clone()),
                _ => None,
            });

        let computer = value
            .extended_properties
            .get("InformationalRecord_Computer")
            .and_then(|prop| match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::Str(s)) => Some(s.clone()),
                _ => None,
            });

        let process_id = value
            .extended_properties
            .get("InformationalRecord_ProcessId")
            .and_then(|prop| match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::I32(id)) => Some(*id),
                _ => None,
            });

        let native_thread_id = value
            .extended_properties
            .get("InformationalRecord_NativeThreadId")
            .and_then(|prop| match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::I32(id)) => Some(*id),
                _ => None,
            });

        let managed_thread_id = value
            .extended_properties
            .get("InformationalRecord_ManagedThreadId")
            .and_then(|prop| match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::I32(id)) => Some(*id),
                _ => None,
            });

        Ok(InformationRecord::builder()
            .message_data(message_data)
            .serialize_invocation_info(serialize_invocation_info)
            .source(source)
            .time_generated(time_generated)
            .tags(tags)
            .user(user)
            .computer(computer)
            .process_id(process_id)
            .native_thread_id(native_thread_id)
            .managed_thread_id(managed_thread_id)
            .build())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_information_record_basic() {
        let record = InformationRecord::builder()
            .message_data("This is an informational message.".to_string())
            .serialize_invocation_info(false)
            .build();

        let complex_obj = ComplexObject::from(record.clone());
        let roundtrip = InformationRecord::try_from(complex_obj).unwrap();

        assert_eq!(record, roundtrip);
    }

    #[test]
    fn test_information_record_with_metadata() {
        let record = InformationRecord::builder()
            .message_data("Test message with metadata".to_string())
            .serialize_invocation_info(true)
            .source(Some("Write-Information".to_string()))
            .user(Some("TestUser".to_string()))
            .computer(Some("TestComputer".to_string()))
            .process_id(Some(1234))
            .native_thread_id(Some(5678))
            .managed_thread_id(Some(9012))
            .build();

        let complex_obj = ComplexObject::from(record.clone());
        let roundtrip = InformationRecord::try_from(complex_obj).unwrap();

        assert_eq!(record, roundtrip);
    }

    #[test]
    fn test_information_record_with_tags() {
        let record = InformationRecord::builder()
            .message_data("Tagged message".to_string())
            .tags(Some(vec!["tag1".to_string(), "tag2".to_string()]))
            .build();

        let complex_obj = ComplexObject::from(record.clone());
        let roundtrip = InformationRecord::try_from(complex_obj).unwrap();

        assert_eq!(record, roundtrip);
    }

    #[test]
    fn test_message_type() {
        let record = InformationRecord::builder()
            .message_data("Test".to_string())
            .build();

        assert_eq!(record.message_type().value(), 0x00041011);
    }

    #[test]
    fn test_to_string_property() {
        let record = InformationRecord::builder()
            .message_data("Test message".to_string())
            .build();

        let complex_obj = ComplexObject::from(record);
        assert_eq!(complex_obj.to_string, Some("Test message".to_string()));
    }

    #[test]
    fn test_type_names() {
        let record = InformationRecord::builder()
            .message_data("Test".to_string())
            .build();

        let complex_obj = ComplexObject::from(record);
        let type_def = complex_obj.type_def.unwrap();
        assert_eq!(type_def.type_names.len(), 3);
        assert_eq!(
            type_def.type_names[0].as_ref(),
            "System.Management.Automation.InformationRecord"
        );
        assert_eq!(
            type_def.type_names[1].as_ref(),
            "System.Management.Automation.InformationalRecord"
        );
        assert_eq!(type_def.type_names[2].as_ref(), "System.Object");
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/init_runspace_pool/apartment_state.rs ---
use crate::ps_value::{ComplexObject, ComplexObjectContent, PsEnums, PsType};
use std::{borrow::Cow, collections::BTreeMap};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ApartmentState {
    STA = 0,
    MTA = 1,
    Unknown = 2,
}

impl From<ApartmentState> for ComplexObject {
    fn from(state: ApartmentState) -> Self {
        let type_def = PsType {
            type_names: vec![
                Cow::Borrowed("System.Threading.ApartmentState"),
                Cow::Borrowed("System.Enum"),
                Cow::Borrowed("System.ValueType"),
                Cow::Borrowed("System.Object"),
            ],
        };

        let to_string = match state {
            ApartmentState::STA => "STA".to_string(),
            ApartmentState::MTA => "MTA".to_string(),
            ApartmentState::Unknown => "Unknown".to_string(),
        };

        ComplexObject {
            type_def: Some(type_def),
            to_string: Some(to_string),
            content: ComplexObjectContent::PsEnums(PsEnums {
                value: state as i32,
            }),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        }
    }
}

// TODO: Add tests for new ComplexObject representation


--- File: crates/protocol-powershell-remoting/src/messages/init_runspace_pool/application_private_data.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, Container, PsObjectWithType, PsPrimitiveValue, PsProperty,
    PsType, PsValue,
};
use std::collections::BTreeMap;

/// ApplicationPrivateData is a specific message type within the PowerShell Remoting Protocol (PSRP)
/// that facilitates the exchange of private application-level data between a server and a client.
///
/// MessageType value: 0x00021009
/// Direction: Server to Client
/// Target: RunspacePool
///
/// The data contains an extended property named "ApplicationPrivateData" with a value that is
/// either a Primitive Dictionary or a Null Value.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ApplicationPrivateData {
    /// The application private data as a dictionary of string keys to primitive values
    pub data: Option<BTreeMap<String, PsValue>>,
}

impl ApplicationPrivateData {
    /// Create a new ApplicationPrivateData with no data (null value)
    pub fn new() -> Self {
        Self { data: None }
    }
}

impl Default for ApplicationPrivateData {
    fn default() -> Self {
        Self::new()
    }
}

impl PsObjectWithType for ApplicationPrivateData {
    fn message_type(&self) -> MessageType {
        MessageType::ApplicationPrivateData
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<ApplicationPrivateData> for ComplexObject {
    fn from(app_data: ApplicationPrivateData) -> Self {
        let mut extended_properties = BTreeMap::new();

        let application_private_data_value = match app_data.data {
            Some(data) => {
                // Convert BTreeMap<String, PsPrimitiveValue> to BTreeMap<PsValue, PsValue>
                let ps_dict: BTreeMap<PsValue, PsValue> = data
                    .into_iter()
                    .map(|(k, v)| (PsValue::Primitive(PsPrimitiveValue::Str(k)), v))
                    .collect();

                PsValue::Object(ComplexObject {
                    type_def: Some(PsType::ps_primitive_dictionary()),
                    to_string: None,
                    content: ComplexObjectContent::Container(Container::Dictionary(ps_dict)),
                    adapted_properties: BTreeMap::new(),
                    extended_properties: BTreeMap::new(),
                })
            }
            None => PsValue::Primitive(PsPrimitiveValue::Nil),
        };

        extended_properties.insert(
            "ApplicationPrivateData".to_string(),
            PsProperty {
                name: "ApplicationPrivateData".to_string(),
                value: application_private_data_value,
            },
        );

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for ApplicationPrivateData {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let app_data_property = value
            .extended_properties
            .get("ApplicationPrivateData")
            .ok_or_else(|| {
                Self::Error::InvalidMessage("Missing ApplicationPrivateData property".to_string())
            })?;

        let data = if let PsValue::Primitive(PsPrimitiveValue::Nil) = &app_data_property.value {
            None
        } else {
            let PsValue::Object(obj) = &app_data_property.value else {
                return Err(Self::Error::InvalidMessage(
                    "ApplicationPrivateData property has invalid type".to_string(),
                ));
            };

            let ComplexObjectContent::Container(Container::Dictionary(dict)) = &obj.content else {
                return Err(Self::Error::InvalidMessage(
                    "ApplicationPrivateData is not a dictionary".to_string(),
                ));
            };

            let mut result = BTreeMap::new();
            for (key, value) in dict {
                let PsValue::Primitive(PsPrimitiveValue::Str(_)) = key else {
                    return Err(Self::Error::InvalidMessage(
                        "Dictionary key is not a string".to_string(),
                    ));
                };

                let PsValue::Object(value_obj) = value else {
                    return Err(Self::Error::InvalidMessage(
                        "Dictionary value is not an object".to_string(),
                    ));
                };

                debug_assert!(value_obj.type_def == Some(PsType::ps_primitive_dictionary()));

                let ComplexObjectContent::Container(Container::Dictionary(value_dict)) =
                    &value_obj.content
                else {
                    return Err(Self::Error::InvalidMessage(format!(
                        "Dictionary value is not a primitive dictionary: {:#?}",
                        value_obj.content
                    )));
                };

                for (value_key, value_value) in value_dict {
                    let PsValue::Primitive(PsPrimitiveValue::Str(value_key_str)) = value_key else {
                        return Err(Self::Error::InvalidMessage(
                            "Dictionary key is not a string".to_string(),
                        ));
                    };

                    result.insert(value_key_str.clone(), value_value.clone());
                }
            }

            Some(result)
        };

        Ok(ApplicationPrivateData { data })
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/init_runspace_pool/host_default_data.rs ---
use crate::ps_value::{ComplexObject, ComplexObjectContent, PsPrimitiveValue, PsProperty, PsValue};
use std::collections::BTreeMap;
use typed_builder::TypedBuilder;

#[derive(Debug, Clone, PartialEq, Eq, Default, TypedBuilder)]
pub struct Coordinates {
    #[builder(default = 0)]
    pub x: i32,
    #[builder(default = 0)]
    pub y: i32,
}

impl From<Coordinates> for ComplexObject {
    fn from(coords: Coordinates) -> Self {
        let mut extended_properties = BTreeMap::new();
        extended_properties.insert(
            "x".to_string(),
            PsProperty {
                name: "x".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(coords.x)),
            },
        );
        extended_properties.insert(
            "y".to_string(),
            PsProperty {
                name: "y".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(coords.y)),
            },
        );
        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default, TypedBuilder)]
pub struct Size {
    #[builder(default = 0)]
    pub width: i32,
    #[builder(default = 0)]
    pub height: i32,
}

impl From<Size> for ComplexObject {
    fn from(size: Size) -> Self {
        let mut extended_properties = BTreeMap::new();
        extended_properties.insert(
            "width".to_string(),
            PsProperty {
                name: "width".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(size.width)),
            },
        );
        extended_properties.insert(
            "height".to_string(),
            PsProperty {
                name: "height".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(size.height)),
            },
        );
        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, TypedBuilder)]
pub struct HostDefaultData {
    #[builder(default = 7)]
    pub foreground_color: i32, // Key 0: System.ConsoleColor
    #[builder(default = 0)]
    pub background_color: i32, // Key 1: System.ConsoleColor
    #[builder(default)]
    pub cursor_position: Coordinates, // Key 2: System.Management.Automation.Host.Coordinates
    #[builder(default)]
    pub window_position: Coordinates, // Key 3: System.Management.Automation.Host.Coordinates
    #[builder(default = 25)]
    pub max_physical_cursor_size: i32, // Key 4: System.Int32
    #[builder(default_code = "Size { width: 120, height: 30 }")]
    pub window_size: Size, // Key 5: System.Management.Automation.Host.Size
    #[builder(default_code = "Size { width: 120, height: 30 }")]
    pub buffer_size: Size, // Key 6: System.Management.Automation.Host.Size
    #[builder(default_code = "Size { width: 120, height: 30 }")]
    pub max_window_size: Size, // Key 7: System.Management.Automation.Host.Size
    #[builder(default_code = "Size { width: 3824, height: 2121 }")]
    pub max_physical_window_size: Size, // Key 8: System.Management.Automation.Host.Size
    #[builder(default = "PowerShell".to_string())]
    pub host_name: String, // Key 9: System.String
}

impl Default for HostDefaultData {
    fn default() -> Self {
        Self::builder().build()
    }
}

impl HostDefaultData {
    // Convert to the BTreeMap<PsValue, PsValue> format expected by HostInfo DCT
    pub fn to_dictionary(&self) -> BTreeMap<PsValue, PsValue> {
        let mut map = BTreeMap::new();

        // Key 0: Foreground color
        let mut fg_props = BTreeMap::new();
        fg_props.insert(
            "T".to_string(),
            PsProperty {
                name: "T".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Str("System.ConsoleColor".to_string())),
            },
        );
        fg_props.insert(
            "V".to_string(),
            PsProperty {
                name: "V".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(self.foreground_color)),
            },
        );
        map.insert(
            PsValue::Primitive(PsPrimitiveValue::I32(0)),
            PsValue::Object(ComplexObject {
                type_def: None,
                to_string: None,
                content: ComplexObjectContent::Standard,
                adapted_properties: BTreeMap::new(),
                extended_properties: fg_props,
            }),
        );

        // Simplified implementation - just add essential host name entry
        // Key 9: Host name
        let mut host_props = BTreeMap::new();
        host_props.insert(
            "T".to_string(),
            PsProperty {
                name: "T".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Str("System.String".to_string())),
            },
        );
        host_props.insert(
            "V".to_string(),
            PsProperty {
                name: "V".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Str(self.host_name.clone())),
            },
        );
        map.insert(
            PsValue::Primitive(PsPrimitiveValue::I32(9)),
            PsValue::Object(ComplexObject {
                type_def: None,
                to_string: None,
                content: ComplexObjectContent::Standard,
                adapted_properties: BTreeMap::new(),
                extended_properties: host_props,
            }),
        );

        map
    }
}

// TODO: Add tests for new ComplexObject representation


--- File: crates/protocol-powershell-remoting/src/messages/init_runspace_pool/host_info.rs ---
use super::HostDefaultData;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, Container, PsPrimitiveValue, PsProperty, PsType, PsValue,
};
use std::{borrow::Cow, collections::BTreeMap};

#[derive(Debug, Clone, PartialEq, Eq, Default, typed_builder::TypedBuilder)]
pub struct HostInfo {
    #[builder(default = false)]
    pub is_host_null: bool,
    #[builder(default = false)]
    pub is_host_ui_null: bool,
    #[builder(default = false)]
    pub is_host_raw_ui_null: bool,
    #[builder(default = false)]
    pub use_runspace_host: bool,
    #[builder(default)]
    pub host_default_data: HostDefaultData,
}

impl HostInfo {
    pub fn enabled_all() -> Self {
        HostInfo {
            is_host_null: true,
            is_host_ui_null: true,
            is_host_raw_ui_null: true,
            use_runspace_host: true,
            host_default_data: HostDefaultData::default(),
        }
    }
}

impl From<HostInfo> for ComplexObject {
    fn from(host_info: HostInfo) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "_isHostNull".to_string(),
            PsProperty {
                name: "_isHostNull".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(host_info.is_host_null)),
            },
        );

        extended_properties.insert(
            "_isHostUINull".to_string(),
            PsProperty {
                name: "_isHostUINull".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(host_info.is_host_ui_null)),
            },
        );

        extended_properties.insert(
            "_isHostRawUINull".to_string(),
            PsProperty {
                name: "_isHostRawUINull".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(host_info.is_host_raw_ui_null)),
            },
        );

        extended_properties.insert(
            "_useRunspaceHost".to_string(),
            PsProperty {
                name: "_useRunspaceHost".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Bool(host_info.use_runspace_host)),
            },
        );

        let host_default_data = host_info.host_default_data;
        let data_props = BTreeMap::from([(
            "data".to_string(),
            PsProperty {
                name: "data".to_string(),
                value: PsValue::Object(ComplexObject {
                    type_def: Some(PsType {
                        type_names: vec![
                            Cow::Borrowed("System.Collections.Hashtable"),
                            Cow::Borrowed("System.Object"),
                        ],
                    }),
                    to_string: None,
                    content: ComplexObjectContent::Container(Container::Dictionary(
                        host_default_data.to_dictionary(),
                    )),
                    adapted_properties: BTreeMap::new(),
                    extended_properties: BTreeMap::new(),
                }),
            },
        )]);

        let host_data_obj = ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties: data_props,
        };

        extended_properties.insert(
            "_hostDefaultData".to_string(),
            PsProperty {
                name: "_hostDefaultData".to_string(),
                value: PsValue::Object(host_data_obj),
            },
        );

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for HostInfo {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let get_bool_property = |name: &str| -> Result<bool, Self::Error> {
            let property = value
                .extended_properties
                .get(name)
                .ok_or_else(|| Self::Error::InvalidMessage(format!("Missing property: {name}")))?;

            match &property.value {
                PsValue::Primitive(PsPrimitiveValue::Bool(b)) => Ok(*b),
                _ => Err(Self::Error::InvalidMessage(format!(
                    "Property '{name}' is not a Bool"
                ))),
            }
        };

        let is_host_null = get_bool_property("_isHostNull").unwrap_or(false);
        let is_host_ui_null = get_bool_property("_isHostUINull").unwrap_or(false);
        let is_host_raw_ui_null = get_bool_property("_isHostRawUINull").unwrap_or(false);
        let use_runspace_host = get_bool_property("_useRunspaceHost").unwrap_or(false);

        // For now, use default HostDefaultData since it's complex to deserialize
        // and the real XML example doesn't seem to include the full host default data
        let host_default_data = HostDefaultData::default();

        Ok(HostInfo {
            is_host_null,
            is_host_ui_null,
            is_host_raw_ui_null,
            use_runspace_host,
            host_default_data,
        })
    }
}

// TODO: Add tests for new ComplexObject representation


--- File: crates/protocol-powershell-remoting/src/messages/init_runspace_pool/mod.rs ---
pub mod apartment_state;
pub mod application_private_data;
pub mod host_default_data;
pub mod host_info;
pub mod ps_thread_options;

pub use apartment_state::ApartmentState;
pub use application_private_data::ApplicationPrivateData;
pub use host_default_data::{Coordinates, HostDefaultData, Size};
pub use host_info::HostInfo;
pub use ps_thread_options::PSThreadOptions;

use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, Container, PsObjectWithType, PsPrimitiveValue, PsProperty,
    PsType, PsValue,
};
use std::collections::BTreeMap;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct InitRunspacePool {
    pub min_runspaces: i32,
    pub max_runspaces: i32,
    pub thread_options: PSThreadOptions,
    pub apartment_state: ApartmentState,
    pub host_info: HostInfo,
    pub application_arguments: BTreeMap<PsValue, PsValue>,
}

impl From<InitRunspacePool> for ComplexObject {
    fn from(init: InitRunspacePool) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "MinRunspaces".to_string(),
            PsProperty {
                name: "MinRunspaces".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(init.min_runspaces)),
            },
        );

        extended_properties.insert(
            "MaxRunspaces".to_string(),
            PsProperty {
                name: "MaxRunspaces".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(init.max_runspaces)),
            },
        );

        extended_properties.insert(
            "PSThreadOptions".to_string(),
            PsProperty {
                name: "PSThreadOptions".to_string(),
                value: PsValue::Object(init.thread_options.into()),
            },
        );

        extended_properties.insert(
            "ApartmentState".to_string(),
            PsProperty {
                name: "ApartmentState".to_string(),
                value: PsValue::Object(init.apartment_state.into()),
            },
        );

        extended_properties.insert(
            "HostInfo".to_string(),
            PsProperty {
                name: "HostInfo".to_string(),
                value: PsValue::Object(init.host_info.clone().into()),
            },
        );

        if init.application_arguments.is_empty() {
            extended_properties.insert(
                "ApplicationArguments".to_string(),
                PsProperty {
                    name: "ApplicationArguments".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::Nil),
                },
            );
        } else {
            let app_args_obj = ComplexObject {
                type_def: Some(PsType::ps_primitive_dictionary()),
                content: ComplexObjectContent::Container(Container::Dictionary(
                    init.application_arguments,
                )),
                ..Default::default()
            };

            extended_properties.insert(
                "ApplicationArguments".to_string(),
                PsProperty {
                    name: "ApplicationArguments".to_string(),
                    value: PsValue::Object(app_args_obj),
                },
            );
        }

        ComplexObject {
            content: ComplexObjectContent::Standard,
            extended_properties,
            ..Default::default()
        }
    }
}

impl PsObjectWithType for InitRunspacePool {
    fn message_type(&self) -> MessageType {
        MessageType::InitRunspacepool
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/init_runspace_pool/ps_thread_options.rs ---
use crate::ps_value::{ComplexObject, ComplexObjectContent, PsEnums, PsType};
use std::{borrow::Cow, collections::BTreeMap};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PSThreadOptions {
    Default = 0,
    UseNewThread = 1,
    ReuseThread = 2,
    UseCurrentThread = 3,
}

impl From<PSThreadOptions> for ComplexObject {
    fn from(option: PSThreadOptions) -> Self {
        let type_def = PsType {
            type_names: vec![
                Cow::Borrowed("System.Management.Automation.Runspaces.PSThreadOptions"),
                Cow::Borrowed("System.Enum"),
                Cow::Borrowed("System.ValueType"),
                Cow::Borrowed("System.Object"),
            ],
        };

        let to_string = match option {
            PSThreadOptions::Default => "Default".to_string(),
            PSThreadOptions::UseNewThread => "UseNewThread".to_string(),
            PSThreadOptions::ReuseThread => "ReuseThread".to_string(),
            PSThreadOptions::UseCurrentThread => "UseCurrentThread".to_string(),
        };

        ComplexObject {
            type_def: Some(type_def),
            to_string: Some(to_string),
            content: ComplexObjectContent::PsEnums(PsEnums {
                value: option as i32,
            }),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        }
    }
}

// TODO: Add tests for new ComplexObject representation


--- File: crates/protocol-powershell-remoting/src/messages/mod.rs ---
pub mod create_pipeline;
pub mod information_record;
pub mod init_runspace_pool;
pub mod pipeline_host_call;
pub mod pipeline_host_response;
pub mod pipeline_input;
pub mod pipeline_output;
pub mod pipeline_state;
pub mod progress_record;
pub mod runspace_pool_host_call;
pub mod runspace_pool_host_response;
pub mod runspace_pool_state;
pub mod session_capability;

pub use create_pipeline::*;
pub use information_record::*;
pub use init_runspace_pool::*;
pub use pipeline_host_call::*;
pub use pipeline_host_response::*;
pub use pipeline_output::*;
pub use pipeline_state::*;
pub use progress_record::*;
pub use runspace_pool_host_call::*;
pub use runspace_pool_host_response::*;
pub use runspace_pool_state::*;
pub use session_capability::*;

// Re-export ps_value types for backwards compatibility
pub use crate::ps_value::{
    ComplexObject, ComplexObjectContent, Container, PsEnums, PsPrimitiveValue, PsProperty, PsType,
    PsValue, deserialize,
};


--- File: crates/protocol-powershell-remoting/src/messages/pipeline_host_call.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, Container, PsObjectWithType, PsPrimitiveValue, PsProperty,
    PsType, PsValue,
};
use std::collections::BTreeMap;

/// PipelineHostCall is a message sent from the server to the client to perform
/// a method call on the host associated with a Pipeline on the server.
///
/// MessageType value: 0x00041100
/// Direction: Server to Client
/// Target: Pipeline
///
/// The message format is identical to RUNSPACEPOOL_HOST_CALL but applies to
/// a specific pipeline rather than the runspace pool.
///
/// The message contains:
/// - Call ID (ci): A signed long integer to associate with the response
/// - Host method identifier (mi): Identifies the specific host method to execute
/// - Parameters for the method (mp): Arguments required for the host method call
///
/// Example scenarios:
/// - Write-Progress calls during pipeline execution to update progress displays
/// - Read-Host calls during pipeline execution to prompt for user input
/// - Other host interaction methods required during pipeline processing
#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct PipelineHostCall {
    /// Unique identifier for this host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Parameters for the method call as a list of values
    #[builder(default)]
    pub parameters: Vec<PsValue>,
}

impl PsObjectWithType for PipelineHostCall {
    fn message_type(&self) -> MessageType {
        MessageType::PipelineHostCall
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<PipelineHostCall> for ComplexObject {
    fn from(host_call: PipelineHostCall) -> Self {
        let mut extended_properties = BTreeMap::new();

        // Call ID (ci)
        extended_properties.insert(
            "ci".to_string(),
            PsProperty {
                name: "ci".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I64(host_call.call_id)),
            },
        );

        // Host method identifier (mi)
        let method_id_obj = ComplexObject {
            type_def: Some(PsType::remote_host_method_id()),
            to_string: Some(host_call.method_name),
            content: ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(
                host_call.method_id,
            )),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        extended_properties.insert(
            "mi".to_string(),
            PsProperty {
                name: "mi".to_string(),
                value: PsValue::Object(method_id_obj),
            },
        );

        // Method parameters (mp) as ArrayList
        let parameters_obj = ComplexObject {
            type_def: Some(PsType::array_list()),
            to_string: None,
            content: ComplexObjectContent::Container(Container::List(host_call.parameters)),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        extended_properties.insert(
            "mp".to_string(),
            PsProperty {
                name: "mp".to_string(),
                value: PsValue::Object(parameters_obj),
            },
        );

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for PipelineHostCall {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        // Extract call_id (ci)
        let ci_property = value.extended_properties.get("ci").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing call ID (ci) property".to_string())
        })?;

        let PsValue::Primitive(PsPrimitiveValue::I64(call_id)) = &ci_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Call ID (ci) is not a signed long integer".to_string(),
            ));
        };

        // Extract method identifier (mi)
        let mi_property = value.extended_properties.get("mi").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing method identifier (mi) property".to_string())
        })?;

        let PsValue::Object(mi_obj) = &mi_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Method identifier (mi) is not an object".to_string(),
            ));
        };

        let method_id = match &mi_obj.content {
            ComplexObjectContent::PsEnums(ps_enums) => ps_enums.value,
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "Method identifier content is not an I32 or Enum".to_string(),
                ));
            }
        };

        let method_name = mi_obj.to_string.clone().unwrap_or_default();

        // Extract method parameters (mp)
        let mp_property = value.extended_properties.get("mp").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing method parameters (mp) property".to_string())
        })?;

        let PsValue::Object(mp_obj) = &mp_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Method parameters (mp) is not an object".to_string(),
            ));
        };

        let parameters =
            if let ComplexObjectContent::Container(Container::List(params)) = &mp_obj.content {
                params.clone()
            } else {
                // Empty list case
                Vec::new()
            };

        Ok(PipelineHostCall {
            call_id: *call_id,
            method_id,
            method_name,
            parameters,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ps_value::PsPrimitiveValue;

    #[test]
    fn test_pipeline_host_call_roundtrip() {
        let original = PipelineHostCall::builder()
            .call_id(42)
            .method_id(11) // ReadLine method
            .method_name("ReadLine".to_string())
            .parameters(vec![PsValue::Primitive(PsPrimitiveValue::Str(
                "Please enter your username".to_string(),
            ))])
            .build();

        let complex_obj = ComplexObject::from(original.clone());
        let restored = PipelineHostCall::try_from(complex_obj).unwrap();

        assert_eq!(original, restored);
    }

    #[test]
    fn test_pipeline_host_call_empty_parameters() {
        let original = PipelineHostCall::builder()
            .call_id(1)
            .method_id(20) // WriteProgress method
            .method_name("WriteProgress".to_string())
            .build();

        let complex_obj = ComplexObject::from(original.clone());
        let restored = PipelineHostCall::try_from(complex_obj).unwrap();

        assert_eq!(original, restored);
        assert!(restored.parameters.is_empty());
    }

    #[test]
    fn test_pipeline_host_call_message_type() {
        let host_call = PipelineHostCall::builder()
            .call_id(1)
            .method_id(11)
            .method_name("ReadLine".to_string())
            .build();

        assert_eq!(host_call.message_type(), MessageType::PipelineHostCall);
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/pipeline_host_response.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, PsObjectWithType, PsPrimitiveValue, PsProperty, PsType,
    PsValue,
};
use std::collections::BTreeMap;

/// PipelineHostResponse is a message sent from the client to the server as a response
/// from a host call executed on the client Pipeline's host.
///
/// MessageType value: 0x00041101
/// Direction: Client to Server
/// Target: Pipeline
///
/// The message format is identical to RUNSPACEPOOL_HOST_RESPONSE but applies to
/// a specific pipeline rather than the runspace pool.
///
/// The message contains:
/// - Call ID (ci): Must match the corresponding PIPELINE_HOST_CALL message
/// - Host method identifier (mi): Identifies the host method from which the response originates
/// - Return value of the method (mr): Optional return value from the host method
/// - Exception thrown by a host method invocation (me): Optional error information
///
/// Example scenarios:
/// - Response to Read-Host with user input ("Alice")
/// - Response to Write-Progress (typically no return value)
/// - Response to other host interaction methods with their respective return values or exceptions
#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct PipelineHostResponse {
    /// Call ID that matches the corresponding host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Optional return value from the method
    #[builder(default, setter(strip_option(fallback_suffix = "_opt")))]
    pub method_result: Option<PsValue>,
    /// Optional exception thrown by the method invocation
    #[builder(default, setter(strip_option(fallback_suffix = "_opt")))]
    pub method_exception: Option<PsValue>,
}

impl PsObjectWithType for PipelineHostResponse {
    fn message_type(&self) -> MessageType {
        MessageType::PipelineHostResponse
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<PipelineHostResponse> for ComplexObject {
    fn from(host_response: PipelineHostResponse) -> Self {
        let mut extended_properties = BTreeMap::new();

        // Call ID (ci)
        extended_properties.insert(
            "ci".to_string(),
            PsProperty {
                name: "ci".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I64(host_response.call_id)),
            },
        );

        // Host method identifier (mi)
        let method_id_obj = ComplexObject {
            type_def: Some(PsType::remote_host_method_id()),
            to_string: Some(host_response.method_name),
            content: ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(
                host_response.method_id,
            )),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        extended_properties.insert(
            "mi".to_string(),
            PsProperty {
                name: "mi".to_string(),
                value: PsValue::Object(method_id_obj),
            },
        );

        // Method result (mr) - optional
        if let Some(result) = host_response.method_result {
            extended_properties.insert(
                "mr".to_string(),
                PsProperty {
                    name: "mr".to_string(),
                    value: result,
                },
            );
        }

        // Method exception (me) - optional
        if let Some(exception) = host_response.method_exception {
            extended_properties.insert(
                "me".to_string(),
                PsProperty {
                    name: "me".to_string(),
                    value: exception,
                },
            );
        }

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for PipelineHostResponse {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        // Extract call_id (ci)
        let ci_property = value.extended_properties.get("ci").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing call ID (ci) property".to_string())
        })?;

        let PsValue::Primitive(PsPrimitiveValue::I64(call_id)) = &ci_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Call ID (ci) is not a signed long integer".to_string(),
            ));
        };

        // Extract method identifier (mi)
        let mi_property = value.extended_properties.get("mi").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing method identifier (mi) property".to_string())
        })?;

        let PsValue::Object(mi_obj) = &mi_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Method identifier (mi) is not an object".to_string(),
            ));
        };

        let ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(method_id)) =
            &mi_obj.content
        else {
            return Err(Self::Error::InvalidMessage(
                "Method identifier content is not an I32".to_string(),
            ));
        };

        let method_name = mi_obj.to_string.clone().unwrap_or_default();

        // Extract optional method result (mr)
        let method_result = value
            .extended_properties
            .get("mr")
            .map(|prop| prop.value.clone());

        // Extract optional method exception (me)
        let method_exception = value
            .extended_properties
            .get("me")
            .map(|prop| prop.value.clone());

        Ok(PipelineHostResponse {
            call_id: *call_id,
            method_id: *method_id,
            method_name,
            method_result,
            method_exception,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ps_value::PsPrimitiveValue;

    #[test]
    fn test_pipeline_host_response_roundtrip() {
        let original = PipelineHostResponse::builder()
            .call_id(42)
            .method_id(11) // ReadLine method
            .method_name("ReadLine".to_string())
            .method_result(PsValue::Primitive(PsPrimitiveValue::Str(
                "Alice".to_string(),
            )))
            .build();

        let complex_obj = ComplexObject::from(original.clone());
        let restored = PipelineHostResponse::try_from(complex_obj).unwrap();

        assert_eq!(original, restored);
    }

    #[test]
    fn test_pipeline_host_response_with_exception() {
        let original = PipelineHostResponse::builder()
            .call_id(1)
            .method_id(20) // WriteProgress method
            .method_name("WriteProgress".to_string())
            .method_exception(PsValue::Primitive(PsPrimitiveValue::Str(
                "Test exception".to_string(),
            )))
            .build();

        let complex_obj = ComplexObject::from(original.clone());
        let restored = PipelineHostResponse::try_from(complex_obj).unwrap();

        assert_eq!(original, restored);
        assert!(restored.method_result.is_none());
        assert!(restored.method_exception.is_some());
    }

    #[test]
    fn test_pipeline_host_response_empty() {
        let original = PipelineHostResponse::builder()
            .call_id(1)
            .method_id(20) // WriteProgress method
            .method_name("WriteProgress".to_string())
            .build();

        let complex_obj = ComplexObject::from(original.clone());
        let restored = PipelineHostResponse::try_from(complex_obj).unwrap();

        assert_eq!(original, restored);
        assert!(restored.method_result.is_none());
        assert!(restored.method_exception.is_none());
    }

    #[test]
    fn test_pipeline_host_response_message_type() {
        let host_response = PipelineHostResponse::builder()
            .call_id(1)
            .method_id(11)
            .method_name("ReadLine".to_string())
            .build();

        assert_eq!(
            host_response.message_type(),
            MessageType::PipelineHostResponse
        );
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/pipeline_input.rs ---
use crate::ps_value::PsValue;

pub struct PipelineInput {
    pub data: PsValue,
}

impl PipelineInput {
    pub fn new(data: PsValue) -> Self {
        PipelineInput { data }
    }
}

// impl From<PipelineInput> for PsObject {
//     fn from(input: PipelineInput) -> Self {
//         PsObject {
//             ms: vec![PsProperty {
//                 name: Some("Data".to_string()),
//                 ref_id: None,
//                 value: input.data,
//             }],
//             ..Default::default()
//         }
//     }
// }


--- File: crates/protocol-powershell-remoting/src/messages/pipeline_output.rs ---
use std::fmt::Display;

use regex::Regex;

use super::PsValue;
use crate::{MessageType, PowerShellRemotingError, PowerShellRemotingMessage, PsObjectWithType};

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PipelineOutput {
    pub data: PsValue, // the actual output object (primitive or complex)
}

impl PipelineOutput {
    pub fn format_as_ps_string(&self) -> Result<String, PowerShellRemotingError> {
        let Some(output_str) = self.data.as_string() else {
            return Err(PowerShellRemotingError::OutputFormattingError(
                "Pipeline output is not a string",
            ));
        };

        decode_escaped_ps_string(&output_str)
    }
}

impl From<PsValue> for PipelineOutput {
    fn from(v: PsValue) -> Self {
        Self { data: v }
    }
}

impl PsObjectWithType for PipelineOutput {
    fn message_type(&self) -> MessageType {
        MessageType::PipelineOutput
    }

    // IMPORTANT: return the inner PsValue directly; no extra wrapper.
    fn to_ps_object(&self) -> PsValue {
        self.data.clone()
    }
}

impl Display for PipelineOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.data)
    }
}

impl TryFrom<&PowerShellRemotingMessage> for PipelineOutput {
    type Error = PowerShellRemotingError;

    fn try_from(msg: &PowerShellRemotingMessage) -> Result<Self, Self::Error> {
        if msg.message_type != MessageType::PipelineOutput {
            return Err(PowerShellRemotingError::InvalidMessage(
                "not a PipelineOutput message".into(),
            ));
        }
        Ok(PipelineOutput {
            data: msg.parse_ps_message()?,
        })
    }
}

fn decode_escaped_ps_string(input: &str) -> Result<String, PowerShellRemotingError> {
    if input.is_empty() {
        return Ok(String::new());
    }

    // Split with capturing parentheses to include the separator in the resulting array
    let regex = Regex::new(r"(_x[0-9A-F]{4}_)")
        .map_err(|_| PowerShellRemotingError::OutputFormattingError("Regex error"))?;
    let parts: Vec<&str> = regex.split(input).collect();

    if parts.len() <= 1 {
        return Ok(input.to_string());
    }

    let mut result = String::new();
    let mut high_surrogate: Option<u16> = None;

    // We need to manually handle the split parts and captures
    let mut current_pos = 0;
    for captures in regex.find_iter(input) {
        // Add the text before the match
        if captures.start() > current_pos {
            result.push_str(&input[current_pos..captures.start()]);
            high_surrogate = None;
        }

        // Process the escaped sequence
        let escaped = captures.as_str();
        if let Some(hex_str) = escaped.strip_prefix("_x").and_then(|s| s.strip_suffix("_")) {
            match u16::from_str_radix(hex_str, 16) {
                Ok(code_unit) => {
                    if let Some(high) = high_surrogate {
                        // We have a high surrogate from before, try to form a surrogate pair
                        if (0xDC00..=0xDFFF).contains(&code_unit) {
                            // This is a low surrogate, form the pair
                            let code_point = 0x10000
                                + ((high as u32 - 0xD800) << 10)
                                + (code_unit as u32 - 0xDC00);
                            if let Some(ch) = char::from_u32(code_point) {
                                result.push(ch);
                            } else {
                                // Invalid code point, add the escaped sequence as-is
                                result.push_str(escaped);
                            }
                            high_surrogate = None;
                        } else {
                            // Not a low surrogate, add the previous high surrogate as-is and process this one
                            result.push_str("_x");
                            result.push_str(&format!("{high:04X}"));
                            result.push('_');

                            if (0xD800..=0xDBFF).contains(&code_unit) {
                                high_surrogate = Some(code_unit);
                            } else {
                                if let Some(ch) = char::from_u32(code_unit as u32) {
                                    result.push(ch);
                                } else {
                                    result.push_str(escaped);
                                }
                                high_surrogate = None;
                            }
                        }
                    } else if (0xD800..=0xDBFF).contains(&code_unit) {
                        // High surrogate, save it for the next iteration
                        high_surrogate = Some(code_unit);
                    } else {
                        // Regular character or low surrogate without high surrogate
                        if let Some(ch) = char::from_u32(code_unit as u32) {
                            result.push(ch);
                        } else {
                            // Invalid character, add the escaped sequence as-is
                            result.push_str(escaped);
                        }
                        high_surrogate = None;
                    }
                }
                Err(_) => {
                    // Invalid hex, add the escaped sequence as-is
                    result.push_str(escaped);
                    high_surrogate = None;
                }
            }
        } else {
            // Not a valid escape sequence, add as-is
            result.push_str(escaped);
            high_surrogate = None;
        }

        current_pos = captures.end();
    }

    // Add any remaining text after the last match
    if current_pos < input.len() {
        result.push_str(&input[current_pos..]);
    }

    // If we have an unmatched high surrogate at the end, add it as-is
    if let Some(high) = high_surrogate {
        result.push_str("_x");
        result.push_str(&format!("{high:04X}"));
        result.push('_');
    }

    Ok(result)
}


--- File: crates/protocol-powershell-remoting/src/messages/pipeline_state.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, PsObjectWithType, PsPrimitiveValue, PsProperty, PsValue,
};
use std::collections::BTreeMap;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PSInvocationState {
    NotStarted = 0,
    Running = 1,
    Stopping = 2,
    Stopped = 3,
    Completed = 4,
    Failed = 5,
    Disconnected = 6,
}

impl PSInvocationState {
    pub fn as_i32(&self) -> i32 {
        match self {
            PSInvocationState::NotStarted => 0,
            PSInvocationState::Running => 1,
            PSInvocationState::Stopping => 2,
            PSInvocationState::Stopped => 3,
            PSInvocationState::Completed => 4,
            PSInvocationState::Failed => 5,
            PSInvocationState::Disconnected => 6,
        }
    }

    pub fn is_terminal(&self) -> bool {
        matches!(
            self,
            PSInvocationState::Completed | PSInvocationState::Failed | PSInvocationState::Stopped
        )
    }
}

impl TryFrom<i32> for PSInvocationState {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PSInvocationState::NotStarted),
            1 => Ok(PSInvocationState::Running),
            2 => Ok(PSInvocationState::Stopping),
            3 => Ok(PSInvocationState::Stopped),
            4 => Ok(PSInvocationState::Completed),
            5 => Ok(PSInvocationState::Failed),
            6 => Ok(PSInvocationState::Disconnected),
            _ => Err(crate::PowerShellRemotingError::InvalidMessage(format!(
                "Invalid PSInvocationState value: {value}"
            ))),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct PipelineStateMessage {
    pub pipeline_state: PSInvocationState,
    #[builder(default)]
    pub exception_as_error_record: Option<PsValue>,
}

impl PsObjectWithType for PipelineStateMessage {
    fn message_type(&self) -> MessageType {
        MessageType::PipelineState
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<PipelineStateMessage> for ComplexObject {
    fn from(state: PipelineStateMessage) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "PipelineState".to_string(),
            PsProperty {
                name: "PipelineState".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(state.pipeline_state.as_i32())),
            },
        );

        if let Some(exception) = state.exception_as_error_record {
            extended_properties.insert(
                "ExceptionAsErrorRecord".to_string(),
                PsProperty {
                    name: "ExceptionAsErrorRecord".to_string(),
                    value: exception,
                },
            );
        }

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for PipelineStateMessage {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let pipeline_state_prop =
            value
                .extended_properties
                .get("PipelineState")
                .ok_or_else(|| {
                    Self::Error::InvalidMessage("Missing PipelineState property".to_string())
                })?;

        let pipeline_state = match &pipeline_state_prop.value {
            PsValue::Primitive(PsPrimitiveValue::I32(state)) => {
                PSInvocationState::try_from(*state)?
            }
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "PipelineState property is not an I32".to_string(),
                ));
            }
        };

        let exception_as_error_record = value
            .extended_properties
            .get("ExceptionAsErrorRecord")
            .map(|prop| prop.value.clone());

        Ok(PipelineStateMessage {
            pipeline_state,
            exception_as_error_record,
        })
    }
}

impl PipelineStateMessage {
    pub fn completed() -> Self {
        Self::builder()
            .pipeline_state(PSInvocationState::Completed)
            .build()
    }

    pub fn failed_with_error(error_record: PsValue) -> Self {
        Self::builder()
            .pipeline_state(PSInvocationState::Failed)
            .exception_as_error_record(Some(error_record))
            .build()
    }

    pub fn stopped_with_error(error_record: PsValue) -> Self {
        Self::builder()
            .pipeline_state(PSInvocationState::Stopped)
            .exception_as_error_record(Some(error_record))
            .build()
    }

    pub fn running() -> Self {
        Self::builder()
            .pipeline_state(PSInvocationState::Running)
            .build()
    }

    pub fn is_terminal(&self) -> bool {
        self.pipeline_state.is_terminal()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pipeline_state_completed() {
        let state = PipelineStateMessage::completed();

        let complex_obj = ComplexObject::from(state.clone());
        let roundtrip = PipelineStateMessage::try_from(complex_obj).unwrap();

        assert_eq!(state, roundtrip);
        assert!(state.is_terminal());
    }

    #[test]
    fn test_pipeline_state_failed_with_error() {
        let error_record = PsValue::Primitive(PsPrimitiveValue::Str("Test error".to_string()));
        let state = PipelineStateMessage::failed_with_error(error_record.clone());

        let complex_obj = ComplexObject::from(state.clone());
        let roundtrip = PipelineStateMessage::try_from(complex_obj).unwrap();

        assert_eq!(state, roundtrip);
        assert!(state.is_terminal());
        assert_eq!(state.pipeline_state, PSInvocationState::Failed);
        assert_eq!(state.exception_as_error_record, Some(error_record));
    }

    #[test]
    fn test_pipeline_state_running() {
        let state = PipelineStateMessage::running();

        let complex_obj = ComplexObject::from(state.clone());
        let roundtrip = PipelineStateMessage::try_from(complex_obj).unwrap();

        assert_eq!(state, roundtrip);
        assert!(!state.is_terminal());
        assert_eq!(state.pipeline_state, PSInvocationState::Running);
    }

    #[test]
    fn test_pipeline_state_stopped_with_error() {
        let error_record = PsValue::Primitive(PsPrimitiveValue::Str("Stopped by user".to_string()));
        let state = PipelineStateMessage::stopped_with_error(error_record.clone());

        assert_eq!(state.pipeline_state, PSInvocationState::Stopped);
        assert!(state.is_terminal());
        assert_eq!(state.exception_as_error_record, Some(error_record));
    }

    #[test]
    fn test_message_type() {
        let state = PipelineStateMessage::completed();
        assert_eq!(state.message_type().value(), 0x00041006);
    }

    #[test]
    fn test_ps_invocation_state_values() {
        assert_eq!(PSInvocationState::NotStarted.as_i32(), 0);
        assert_eq!(PSInvocationState::Running.as_i32(), 1);
        assert_eq!(PSInvocationState::Stopping.as_i32(), 2);
        assert_eq!(PSInvocationState::Stopped.as_i32(), 3);
        assert_eq!(PSInvocationState::Completed.as_i32(), 4);
        assert_eq!(PSInvocationState::Failed.as_i32(), 5);
        assert_eq!(PSInvocationState::Disconnected.as_i32(), 6);
    }

    #[test]
    fn test_ps_invocation_state_try_from() {
        assert_eq!(
            PSInvocationState::try_from(0).unwrap(),
            PSInvocationState::NotStarted
        );
        assert_eq!(
            PSInvocationState::try_from(1).unwrap(),
            PSInvocationState::Running
        );
        assert_eq!(
            PSInvocationState::try_from(2).unwrap(),
            PSInvocationState::Stopping
        );
        assert_eq!(
            PSInvocationState::try_from(3).unwrap(),
            PSInvocationState::Stopped
        );
        assert_eq!(
            PSInvocationState::try_from(4).unwrap(),
            PSInvocationState::Completed
        );
        assert_eq!(
            PSInvocationState::try_from(5).unwrap(),
            PSInvocationState::Failed
        );
        assert_eq!(
            PSInvocationState::try_from(6).unwrap(),
            PSInvocationState::Disconnected
        );

        assert!(PSInvocationState::try_from(7).is_err());
        assert!(PSInvocationState::try_from(-1).is_err());
    }

    #[test]
    fn test_terminal_states() {
        assert!(!PSInvocationState::NotStarted.is_terminal());
        assert!(!PSInvocationState::Running.is_terminal());
        assert!(!PSInvocationState::Stopping.is_terminal());
        assert!(PSInvocationState::Stopped.is_terminal());
        assert!(PSInvocationState::Completed.is_terminal());
        assert!(PSInvocationState::Failed.is_terminal());
        assert!(!PSInvocationState::Disconnected.is_terminal());
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/progress_record.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, PsObjectWithType, PsPrimitiveValue, PsProperty, PsType,
    PsValue,
};
use std::{borrow::Cow, collections::BTreeMap};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ProgressRecordType {
    Processing = 0,
    Completed = 1,
}

impl ProgressRecordType {
    pub fn as_i32(&self) -> i32 {
        match self {
            ProgressRecordType::Processing => 0,
            ProgressRecordType::Completed => 1,
        }
    }

    pub fn as_string(&self) -> &'static str {
        match self {
            ProgressRecordType::Processing => "Processing",
            ProgressRecordType::Completed => "Completed",
        }
    }
}

impl TryFrom<i32> for ProgressRecordType {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(ProgressRecordType::Processing),
            1 => Ok(ProgressRecordType::Completed),
            _ => Err(crate::PowerShellRemotingError::InvalidMessage(format!(
                "Invalid ProgressRecordType value: {value}"
            ))),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct ProgressRecord {
    pub activity: String,
    pub activity_id: i32,
    #[builder(default)]
    pub status_description: Option<String>,
    #[builder(default)]
    pub current_operation: Option<String>,
    #[builder(default, setter(transform = |x: Option<i32>| x.filter(|&v| v >= 0)))]
    pub parent_activity_id: Option<i32>,
    #[builder(default, setter(transform = |x: i32| if (-1..=100).contains(&x) { x } else { -1 }))]
    pub percent_complete: i32,
    #[builder(default = ProgressRecordType::Processing)]
    pub progress_type: ProgressRecordType,
    #[builder(default)]
    pub seconds_remaining: Option<i32>,
}

impl PsObjectWithType for ProgressRecord {
    fn message_type(&self) -> MessageType {
        MessageType::ProgressRecord
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<ProgressRecord> for ComplexObject {
    fn from(record: ProgressRecord) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "Activity".to_string(),
            PsProperty {
                name: "Activity".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Str(record.activity)),
            },
        );

        extended_properties.insert(
            "ActivityId".to_string(),
            PsProperty {
                name: "ActivityId".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(record.activity_id)),
            },
        );

        if let Some(status) = record.status_description {
            extended_properties.insert(
                "StatusDescription".to_string(),
                PsProperty {
                    name: "StatusDescription".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::Str(status)),
                },
            );
        }

        if let Some(current_op) = record.current_operation {
            extended_properties.insert(
                "CurrentOperation".to_string(),
                PsProperty {
                    name: "CurrentOperation".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::Str(current_op)),
                },
            );
        }

        if let Some(parent_id) = record.parent_activity_id {
            extended_properties.insert(
                "ParentActivityId".to_string(),
                PsProperty {
                    name: "ParentActivityId".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::I32(parent_id)),
                },
            );
        }

        extended_properties.insert(
            "PercentComplete".to_string(),
            PsProperty {
                name: "PercentComplete".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(record.percent_complete)),
            },
        );

        let progress_type_obj = ComplexObject {
            type_def: Some(PsType {
                type_names: vec![
                    Cow::Borrowed("System.Management.Automation.ProgressRecordType"),
                    Cow::Borrowed("System.Enum"),
                    Cow::Borrowed("System.ValueType"),
                    Cow::Borrowed("System.Object"),
                ],
            }),
            to_string: Some(record.progress_type.as_string().to_string()),
            content: ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(
                record.progress_type.as_i32(),
            )),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        extended_properties.insert(
            "Type".to_string(),
            PsProperty {
                name: "Type".to_string(),
                value: PsValue::Object(progress_type_obj),
            },
        );

        if let Some(seconds) = record.seconds_remaining {
            extended_properties.insert(
                "SecondsRemaining".to_string(),
                PsProperty {
                    name: "SecondsRemaining".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::I32(seconds)),
                },
            );
        }

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for ProgressRecord {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let activity = value
            .extended_properties
            .get("Activity")
            .ok_or_else(|| Self::Error::InvalidMessage("Missing Activity property".to_string()))?;
        let activity = match &activity.value {
            PsValue::Primitive(PsPrimitiveValue::Str(s)) => s.clone(),
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "Activity property is not a string".to_string(),
                ));
            }
        };

        let activity_id = value.extended_properties.get("ActivityId").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing ActivityId property".to_string())
        })?;
        let activity_id = match &activity_id.value {
            PsValue::Primitive(PsPrimitiveValue::I32(id)) => *id,
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "ActivityId property is not an I32".to_string(),
                ));
            }
        };

        let status_description =
            value
                .extended_properties
                .get("StatusDescription")
                .and_then(|prop| match &prop.value {
                    PsValue::Primitive(PsPrimitiveValue::Str(s)) => Some(s.clone()),
                    _ => None,
                });

        let current_operation =
            value
                .extended_properties
                .get("CurrentOperation")
                .and_then(|prop| match &prop.value {
                    PsValue::Primitive(PsPrimitiveValue::Str(s)) => Some(s.clone()),
                    _ => None,
                });

        let parent_activity_id =
            value
                .extended_properties
                .get("ParentActivityId")
                .and_then(|prop| match &prop.value {
                    PsValue::Primitive(PsPrimitiveValue::I32(id)) if *id >= 0 => Some(*id),
                    _ => None,
                });

        let percent_complete = value
            .extended_properties
            .get("PercentComplete")
            .map(|prop| match &prop.value {
                PsValue::Primitive(PsPrimitiveValue::I32(percent)) => *percent,
                _ => -1,
            })
            .unwrap_or(-1);

        let progress_type = value
            .extended_properties
            .get("Type")
            .and_then(|prop| match &prop.value {
                PsValue::Object(obj) => match &obj.content {
                    ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(val)) => {
                        ProgressRecordType::try_from(*val).ok()
                    }
                    _ => None,
                },
                _ => None,
            })
            .unwrap_or(ProgressRecordType::Processing);

        let seconds_remaining =
            value
                .extended_properties
                .get("SecondsRemaining")
                .and_then(|prop| match &prop.value {
                    PsValue::Primitive(PsPrimitiveValue::I32(seconds)) => Some(*seconds),
                    _ => None,
                });

        Ok(ProgressRecord::builder()
            .activity(activity)
            .activity_id(activity_id)
            .status_description(status_description)
            .current_operation(current_operation)
            .parent_activity_id(parent_activity_id)
            .percent_complete(percent_complete)
            .progress_type(progress_type)
            .seconds_remaining(seconds_remaining)
            .build())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_progress_record_basic() {
        let record = ProgressRecord::builder()
            .activity("Activity Name".to_string())
            .activity_id(4)
            .status_description(Some("Good".to_string()))
            .current_operation(Some("Downloading file.txt".to_string()))
            .parent_activity_id(Some(-1)) // Will be filtered out by builder transform
            .percent_complete(20)
            .progress_type(ProgressRecordType::Processing)
            .seconds_remaining(Some(30))
            .build();

        let complex_obj = ComplexObject::from(record.clone());
        let roundtrip = ProgressRecord::try_from(complex_obj).unwrap();

        // Parent activity ID should be None due to builder transform filtering negative values
        let expected = ProgressRecord::builder()
            .activity("Activity Name".to_string())
            .activity_id(4)
            .status_description(Some("Good".to_string()))
            .current_operation(Some("Downloading file.txt".to_string()))
            .parent_activity_id(None)
            .percent_complete(20)
            .progress_type(ProgressRecordType::Processing)
            .seconds_remaining(Some(30))
            .build();

        assert_eq!(expected, roundtrip);
    }

    #[test]
    fn test_progress_record_completed() {
        let record = ProgressRecord::builder()
            .activity("Completed Task".to_string())
            .activity_id(1)
            .percent_complete(100)
            .progress_type(ProgressRecordType::Completed)
            .build();

        let complex_obj = ComplexObject::from(record.clone());
        let roundtrip = ProgressRecord::try_from(complex_obj).unwrap();

        assert_eq!(record, roundtrip);
    }

    #[test]
    fn test_message_type() {
        let record = ProgressRecord::builder()
            .activity("Test".to_string())
            .activity_id(0)
            .build();

        assert_eq!(record.message_type().value(), 0x00041010);
    }

    #[test]
    fn test_percent_complete_bounds() {
        // Test valid range
        let record = ProgressRecord::builder()
            .activity("Test".to_string())
            .activity_id(0)
            .percent_complete(50)
            .build();
        assert_eq!(record.percent_complete, 50);

        // Test out of range gets clamped to -1 by builder
        let record = ProgressRecord::builder()
            .activity("Test".to_string())
            .activity_id(0)
            .percent_complete(150) // Will be transformed to -1
            .build();
        assert_eq!(record.percent_complete, -1);
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/runspace_pool_host_call.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, Container, PsObjectWithType, PsPrimitiveValue, PsProperty,
    PsType, PsValue,
};
use std::collections::BTreeMap;

/// RunspacePoolHostCall is a message sent from the server to the client to perform
/// a method call on the host associated with the RunspacePool on the server.
///
/// MessageType value: 0x00021100
/// Direction: Server to Client
/// Target: RunspacePool
///
/// The message contains:
/// - Call ID (ci): A signed long integer to associate with the response
/// - Host method identifier (mi): Identifies the specific host method to execute
/// - Parameters for the method (mp): Arguments required for the host method call
#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct RunspacePoolHostCall {
    /// Unique identifier for this host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Parameters for the method call as a list of values
    #[builder(default)]
    pub parameters: Vec<PsValue>,
}

impl PsObjectWithType for RunspacePoolHostCall {
    fn message_type(&self) -> MessageType {
        MessageType::RunspacepoolHostCall
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<RunspacePoolHostCall> for ComplexObject {
    fn from(host_call: RunspacePoolHostCall) -> Self {
        let mut extended_properties = BTreeMap::new();

        // Call ID (ci)
        extended_properties.insert(
            "ci".to_string(),
            PsProperty {
                name: "ci".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I64(host_call.call_id)),
            },
        );

        // Host method identifier (mi)
        let method_id_obj = ComplexObject {
            type_def: Some(PsType::remote_host_method_id()),
            to_string: Some(host_call.method_name),
            content: ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(
                host_call.method_id,
            )),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        extended_properties.insert(
            "mi".to_string(),
            PsProperty {
                name: "mi".to_string(),
                value: PsValue::Object(method_id_obj),
            },
        );

        // Method parameters (mp) as ArrayList
        let parameters_obj = ComplexObject {
            type_def: Some(PsType::array_list()),
            to_string: None,
            content: ComplexObjectContent::Container(Container::List(host_call.parameters)),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        extended_properties.insert(
            "mp".to_string(),
            PsProperty {
                name: "mp".to_string(),
                value: PsValue::Object(parameters_obj),
            },
        );

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for RunspacePoolHostCall {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        // Extract call_id (ci)
        let ci_property = value.extended_properties.get("ci").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing call ID (ci) property".to_string())
        })?;

        let PsValue::Primitive(PsPrimitiveValue::I64(call_id)) = &ci_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Call ID (ci) is not a signed long integer".to_string(),
            ));
        };

        // Extract method identifier (mi)
        let mi_property = value.extended_properties.get("mi").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing method identifier (mi) property".to_string())
        })?;

        let PsValue::Object(mi_obj) = &mi_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Method identifier (mi) is not an object".to_string(),
            ));
        };

        let ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(method_id)) =
            &mi_obj.content
        else {
            return Err(Self::Error::InvalidMessage(
                "Method identifier content is not an I32".to_string(),
            ));
        };

        let method_name = mi_obj.to_string.clone().unwrap_or_default();

        // Extract method parameters (mp)
        let mp_property = value.extended_properties.get("mp").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing method parameters (mp) property".to_string())
        })?;

        let PsValue::Object(mp_obj) = &mp_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Method parameters (mp) is not an object".to_string(),
            ));
        };

        let parameters =
            if let ComplexObjectContent::Container(Container::List(params)) = &mp_obj.content {
                params.clone()
            } else {
                // Empty list case
                Vec::new()
            };

        Ok(RunspacePoolHostCall {
            call_id: *call_id,
            method_id: *method_id,
            method_name,
            parameters,
        })
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/runspace_pool_host_response.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, PsObjectWithType, PsPrimitiveValue, PsProperty, PsType,
    PsValue,
};
use std::collections::BTreeMap;

/// RunspacePoolHostResponse is a message sent from the client to the server as a response
/// from a host call executed on the client RunspacePool's host.
///
/// MessageType value: 0x00021101
/// Direction: Client to Server
/// Target: RunspacePool
///
/// The message contains:
/// - Call ID (ci): Must match the corresponding RUNSPACEPOOL_HOST_CALL message
/// - Host method identifier (mi): Identifies the host method from which the response originates
/// - Return value of the method (mr): Optional return value from the host method
/// - Exception thrown by a host method invocation (me): Optional error information
#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct RunspacePoolHostResponse {
    /// Call ID that matches the corresponding host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Optional return value from the method
    #[builder(default, setter(strip_option(fallback_suffix = "_opt")))]
    pub method_result: Option<PsValue>,
    /// Optional exception thrown by the method invocation
    #[builder(default, setter(strip_option(fallback_suffix = "_opt")))]
    pub method_exception: Option<PsValue>,
}

impl PsObjectWithType for RunspacePoolHostResponse {
    fn message_type(&self) -> MessageType {
        MessageType::RunspacepoolHostResponse
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<RunspacePoolHostResponse> for ComplexObject {
    fn from(host_response: RunspacePoolHostResponse) -> Self {
        let mut extended_properties = BTreeMap::new();

        // Call ID (ci)
        extended_properties.insert(
            "ci".to_string(),
            PsProperty {
                name: "ci".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I64(host_response.call_id)),
            },
        );

        // Host method identifier (mi)
        let method_id_obj = ComplexObject {
            type_def: Some(PsType::remote_host_method_id()),
            to_string: Some(host_response.method_name),
            content: ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(
                host_response.method_id,
            )),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        extended_properties.insert(
            "mi".to_string(),
            PsProperty {
                name: "mi".to_string(),
                value: PsValue::Object(method_id_obj),
            },
        );

        // Method result (mr) - optional
        if let Some(result) = host_response.method_result {
            extended_properties.insert(
                "mr".to_string(),
                PsProperty {
                    name: "mr".to_string(),
                    value: result,
                },
            );
        }

        // Method exception (me) - optional
        if let Some(exception) = host_response.method_exception {
            extended_properties.insert(
                "me".to_string(),
                PsProperty {
                    name: "me".to_string(),
                    value: exception,
                },
            );
        }

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for RunspacePoolHostResponse {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        // Extract call_id (ci)
        let ci_property = value.extended_properties.get("ci").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing call ID (ci) property".to_string())
        })?;

        let PsValue::Primitive(PsPrimitiveValue::I64(call_id)) = &ci_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Call ID (ci) is not a signed long integer".to_string(),
            ));
        };

        // Extract method identifier (mi)
        let mi_property = value.extended_properties.get("mi").ok_or_else(|| {
            Self::Error::InvalidMessage("Missing method identifier (mi) property".to_string())
        })?;

        let PsValue::Object(mi_obj) = &mi_property.value else {
            return Err(Self::Error::InvalidMessage(
                "Method identifier (mi) is not an object".to_string(),
            ));
        };

        let ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(method_id)) =
            &mi_obj.content
        else {
            return Err(Self::Error::InvalidMessage(
                "Method identifier content is not an I32".to_string(),
            ));
        };

        let method_name = mi_obj.to_string.clone().unwrap_or_default();

        // Extract optional method result (mr)
        let method_result = value
            .extended_properties
            .get("mr")
            .map(|prop| prop.value.clone());

        // Extract optional method exception (me)
        let method_exception = value
            .extended_properties
            .get("me")
            .map(|prop| prop.value.clone());

        Ok(RunspacePoolHostResponse {
            call_id: *call_id,
            method_id: *method_id,
            method_name,
            method_result,
            method_exception,
        })
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/runspace_pool_state.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, PsObjectWithType, PsPrimitiveValue, PsProperty, PsValue,
};
use std::collections::BTreeMap;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RunspacePoolStateValue {
    BeforeOpen = 0,
    Opening = 1,
    Opened = 2,
    Closed = 3,
    Closing = 4,
    Broken = 5,
    NegotiationSent = 6,
    NegotiationSucceeded = 7,
    Connecting = 8,
    Disconnected = 9,
}

impl RunspacePoolStateValue {
    pub fn as_i32(&self) -> i32 {
        match self {
            RunspacePoolStateValue::BeforeOpen => 0,
            RunspacePoolStateValue::Opening => 1,
            RunspacePoolStateValue::Opened => 2,
            RunspacePoolStateValue::Closed => 3,
            RunspacePoolStateValue::Closing => 4,
            RunspacePoolStateValue::Broken => 5,
            RunspacePoolStateValue::NegotiationSent => 6,
            RunspacePoolStateValue::NegotiationSucceeded => 7,
            RunspacePoolStateValue::Connecting => 8,
            RunspacePoolStateValue::Disconnected => 9,
        }
    }
}

impl TryFrom<i32> for RunspacePoolStateValue {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(RunspacePoolStateValue::BeforeOpen),
            1 => Ok(RunspacePoolStateValue::Opening),
            2 => Ok(RunspacePoolStateValue::Opened),
            3 => Ok(RunspacePoolStateValue::Closed),
            4 => Ok(RunspacePoolStateValue::Closing),
            5 => Ok(RunspacePoolStateValue::Broken),
            6 => Ok(RunspacePoolStateValue::NegotiationSent),
            7 => Ok(RunspacePoolStateValue::NegotiationSucceeded),
            8 => Ok(RunspacePoolStateValue::Connecting),
            9 => Ok(RunspacePoolStateValue::Disconnected),
            _ => Err(crate::PowerShellRemotingError::InvalidMessage(format!(
                "Invalid RunspacePoolState value: {value}"
            ))),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, typed_builder::TypedBuilder)]
pub struct RunspacePoolStateMessage {
    pub runspace_state: RunspacePoolStateValue,
    #[builder(default)]
    pub exception_as_error_record: Option<PsValue>,
}

impl PsObjectWithType for RunspacePoolStateMessage {
    fn message_type(&self) -> MessageType {
        MessageType::RunspacepoolState
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

impl From<RunspacePoolStateMessage> for ComplexObject {
    fn from(state: RunspacePoolStateMessage) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "RunspaceState".to_string(),
            PsProperty {
                name: "RunspaceState".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::I32(state.runspace_state.as_i32())),
            },
        );

        if let Some(exception) = state.exception_as_error_record {
            extended_properties.insert(
                "ExceptionAsErrorRecord".to_string(),
                PsProperty {
                    name: "ExceptionAsErrorRecord".to_string(),
                    value: exception,
                },
            );
        }

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for RunspacePoolStateMessage {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let runspace_state_prop =
            value
                .extended_properties
                .get("RunspaceState")
                .ok_or_else(|| {
                    Self::Error::InvalidMessage("Missing RunspaceState property".to_string())
                })?;

        let runspace_state = match &runspace_state_prop.value {
            PsValue::Primitive(PsPrimitiveValue::I32(state)) => {
                RunspacePoolStateValue::try_from(*state)?
            }
            _ => {
                return Err(Self::Error::InvalidMessage(
                    "RunspaceState property is not an I32".to_string(),
                ));
            }
        };

        let exception_as_error_record = value
            .extended_properties
            .get("ExceptionAsErrorRecord")
            .map(|prop| prop.value.clone());

        Ok(RunspacePoolStateMessage {
            runspace_state,
            exception_as_error_record,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_runspace_pool_state_opened() {
        let state = RunspacePoolStateMessage::builder()
            .runspace_state(RunspacePoolStateValue::Opened)
            .build();

        let complex_obj = ComplexObject::from(state.clone());
        let roundtrip = RunspacePoolStateMessage::try_from(complex_obj).unwrap();

        assert_eq!(state, roundtrip);
    }

    #[test]
    fn test_runspace_pool_state_broken_with_exception() {
        let exception = PsValue::Primitive(PsPrimitiveValue::Str("Test error".to_string()));
        let state = RunspacePoolStateMessage::builder()
            .runspace_state(RunspacePoolStateValue::Broken)
            .exception_as_error_record(Some(exception.clone()))
            .build();

        let complex_obj = ComplexObject::from(state.clone());
        let roundtrip = RunspacePoolStateMessage::try_from(complex_obj).unwrap();

        assert_eq!(state, roundtrip);
    }

    #[test]
    fn test_message_type() {
        let state = RunspacePoolStateMessage::builder()
            .runspace_state(RunspacePoolStateValue::Opened)
            .build();

        assert_eq!(state.message_type().value(), 0x00021005);
    }
}


--- File: crates/protocol-powershell-remoting/src/messages/session_capability.rs ---
use crate::MessageType;
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, PsObjectWithType, PsPrimitiveValue, PsProperty, PsValue,
};
use std::collections::BTreeMap;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SessionCapability {
    pub protocol_version: String,
    pub ps_version: String,
    pub serialization_version: String,
    pub time_zone: Option<String>,
}

impl PsObjectWithType for SessionCapability {
    fn message_type(&self) -> MessageType {
        MessageType::SessionCapability
    }

    fn to_ps_object(&self) -> PsValue {
        PsValue::Object(ComplexObject::from(self.clone()))
    }
}

// <Obj RefId="0">
//    <MS>
//      <Version N="protocolversion">2.2</Version>
//      <Version N="PSVersion">2.0</Version>
//      <Version N="SerializationVersion">1.1.0.1</Version>
//      <BA N="TimeZone">AAEAAAD/////AQAAAAAAAAAEAQAAABxTeXN0ZW0uQ3VycmVudFN5c3RlbVRpbWVab25lBAAAABdtX0NhY2hlZERheWxpZ2h0Q2hhbmdlcw1tX3RpY2tzT2Zmc2V0Dm1fc3RhbmRhcmROYW1lDm1fZGF5bGlnaHROYW1lAwABARxTeXN0ZW0uQ29sbGVjdGlvbnMuSGFzaHRhYmxlCQkCAAAAAMDc8bz///8KCgQCAAAAHFN5c3RlbS5Db2xsZWN0aW9ucy5IYXNodGFibGUHAAAACkxvYWRGYWN0b3IHVmVyc2lvbghDb21wYXJlchBIYXNoQ29kZVByb3ZpZGVyCEhhc2hTaXplBEtleXMGVmFsdWVzAAADAwAFBQsIHFN5c3RlbS5Db2xsZWN0aW9ucy5JQ29tcGFyZXIkU3lzdGVtLkNvbGxlY3Rpb25zLklIYXNoQ29kZVByb3ZpZGVyCOxROD8BAAAACgoLAAAACQMAAAAJBAAAABADAAAAAQAAAAgI2QcAABAEAAAAAQAAAAkFAAAABAUAAAAhU3lzdGVtLkdsb2JhbGl6YXRpb24uRGF5bGlnaHRUaW1lAwAAAAdtX3N0YXJ0BW1fZW5kB21fZGVsdGEAAAANDQwAkOq4qG3LiAAQOyeuKMyIAGjEYQgAAAAL</BA>
//    </MS>
//  </Obj>

impl From<SessionCapability> for ComplexObject {
    fn from(cap: SessionCapability) -> Self {
        let mut extended_properties = BTreeMap::new();

        extended_properties.insert(
            "protocolversion".to_string(),
            PsProperty {
                name: "protocolversion".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Version(cap.protocol_version)),
            },
        );

        extended_properties.insert(
            "PSVersion".to_string(),
            PsProperty {
                name: "PSVersion".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Version(cap.ps_version)),
            },
        );

        extended_properties.insert(
            "SerializationVersion".to_string(),
            PsProperty {
                name: "SerializationVersion".to_string(),
                value: PsValue::Primitive(PsPrimitiveValue::Version(cap.serialization_version)),
            },
        );

        if let Some(time_zone) = cap.time_zone {
            extended_properties.insert(
                "TimeZone".to_string(),
                PsProperty {
                    name: "TimeZone".to_string(),
                    value: PsValue::Primitive(PsPrimitiveValue::Bytes(time_zone.into_bytes())),
                },
            );
        }

        ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties,
        }
    }
}

impl TryFrom<ComplexObject> for SessionCapability {
    type Error = crate::PowerShellRemotingError;

    fn try_from(value: ComplexObject) -> Result<Self, Self::Error> {
        let get_version_property = |name: &str| -> Result<String, Self::Error> {
            let property = value
                .extended_properties
                .get(name)
                .ok_or_else(|| Self::Error::InvalidMessage(format!("Missing property: {name}")))?;

            match &property.value {
                PsValue::Primitive(PsPrimitiveValue::Version(version)) => Ok(version.clone()),
                _ => Err(Self::Error::InvalidMessage(format!(
                    "Property '{name}' is not a Version"
                ))),
            }
        };

        let protocol_version = get_version_property("protocolversion")?;
        let ps_version = get_version_property("PSVersion")?;
        let serialization_version = get_version_property("SerializationVersion")?;

        let time_zone =
            value
                .extended_properties
                .get("TimeZone")
                .and_then(|prop| match &prop.value {
                    PsValue::Primitive(PsPrimitiveValue::Bytes(bytes)) => {
                        Some(String::from_utf8_lossy(bytes).to_string())
                    }
                    _ => None,
                });

        Ok(SessionCapability {
            protocol_version,
            ps_version,
            serialization_version,
            time_zone,
        })
    }
}


--- File: crates/protocol-powershell-remoting/src/ps_value/complex.rs ---
use std::{collections::BTreeMap, fmt::Display};

use super::{Container, PsEnums, PsPrimitiveValue, PsProperty, PsType};

/*
https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/3e107e78-3f28-4f85-9e25-493fd9b09726
The <Obj> element can include the following subelements in any order.
    Type names (section 2.2.5.2.3).
    ToString (section 2.2.5.2.4).
    Element generated by one of the following:
        Value of a primitive type (when the Complex Object is an Extended Primitive Object) (section 2.2.5.2.5).
        Contents of known containers (section 2.2.5.2.6).
        Contents of enums (section 2.2.5.2.7).
    Adapted Properties (section 2.2.5.2.8).
    Extended properties (section 2.2.5.2.9).

*/
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct ComplexObject {
    pub type_def: Option<PsType>,
    pub to_string: Option<String>,
    pub content: ComplexObjectContent,
    pub adapted_properties: BTreeMap<String, PsProperty>,
    pub extended_properties: BTreeMap<String, PsProperty>,
}

impl Display for ComplexObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(to_string) = &self.to_string {
            // For some types, the ToString is enough. But for others, like FileSystemInfo,
            // it's not. We will have a special formatting for well-known types.
            if let Some(type_def) = &self.type_def {
                if type_def
                    .type_names
                    .iter()
                    .any(|t| t.as_ref() == "System.IO.FileSystemInfo")
                {
                    // This is a FileSystemInfo object, let's format it better.
                } else {
                    return write!(f, "{to_string}");
                }
            } else {
                return write!(f, "{to_string}");
            }
        }

        // Fallback to a property-based representation
        writeln!(f, "@{{")?;
        for prop in self.adapted_properties.values() {
            writeln!(f, "  {} = {}", prop.name, prop.value)?;
        }
        for prop in self.extended_properties.values() {
            writeln!(f, "  {} = {}", prop.name, prop.value)?;
        }
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub enum ComplexObjectContent {
    /// If the Complex Object being serialized is an Extended Primitive Object, then the value of the primitive type is serialized as described in section 2.2.5.1.
    ///Example (compare with the serialization of a string without notes in section 2.2.5.1.1):
    ///
    ///     <Obj RefId="RefId-0">
    ///       <S>This is a string</S>
    ///       <MS>
    ///         <S N="Note1">My note</S>
    ///       </MS>
    ///     </Obj>
    ExtendedPrimitive(PsPrimitiveValue),
    Container(Container),
    PsEnums(PsEnums),
    #[default]
    Standard,
}

impl Display for ComplexObjectContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ComplexObjectContent::ExtendedPrimitive(p) => p.fmt(f),
            ComplexObjectContent::Container(c) => c.fmt(f),
            ComplexObjectContent::PsEnums(e) => e.fmt(f),
            ComplexObjectContent::Standard => write!(f, "System.Object"), // Fallback
        }
    }
}


--- File: crates/protocol-powershell-remoting/src/ps_value/container.rs ---
use std::{collections::BTreeMap, fmt::Display};

use super::PsValue;

#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum Container {
    ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/e9cf648e-38fe-42ba-9ca3-d89a9e0a856a
    Stack(Vec<PsValue>),
    ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/ade9f023-ac30-4b7e-be17-900c02a6f837
    Queue(Vec<PsValue>),
    ///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/f4bdb166-cefc-4d49-848c-7d08680ae0a7
    List(Vec<PsValue>),
    /// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/c4e000a2-21d8-46c0-a71b-0051365d8273
    Dictionary(BTreeMap<PsValue, PsValue>),
}

impl Display for Container {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Container::Stack(_) => write!(f, "System.Collections.Stack"),
            Container::Queue(_) => write!(f, "System.Collections.Queue"),
            Container::List(items) => {
                let s: Vec<String> = items.iter().map(|v| v.to_string()).collect();
                write!(f, "{}", s.join(" "))
            }
            Container::Dictionary(_) => write!(f, "System.Collections.Hashtable"),
        }
    }
}

/// Enums specify a value of an enumeration. An enumeration is a distinct type consisting of a set of named constants. Every enumeration type has an underlying type, which can be any integral type. The default underlying type of the enumeration elements is a 32-bit integer (see section 2.2.5.1.11). Enums never have adapted properties (see section 2.2.5.3.4.1).
/// XML Element: element corresponding to the primitive integer type (see section 2.2.5.1) that is underlying the enumeration type.
/// XML Contents: value of the enumeration converted to the underlying type.
///
/// Example:
///
///      <Obj RefId="0">
///        <TN RefId="0">
///          <T>System.ConsoleColor</T>
///          <T>System.Enum</T>
///          <T>System.ValueType</T>
///          <T>System.Object</T>
///        </TN>
///        <ToString>Blue</ToString>
///        <I32>9</I32>
///      </Obj>
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PsEnums {
    pub value: i32,
}

impl Display for PsEnums {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // The to_string of the ComplexObject holding this enum should be used.
        // This is a fallback.
        write!(f, "{}", self.value)
    }
}


--- File: crates/protocol-powershell-remoting/src/ps_value/deserialize.rs ---
use super::{
    ComplexObject, ComplexObjectContent, Container, PsEnums, PsPrimitiveValue, PsProperty, PsType,
    PsValue,
};
use base64::Engine;
use base64::engine::general_purpose::STANDARD as B64;
use std::borrow::Cow;
use std::collections::{BTreeMap, HashMap};
use tracing::trace;
use xml::parser::{XmlDeserialize, XmlVisitor};

type Result<T> = std::result::Result<T, xml::XmlError>;

/// ================================================================================================
/// PsPrimitiveValue Visitor and XmlDeserialize Implementation
/// (Kept for backwards compatibility - primitives don't need context)
/// ================================================================================================
pub struct PsPrimitiveValueVisitor<'a> {
    value: Option<PsPrimitiveValue>,
    _phantom: std::marker::PhantomData<&'a ()>,
}

impl<'a> Default for PsPrimitiveValueVisitor<'a> {
    fn default() -> Self {
        Self::new()
    }
}

impl<'a> PsPrimitiveValueVisitor<'a> {
    pub fn new() -> Self {
        Self {
            value: None,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<'a> XmlVisitor<'a> for PsPrimitiveValueVisitor<'a> {
    type Value = PsPrimitiveValue;

    fn visit_node(&mut self, node: xml::parser::Node<'a, 'a>) -> Result<()> {
        if !node.is_element() {
            return Ok(());
        }

        let tag_name = node.tag_name().name();

        match tag_name {
            "S" => {
                let text = node.text().unwrap_or("").to_string();
                self.value = Some(PsPrimitiveValue::Str(text));
            }
            "B" => {
                let text = node.text().unwrap_or("false");
                let bool_val = text.parse::<bool>().map_err(|_| {
                    xml::XmlError::GenericError(format!("Invalid boolean value: {text}"))
                })?;
                self.value = Some(PsPrimitiveValue::Bool(bool_val));
            }
            "I32" => {
                let text = node.text().unwrap_or("0");
                let int_val = text.parse::<i32>().map_err(|_| {
                    xml::XmlError::GenericError(format!("Invalid i32 value: {text}"))
                })?;
                self.value = Some(PsPrimitiveValue::I32(int_val));
            }
            "U32" => {
                let text = node.text().unwrap_or("0");
                let uint_val = text.parse::<u32>().map_err(|_| {
                    xml::XmlError::GenericError(format!("Invalid u32 value: {text}"))
                })?;
                self.value = Some(PsPrimitiveValue::U32(uint_val));
            }
            "U64" => {
                let text = node.text().unwrap_or("0");
                let uint_val = text.parse::<u64>().map_err(|_| {
                    xml::XmlError::GenericError(format!("Invalid u64 value: {text}"))
                })?;
                self.value = Some(PsPrimitiveValue::U64(uint_val));
            }
            "I64" => {
                let text = node.text().unwrap_or("0");
                let long_val = text.parse::<i64>().map_err(|_| {
                    xml::XmlError::GenericError(format!("Invalid i64 value: {text}"))
                })?;
                self.value = Some(PsPrimitiveValue::I64(long_val));
            }
            "DT" => {
                let text = node.text().unwrap_or("").to_string();
                self.value = Some(PsPrimitiveValue::DateTime(text));
            }
            "G" => {
                let text = node.text().unwrap_or("").to_string();
                self.value = Some(PsPrimitiveValue::Guid(text));
            }
            "Nil" => {
                self.value = Some(PsPrimitiveValue::Nil);
            }
            "BA" => {
                let text = node.text().unwrap_or("");
                let bytes = B64.decode(text).map_err(|_| {
                    xml::XmlError::GenericError(format!("Invalid base64 data: {text}"))
                })?;
                self.value = Some(PsPrimitiveValue::Bytes(bytes));
            }
            "Version" => {
                let text = node.text().unwrap_or("").to_string();
                self.value = Some(PsPrimitiveValue::Version(text));
            }
            _ => {
                return Err(xml::XmlError::UnexpectedTag(tag_name.to_string()));
            }
        }

        Ok(())
    }

    fn visit_children(
        &mut self,
        _children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<()> {
        Ok(())
    }

    fn finish(self) -> Result<Self::Value> {
        self.value
            .ok_or_else(|| xml::XmlError::GenericError("No PsPrimitiveValue found".to_string()))
    }
}

impl<'a> XmlDeserialize<'a> for PsPrimitiveValue {
    type Visitor = PsPrimitiveValueVisitor<'a>;

    fn visitor() -> Self::Visitor {
        PsPrimitiveValueVisitor::new()
    }
}

/// ================================================================================================
/// Context-Aware Deserialization System for Type and Object References
/// ================================================================================================
/// Context for deserialization that maintains reference maps
#[derive(Debug, Default)]
pub struct DeserializationContext {
    /// Maps RefId to PsType for type references (<TNRef RefId="...">)
    pub type_refs: HashMap<String, PsType>,
    /// Maps RefId to ComplexObject for object references (<Ref RefId="...">)
    pub object_refs: HashMap<String, ComplexObject>,
}

impl DeserializationContext {
    pub fn new() -> Self {
        Self {
            type_refs: HashMap::new(),
            object_refs: HashMap::new(),
        }
    }

    pub fn register_type(&mut self, ref_id: String, ps_type: PsType) {
        trace!(
            "Registering type reference RefId={} with {} type names",
            ref_id,
            ps_type.type_names.len()
        );
        trace!(?ps_type, "Type details for RefId={}", ref_id);
        self.type_refs.insert(ref_id, ps_type);
    }

    pub fn get_type(&self, ref_id: &str) -> Option<&PsType> {
        let result = self.type_refs.get(ref_id);
        trace!(
            "Looking up type reference RefId={}, found={}",
            ref_id,
            result.is_some()
        );
        result
    }

    pub fn register_object(&mut self, ref_id: String, object: ComplexObject) {
        trace!(?object, "Object details for RefId={}", ref_id);
        self.object_refs.insert(ref_id, object);
    }

    pub fn get_object(&self, ref_id: &str) -> Option<&ComplexObject> {
        let result = self.object_refs.get(ref_id);
        trace!(
            "Looking up object reference RefId={}, found={}",
            ref_id,
            result.is_some()
        );
        if result.is_none() {
            trace!(
                "Available object RefIds: {:?}",
                self.object_refs.keys().collect::<Vec<_>>()
            );
        }
        result
    }
}

/// Context-aware visitor trait for deserialization with reference resolution
pub trait PsXmlVisitor<'a> {
    type Value;

    fn visit_node(
        &mut self,
        node: xml::parser::Node<'a, 'a>,
        context: &mut DeserializationContext,
    ) -> Result<()>;
    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
        context: &mut DeserializationContext,
    ) -> Result<()>;
    fn finish(self) -> Result<Self::Value>;
}

/// Context-aware deserialize trait
pub trait PsXmlDeserialize<'a>: Sized {
    type Visitor: PsXmlVisitor<'a, Value = Self>;

    fn visitor_with_context() -> Self::Visitor;

    fn from_node_with_context(
        node: xml::parser::Node<'a, 'a>,
        context: &mut DeserializationContext,
    ) -> Result<Self> {
        let mut visitor = Self::visitor_with_context();
        visitor.visit_node(node, context)?;
        visitor.finish()
    }

    fn from_children_with_context(
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
        context: &mut DeserializationContext,
    ) -> Result<Self> {
        let mut visitor = Self::visitor_with_context();
        visitor.visit_children(children, context)?;
        visitor.finish()
    }
}

/// Context-aware PsType visitor that handles type references
pub struct PsTypeContextVisitor<'a> {
    type_names: Vec<Cow<'static, str>>,
    resolved_type: Option<PsType>,
    _phantom: std::marker::PhantomData<&'a ()>,
}

impl<'a> Default for PsTypeContextVisitor<'a> {
    fn default() -> Self {
        Self::new()
    }
}

impl<'a> PsTypeContextVisitor<'a> {
    pub fn new() -> Self {
        Self {
            type_names: Vec::new(),
            resolved_type: None,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<'a> PsXmlVisitor<'a> for PsTypeContextVisitor<'a> {
    type Value = PsType;

    fn visit_node(
        &mut self,
        node: xml::parser::Node<'a, 'a>,
        context: &mut DeserializationContext,
    ) -> Result<()> {
        if !node.is_element() {
            return Ok(());
        }

        let tag_name = node.tag_name().name();

        match tag_name {
            "TN" => {
                // Full type definition - extract RefId and register it
                if let Some(ref_id) = node.attribute("RefId") {
                    trace!(ref_id, "Processing TN with RefId");
                    // Process children to get <T> elements
                    self.visit_children(node.children(), context)?;

                    let ps_type = PsType {
                        type_names: self.type_names.clone(),
                    };

                    // Register this type in the context
                    context.register_type(ref_id.to_string(), ps_type.clone());
                    self.resolved_type = Some(ps_type);
                } else {
                    trace!("Processing TN without RefId");
                    // TN without RefId - just process children
                    self.visit_children(node.children(), context)?;
                    self.resolved_type = Some(PsType {
                        type_names: self.type_names.clone(),
                    });
                }
            }
            "TNRef" => {
                // Type reference - look up existing type definition
                if let Some(ref_id) = node.attribute("RefId") {
                    trace!("Processing TNRef with RefId={}", ref_id);
                    if let Some(ps_type) = context.get_type(ref_id) {
                        trace!("Successfully resolved TNRef RefId={}", ref_id);
                        self.resolved_type = Some(ps_type.clone());
                    } else {
                        trace!("Failed to resolve TNRef RefId={}", ref_id);
                        return Err(xml::XmlError::GenericError(format!(
                            "Type reference {ref_id} not found"
                        )));
                    }
                } else {
                    trace!("TNRef missing RefId attribute");
                    return Err(xml::XmlError::GenericError(
                        "TNRef missing RefId attribute".to_string(),
                    ));
                }
            }
            _ => {
                return Err(xml::XmlError::UnexpectedTag(format!(
                    "Unexpected tag in PsType: {tag_name}"
                )));
            }
        }

        Ok(())
    }

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
        _context: &mut DeserializationContext,
    ) -> Result<()> {
        for child in children {
            if child.is_element()
                && child.tag_name().name() == "T"
                && let Some(text) = child.text()
            {
                self.type_names.push(Cow::Owned(text.to_string()));
            }
        }
        Ok(())
    }

    fn finish(self) -> Result<Self::Value> {
        self.resolved_type
            .ok_or_else(|| xml::XmlError::GenericError("No PsType resolved".to_string()))
    }
}

impl<'a> PsXmlDeserialize<'a> for PsType {
    type Visitor = PsTypeContextVisitor<'a>;

    fn visitor_with_context() -> Self::Visitor {
        PsTypeContextVisitor::new()
    }
}

/// Context-aware ComplexObject visitor that uses context for type resolution
pub struct ComplexObjectContextVisitor<'a> {
    type_def: Option<PsType>,
    to_string: Option<String>,
    content: ComplexObjectContent,
    adapted_properties: BTreeMap<String, PsProperty>,
    extended_properties: BTreeMap<String, PsProperty>,
    _phantom: std::marker::PhantomData<&'a ()>,
}

impl<'a> Default for ComplexObjectContextVisitor<'a> {
    fn default() -> Self {
        Self::new()
    }
}

impl<'a> ComplexObjectContextVisitor<'a> {
    pub fn new() -> Self {
        Self {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::Standard,
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<'a> PsXmlVisitor<'a> for ComplexObjectContextVisitor<'a> {
    type Value = ComplexObject;

    fn visit_node(
        &mut self,
        node: xml::parser::Node<'a, 'a>,
        context: &mut DeserializationContext,
    ) -> Result<()> {
        if !node.is_element() {
            return Ok(());
        }

        let tag_name = node.tag_name().name();

        if tag_name == "Obj" {
            let ref_id = node.attribute("RefId");
            trace!("Processing Obj with RefId={:?}", ref_id);
            // Process children of the Obj element
            self.visit_children(node.children(), context)?;

            // If this object has a RefId, register it in the context
            if let Some(ref_id) = ref_id {
                let obj = ComplexObject {
                    type_def: self.type_def.clone(),
                    to_string: self.to_string.clone(),
                    content: self.content.clone(),
                    adapted_properties: self.adapted_properties.clone(),
                    extended_properties: self.extended_properties.clone(),
                };
                context.register_object(ref_id.to_string(), obj);
            }
        }

        Ok(())
    }

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
        context: &mut DeserializationContext,
    ) -> Result<()> {
        for child in children {
            if !child.is_element() {
                continue;
            }

            let tag_name = child.tag_name().name();

            match tag_name {
                "TN" | "TNRef" => {
                    // Use context-aware type deserialization
                    let ps_type = PsType::from_node_with_context(child, context)?;
                    self.type_def = Some(ps_type);
                }
                "ToString" => {
                    if let Some(text) = child.text() {
                        self.to_string = Some(text.to_string());
                    }
                }
                // Handle primitive content for ExtendedPrimitive objects
                "S" | "B" | "I32" | "U32" | "I64" | "U64" | "G" | "Nil" | "BA" | "Version"
                | "DT" => {
                    let primitive = PsPrimitiveValue::from_node(child)?;
                    self.content = ComplexObjectContent::ExtendedPrimitive(primitive);
                }
                // Handle containers with context
                "STK" | "QUE" | "LST" | "DCT" => {
                    let container = Container::from_node_with_context(child, context)?;
                    self.content = ComplexObjectContent::Container(container);
                }
                "Props" => {
                    // Parse adapted properties with context
                    for prop_child in child.children() {
                        if prop_child.is_element() {
                            let prop = PsProperty::from_node_with_context(prop_child, context)?;
                            self.adapted_properties.insert(prop.name.clone(), prop);
                        }
                    }
                }
                "MS" => {
                    // Parse extended properties with context
                    for prop_child in child.children() {
                        if prop_child.is_element() {
                            let prop = PsProperty::from_node_with_context(prop_child, context)?;
                            self.extended_properties.insert(prop.name.clone(), prop);
                        }
                    }
                }
                _ => {
                    // Unknown element - could be part of content or should be ignored
                    // For now, we'll ignore unknown elements
                }
            }
        }

        // Post-process to detect enum content
        if let Some(type_def) = &self.type_def
            && type_def.type_names.iter().any(|name| name.contains("Enum"))
            && let ComplexObjectContent::ExtendedPrimitive(PsPrimitiveValue::I32(value)) =
                &self.content
        {
            self.content = ComplexObjectContent::PsEnums(PsEnums { value: *value });
        }

        Ok(())
    }

    fn finish(self) -> Result<Self::Value> {
        Ok(ComplexObject {
            type_def: self.type_def,
            to_string: self.to_string,
            content: self.content,
            adapted_properties: self.adapted_properties,
            extended_properties: self.extended_properties,
        })
    }
}

impl<'a> PsXmlDeserialize<'a> for ComplexObject {
    type Visitor = ComplexObjectContextVisitor<'a>;

    fn visitor_with_context() -> Self::Visitor {
        ComplexObjectContextVisitor::new()
    }
}

/// Context-aware PsValue visitor
pub struct PsValueContextVisitor<'a> {
    value: Option<PsValue>,
    _phantom: std::marker::PhantomData<&'a ()>,
}

impl<'a> Default for PsValueContextVisitor<'a> {
    fn default() -> Self {
        Self::new()
    }
}

impl<'a> PsValueContextVisitor<'a> {
    pub fn new() -> Self {
        Self {
            value: None,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<'a> PsXmlVisitor<'a> for PsValueContextVisitor<'a> {
    type Value = PsValue;

    fn visit_node(
        &mut self,
        node: xml::parser::Node<'a, 'a>,
        context: &mut DeserializationContext,
    ) -> Result<()> {
        if !node.is_element() {
            return Ok(());
        }

        let tag_name = node.tag_name().name();

        match tag_name {
            // Handle primitive values
            "S" | "B" | "I32" | "U32" | "I64" | "U64" | "G" | "Nil" | "BA" | "Version" | "DT" => {
                let primitive = PsPrimitiveValue::from_node(node)?;
                self.value = Some(PsValue::Primitive(primitive));
            }
            // Handle complex objects with context
            "Obj" => {
                let complex_obj = ComplexObject::from_node_with_context(node, context)?;
                self.value = Some(PsValue::Object(complex_obj));
            }
            // Handle object references
            "Ref" => {
                if let Some(ref_id) = node.attribute("RefId") {
                    trace!("Processing Ref with RefId={}", ref_id);
                    if let Some(complex_obj) = context.get_object(ref_id) {
                        trace!("Successfully resolved object reference RefId={}", ref_id);
                        self.value = Some(PsValue::Object(complex_obj.clone()));
                    } else {
                        trace!("Failed to resolve object reference RefId={}", ref_id);
                        return Err(xml::XmlError::GenericError(format!(
                            "Object reference {ref_id} not found"
                        )));
                    }
                } else {
                    trace!("Ref missing RefId attribute");
                    return Err(xml::XmlError::GenericError(
                        "Ref missing RefId attribute".to_string(),
                    ));
                }
            }
            _ => {
                return Err(xml::XmlError::UnexpectedTag(format!(
                    "Unexpected tag for PsValue: {tag_name}"
                )));
            }
        }

        Ok(())
    }

    fn visit_children(
        &mut self,
        _children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
        _context: &mut DeserializationContext,
    ) -> Result<()> {
        Ok(())
    }

    fn finish(self) -> Result<Self::Value> {
        self.value
            .ok_or_else(|| xml::XmlError::GenericError("No PsValue found".to_string()))
    }
}

impl<'a> PsXmlDeserialize<'a> for PsValue {
    type Visitor = PsValueContextVisitor<'a>;

    fn visitor_with_context() -> Self::Visitor {
        PsValueContextVisitor::new()
    }
}

/// Context-aware Container visitor
pub struct ContainerContextVisitor<'a> {
    container: Option<Container>,
    _phantom: std::marker::PhantomData<&'a ()>,
}

impl<'a> Default for ContainerContextVisitor<'a> {
    fn default() -> Self {
        Self::new()
    }
}

impl<'a> ContainerContextVisitor<'a> {
    pub fn new() -> Self {
        Self {
            container: None,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<'a> PsXmlVisitor<'a> for ContainerContextVisitor<'a> {
    type Value = Container;

    fn visit_node(
        &mut self,
        node: xml::parser::Node<'a, 'a>,
        context: &mut DeserializationContext,
    ) -> Result<()> {
        if !node.is_element() {
            return Ok(());
        }

        let tag_name = node.tag_name().name();

        match tag_name {
            "STK" => {
                let mut values = Vec::new();
                for child in node.children() {
                    if child.is_element() {
                        let value = PsValue::from_node_with_context(child, context)?;
                        values.push(value);
                    }
                }
                self.container = Some(Container::Stack(values));
            }
            "QUE" => {
                let mut values = Vec::new();
                for child in node.children() {
                    if child.is_element() {
                        let value = PsValue::from_node_with_context(child, context)?;
                        values.push(value);
                    }
                }
                self.container = Some(Container::Queue(values));
            }
            "LST" => {
                let mut values = Vec::new();
                for child in node.children() {
                    if child.is_element() {
                        let value = PsValue::from_node_with_context(child, context)?;
                        values.push(value);
                    }
                }
                self.container = Some(Container::List(values));
            }
            "DCT" => {
                let mut map = BTreeMap::new();
                for en_child in node.children() {
                    if en_child.is_element() && en_child.tag_name().name() == "En" {
                        let mut key: Option<PsValue> = None;
                        let mut value: Option<PsValue> = None;

                        for entry_child in en_child.children() {
                            if entry_child.is_element()
                                && let Some(n_attr) = entry_child.attribute("N")
                            {
                                match n_attr {
                                    "Key" => {
                                        key = Some(PsValue::from_node_with_context(
                                            entry_child,
                                            context,
                                        )?);
                                    }
                                    "Value" => {
                                        value = Some(PsValue::from_node_with_context(
                                            entry_child,
                                            context,
                                        )?);
                                    }
                                    _ => {}
                                }
                            }
                        }

                        if let (Some(k), Some(v)) = (key, value) {
                            map.insert(k, v);
                        }
                    }
                }
                self.container = Some(Container::Dictionary(map));
            }
            _ => {
                return Err(xml::XmlError::UnexpectedTag(format!(
                    "Unexpected container tag: {tag_name}"
                )));
            }
        }

        Ok(())
    }

    fn visit_children(
        &mut self,
        _children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
        _context: &mut DeserializationContext,
    ) -> Result<()> {
        Ok(())
    }

    fn finish(self) -> Result<Self::Value> {
        self.container
            .ok_or_else(|| xml::XmlError::GenericError("No Container found".to_string()))
    }
}

impl<'a> PsXmlDeserialize<'a> for Container {
    type Visitor = ContainerContextVisitor<'a>;

    fn visitor_with_context() -> Self::Visitor {
        ContainerContextVisitor::new()
    }
}

/// Context-aware PsProperty visitor
pub struct PsPropertyContextVisitor<'a> {
    name: Option<String>,
    value: Option<PsValue>,
    _phantom: std::marker::PhantomData<&'a ()>,
}

impl<'a> Default for PsPropertyContextVisitor<'a> {
    fn default() -> Self {
        Self::new()
    }
}

impl<'a> PsPropertyContextVisitor<'a> {
    pub fn new() -> Self {
        Self {
            name: None,
            value: None,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<'a> PsXmlVisitor<'a> for PsPropertyContextVisitor<'a> {
    type Value = PsProperty;

    fn visit_node(
        &mut self,
        node: xml::parser::Node<'a, 'a>,
        context: &mut DeserializationContext,
    ) -> Result<()> {
        if !node.is_element() {
            return Ok(());
        }

        // Extract the N attribute for property name
        if let Some(name_attr) = node.attribute("N") {
            self.name = Some(name_attr.to_string());
        }

        // Parse the value from the node using context
        let value = PsValue::from_node_with_context(node, context)?;
        self.value = Some(value);

        Ok(())
    }

    fn visit_children(
        &mut self,
        _children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
        _context: &mut DeserializationContext,
    ) -> Result<()> {
        Ok(())
    }

    fn finish(self) -> Result<Self::Value> {
        let value = self.value.ok_or_else(|| {
            xml::XmlError::GenericError("No value found for PsProperty".to_string())
        })?;

        let name = self.name.unwrap_or_default();

        Ok(PsProperty { name, value })
    }
}

impl<'a> PsXmlDeserialize<'a> for PsProperty {
    type Visitor = PsPropertyContextVisitor<'a>;

    fn visitor_with_context() -> Self::Visitor {
        PsPropertyContextVisitor::new()
    }
}


--- File: crates/protocol-powershell-remoting/src/ps_value/mod.rs ---
pub mod complex;
pub mod container;
pub mod deserialize;
pub mod primitive;
pub mod property;
pub mod serialize;
pub mod types;
pub mod value;

pub use complex::*;
pub use container::*;
pub use deserialize::*;
pub use primitive::*;
pub use property::*;
pub use serialize::*;
pub use types::*;
pub use value::*;

use crate::MessageType;

pub trait PsObjectWithType {
    fn message_type(&self) -> MessageType;
    fn to_ps_object(&self) -> PsValue;
}


--- File: crates/protocol-powershell-remoting/src/ps_value/primitive.rs ---
use std::fmt::Display;

///  https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/c8c85974-ffd7-4455-84a8-e49016c20683
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum PsPrimitiveValue {
    Str(String),
    Bool(bool),
    I32(i32),
    U32(u32),
    I64(i64),
    U64(u64),
    Guid(String),
    Nil,
    Bytes(Vec<u8>),
    Version(String),
    DateTime(String), // Store as string for now
                      // Add more primitive types as needed
}

impl Display for PsPrimitiveValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PsPrimitiveValue::Str(s) => write!(f, "{s}"),
            PsPrimitiveValue::Bool(b) => write!(f, "{b}"),
            PsPrimitiveValue::I32(i) => write!(f, "{i}"),
            PsPrimitiveValue::U32(u) => write!(f, "{u}"),
            PsPrimitiveValue::I64(i) => write!(f, "{i}"),
            PsPrimitiveValue::U64(u) => write!(f, "{u}"),
            PsPrimitiveValue::Guid(g) => write!(f, "{g}"),
            PsPrimitiveValue::Nil => write!(f, ""), // PowerShell $null stringifies to empty string
            PsPrimitiveValue::Bytes(_bytes) => write!(f, "System.Byte[]"),
            PsPrimitiveValue::Version(v) => write!(f, "{v}"),
            PsPrimitiveValue::DateTime(d) => write!(f, "{d}"),
        }
    }
}


--- File: crates/protocol-powershell-remoting/src/ps_value/property.rs ---
use super::PsValue;

#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PsProperty {
    pub name: String,
    pub value: PsValue,
}


--- File: crates/protocol-powershell-remoting/src/ps_value/serialize.rs ---
use std::collections::HashMap;

use super::{
    ComplexObject, ComplexObjectContent, Container, PsPrimitiveValue, PsProperty, PsType, PsValue,
};
use base64::Engine;
use base64::engine::general_purpose::STANDARD as B64;

use tracing::{debug, trace};
use xml::builder::{Attribute, Element};

type Result<T> = std::result::Result<T, crate::PowerShellRemotingError>;

#[derive(Debug, Default)]
pub struct RefIdMap<'a, T> {
    pub map: HashMap<&'a T, u32>,
    pub next_id: u32,
}

impl<'a, T> RefIdMap<'a, T> {
    pub fn new() -> Self {
        RefIdMap {
            map: HashMap::new(),
            next_id: 0,
        }
    }
}

impl<'a, T> RefIdMap<'a, T>
where
    T: std::hash::Hash + Eq,
{
    pub fn contains(&self, item: &T) -> bool {
        self.map.contains_key(item)
    }

    pub fn insert_new(&mut self, item: &'a T) -> Result<u32> {
        if let Some(existing_id) = self.map.get(item) {
            trace!("Item already exists in RefIdMap with id={}", existing_id);
            Err(crate::PowerShellRemotingError::SerializationError(
                "Attempted to insert duplicate item into RefIdMap",
            ))
        } else {
            let id = self.next_id;
            trace!("Assigning new RefId={} to item", id);
            self.map.insert(item, id);
            self.next_id += 1;
            Ok(id)
        }
    }
}
/// ------------------------------------------------------------------------------------------------
/// 1.  PsValue → <xml> element
/// ------------------------------------------------------------------------------------------------
impl<'a> PsPrimitiveValue {
    pub fn to_element(&'a self) -> Result<Element<'a>> {
        Ok(match self {
            PsPrimitiveValue::Str(s) => Element::new("S").set_text_owned(s.clone()),
            PsPrimitiveValue::Bool(b) => Element::new("B").set_text_owned(b.to_string()),
            PsPrimitiveValue::I32(i) => Element::new("I32").set_text_owned(i.to_string()),
            PsPrimitiveValue::U32(u) => Element::new("U32").set_text_owned(u.to_string()),
            PsPrimitiveValue::I64(i) => Element::new("I64").set_text_owned(i.to_string()),
            PsPrimitiveValue::U64(u) => Element::new("U64").set_text_owned(u.to_string()),
            PsPrimitiveValue::Guid(g) => Element::new("G").set_text_owned(g.clone()),
            PsPrimitiveValue::Nil => Element::new("Nil"), // empty tag
            PsPrimitiveValue::Bytes(b) => Element::new("BA").set_text_owned(B64.encode(b)),
            PsPrimitiveValue::Version(v) => Element::new("Version").set_text_owned(v.clone()),
            PsPrimitiveValue::DateTime(dt) => Element::new("DT").set_text_owned(dt.clone()),
        })
    }
}

impl<'a> PsValue {
    pub fn to_element_as_root(&'a self) -> Result<Element<'a>> {
        let mut objects_map = RefIdMap::new();
        let mut types_map = RefIdMap::new();
        self.to_element(&mut objects_map, &mut types_map)
    }

    pub fn to_element(
        &'a self,
        objects_map: &mut RefIdMap<'a, ComplexObject>,
        types_map: &mut RefIdMap<'a, PsType>,
    ) -> Result<Element<'a>> {
        match self {
            PsValue::Primitive(ps_primitive_value) => Ok(ps_primitive_value.to_element()?),
            PsValue::Object(complex_object) => complex_object.to_element(objects_map, types_map),
        }
    }
}

impl<'a> PsProperty {
    pub fn to_element(
        &'a self,
        objects_map: &mut RefIdMap<'a, ComplexObject>,
        types_map: &mut RefIdMap<'a, PsType>,
    ) -> Result<Element<'a>> {
        Ok(self
            .value
            .to_element(objects_map, types_map)?
            .add_attribute(Attribute::new("N", &self.name)))
    }
}

impl<'a> PsType {
    pub fn to_element(&'a self, type_maps: &mut RefIdMap<'a, PsType>) -> Result<Element<'a>> {
        if type_maps.contains(self) {
            // If this type has already been serialized, return a reference element.
            let ref_id = type_maps.map.get(self).unwrap();
            debug!("Creating TNRef for existing type with RefId={}", ref_id);
            return Ok(
                Element::new("TNRef").add_attribute(Attribute::new("RefId", ref_id.to_string()))
            );
        }

        let ref_id = type_maps.insert_new(self)?;
        trace!(
            "Creating TN with new RefId={} and {} type names",
            ref_id,
            self.type_names.len()
        );
        trace!(?self.type_names, "Type names for RefId={}", ref_id);
        let mut element =
            Element::new("TN").add_attribute(Attribute::new("RefId", ref_id.to_string()));
        for type_name in &self.type_names {
            element = element.add_child(Element::new("T").set_text_owned(type_name.to_string()));
        }
        Ok(element)
    }
}

impl<'a> Container {
    pub fn to_element(
        &'a self,
        objects_map: &mut RefIdMap<'a, ComplexObject>,
        types_map: &mut RefIdMap<'a, PsType>,
    ) -> Result<Element<'a>> {
        Ok(match self {
            // Stacks, Queues, and Lists all serialize to an <LST> tag.
            // The <TN> in the parent <Obj> is what differentiates their type.
            Container::Stack(values) => {
                let mut element = Element::new("STK");
                for value in values {
                    element = element.add_child(value.to_element(objects_map, types_map)?);
                }
                element
            }
            Container::Queue(values) => {
                let mut element = Element::new("QUE");
                for value in values {
                    element = element.add_child(value.to_element(objects_map, types_map)?);
                }
                element
            }
            Container::List(values) => {
                let mut element = Element::new("LST");
                for value in values {
                    element = element.add_child(value.to_element(objects_map, types_map)?);
                }
                element
            }
            // Dictionaries serialize to a <DCT> tag with <En> entries.
            Container::Dictionary(map) => {
                let mut element = Element::new("DCT");
                for (key, value) in map {
                    let key_element = key
                        .to_element(objects_map, types_map)?
                        .add_attribute(Attribute::new("N", "Key"));
                    let value_element = value
                        .to_element(objects_map, types_map)?
                        .add_attribute(Attribute::new("N", "Value"));

                    let entry_element = Element::new("En")
                        .add_child(key_element)
                        .add_child(value_element);

                    element = element.add_child(entry_element);
                }
                element
            }
        })
    }
}

impl<'a> ComplexObject {
    pub fn to_element_as_root(&'a self) -> Result<Element<'a>> {
        let mut objects_map = RefIdMap::new();
        let mut types_map = RefIdMap::new();
        self.to_element(&mut objects_map, &mut types_map)
    }

    pub fn to_element(
        &'a self,
        objects_map: &mut RefIdMap<'a, ComplexObject>,
        types_map: &mut RefIdMap<'a, PsType>,
    ) -> Result<Element<'a>> {
        let ref_id = if let Some(obj_ref_id) = objects_map.map.get(self) {
            // If this object has already been serialized, return a reference element.
            trace!("Creating Ref for existing object with RefId={}", obj_ref_id);
            return Ok(
                Element::new("Ref").add_attribute(Attribute::new("RefId", obj_ref_id.to_string()))
            );
        } else {
            // Assign a new RefId to this object and store it in the map.
            let new_ref_id = objects_map.insert_new(self)?;
            trace!("Creating Obj with new RefId={}", new_ref_id);
            new_ref_id
        };

        // 1. Create the root <Obj> element and add its RefId
        let mut element =
            Element::new("Obj").add_attribute(Attribute::new("RefId", ref_id.to_string()));

        // 2. Add optional metadata: <TN> and <ToString>
        if let Some(type_def) = &self.type_def {
            element = element.add_child(type_def.to_element(types_map)?);
        }
        if let Some(to_string) = &self.to_string {
            element = element.add_child(Element::new("ToString").set_text(to_string.as_str()));
        }

        // 3. Add the primary content based on its type
        match &self.content {
            ComplexObjectContent::ExtendedPrimitive(value) => {
                element = element.add_child(value.to_element()?);
            }
            ComplexObjectContent::Container(container) => {
                element = element.add_child(container.to_element(objects_map, types_map)?);
            }
            ComplexObjectContent::PsEnums(ps_enum) => {
                // For enums, the "content" is the <ToString> and <I32> tags.
                // Note: The general <ToString> is added above; the spec can be
                // interpreted in different ways, but often an enum's specific
                // name is placed in the general <ToString> tag.
                // We will add the required integer value here.
                element = element
                    .add_child(Element::new("I32").set_text_owned(ps_enum.value.to_string()));
            }
            ComplexObjectContent::Standard => {
                // A standard object's content is defined solely by its properties (<MS>).
                // No extra content element is needed here.
            }
        }

        // 4. Add Adapted Properties (<Props>) if they exist
        if !self.adapted_properties.is_empty() {
            let mut props_element = Element::new("Props");
            for prop in self.adapted_properties.values() {
                props_element = props_element.add_child(prop.to_element(objects_map, types_map)?);
            }
            element = element.add_child(props_element);
        }

        // 5. Add Extended/Standard Properties (<MS>) if they exist
        if !self.extended_properties.is_empty() {
            let mut ms_element = Element::new("MS");
            for prop in self.extended_properties.values() {
                ms_element = ms_element.add_child(prop.to_element(objects_map, types_map)?);
            }
            element = element.add_child(ms_element);
        }

        Ok(element)
    }
}


--- File: crates/protocol-powershell-remoting/src/ps_value/types.rs ---
use core::hash;
use std::borrow::Cow;

/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/2784bd9c-267d-4297-b603-722c727f85f1
#[derive(Debug, Clone, Eq, Default, PartialOrd, Ord)]
pub struct PsType {
    /// The <TN> element contains <T> elements, each of which contains the name of a type associated with the object being serialized.
    /// <T> elements MUST be ordered from the most specific (that is, point) to least specific (that is, object).
    /// Type names MUST be encoded as described in section 2.2.5.3.2.
    ///  Mapping type names to concrete types is outside the scope of the protocol and is an implementation detail.
    pub type_names: Vec<Cow<'static, str>>,
}

impl PsType {
    pub fn ps_primitive_dictionary() -> Self {
        PsType {
            type_names: vec![
                Cow::Borrowed("System.Management.Automation.PSPrimitiveDictionary"),
                Cow::Borrowed("System.Collections.Hashtable"),
                Cow::Borrowed("System.Object"),
            ],
        }
    }

    pub fn remote_host_method_id() -> Self {
        PsType {
            type_names: vec![
                Cow::Borrowed("System.Management.Automation.Remoting.RemoteHostMethodId"),
                Cow::Borrowed("System.Enum"),
                Cow::Borrowed("System.ValueType"),
                Cow::Borrowed("System.Object"),
            ],
        }
    }

    pub fn array_list() -> Self {
        PsType {
            type_names: vec![
                Cow::Borrowed("System.Collections.ArrayList"),
                Cow::Borrowed("System.Object"),
            ],
        }
    }

    pub fn pipeline_result_types() -> Self {
        PsType {
            type_names: vec![
                Cow::Borrowed("System.Management.Automation.Runspaces.PipelineResultTypes"),
                Cow::Borrowed("System.Enum"),
                Cow::Borrowed("System.ValueType"),
                Cow::Borrowed("System.Object"),
            ],
        }
    }
}

impl PartialEq for PsType {
    fn eq(&self, other: &Self) -> bool {
        for (ty1, ty2) in self.type_names.iter().zip(other.type_names.iter()) {
            if ty1.as_ref() != ty2.as_ref() {
                return false;
            }
        }
        true
    }
}

impl hash::Hash for PsType {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        for ty in &self.type_names {
            ty.hash(state);
        }
    }
}


--- File: crates/protocol-powershell-remoting/src/ps_value/value.rs ---
use std::fmt::Display;

use super::{ComplexObject, PsPrimitiveValue, PsType};

#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum PsValue {
    Primitive(PsPrimitiveValue),
    Object(ComplexObject),
}

impl Display for PsValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PsValue::Primitive(p) => p.fmt(f),
            PsValue::Object(o) => o.fmt(f),
        }
    }
}

impl PsValue {
    pub fn as_object(&self) -> Option<&ComplexObject> {
        if let PsValue::Object(obj) = self {
            Some(obj)
        } else {
            None
        }
    }

    /// Extract i32 value from PsValue
    pub fn as_i32(&self) -> Option<i32> {
        match self {
            PsValue::Primitive(PsPrimitiveValue::I32(val)) => Some(*val),
            _ => None,
        }
    }

    /// Extract i64 value from PsValue
    pub fn as_i64(&self) -> Option<i64> {
        match self {
            PsValue::Primitive(PsPrimitiveValue::I64(val)) => Some(*val),
            _ => None,
        }
    }

    /// Extract string value from PsValue
    pub fn as_string(&self) -> Option<String> {
        match self {
            PsValue::Primitive(PsPrimitiveValue::Str(val)) => Some(val.clone()),
            _ => None,
        }
    }

    /// Extract string array from PsValue (simplified implementation)
    pub fn as_string_array(&self) -> Option<Vec<String>> {
        // For now, simplified - in reality this would need to parse complex objects
        // that represent string arrays
        match self {
            PsValue::Object(_obj) => {
                // TODO: Parse array objects properly
                // For now return empty vec as placeholder
                Some(vec![])
            }
            _ => None,
        }
    }

    /// Create an array from a Vec of PsValues
    pub fn from_array(values: Vec<PsValue>) -> Self {
        PsValue::Object(ComplexObject {
            type_def: Some(PsType::array_list()),
            to_string: None,
            content: super::ComplexObjectContent::Container(super::Container::List(values)),
            adapted_properties: std::collections::BTreeMap::new(),
            extended_properties: std::collections::BTreeMap::new(),
        })
    }

    /// Create a string array from a Vec of strings
    pub fn from_string_array(strings: Vec<String>) -> Self {
        let values: Vec<PsValue> = strings
            .into_iter()
            .map(|s| PsValue::Primitive(PsPrimitiveValue::Str(s)))
            .collect();
        Self::from_array(values)
    }
}


--- File: crates/protocol-powershell-remoting/src/tests/creation_xml.rs ---
use crate::{
    HostInfo,
    fragmentation::{DefragmentResult, Defragmenter, Fragmenter},
    messages::{ApartmentState, InitRunspacePool, PSThreadOptions, SessionCapability},
};
use std::collections::BTreeMap;
use tracing::info;
use tracing_test::traced_test;
use uuid::Uuid;

#[test]
#[traced_test]
fn test_combined_messages_like_runspace_open() {
    // Test the exact scenario from RunspacePool::open()
    let session_capability = SessionCapability {
        protocol_version: "2.3".to_string(),
        ps_version: "2.0".to_string(),
        serialization_version: "1.1.0.1".to_string(),
        time_zone: Some("UTC".to_string()),
    };

    let init_runspace_pool = InitRunspacePool {
        min_runspaces: 1,
        max_runspaces: 1,
        thread_options: PSThreadOptions::Default,
        apartment_state: ApartmentState::Unknown,
        host_info: HostInfo::builder().build(),
        application_arguments: BTreeMap::new(),
    };

    let runspace_id = Uuid::parse_str("d034652d-126b-e340-b773-cba26459cfa8").unwrap();

    // Fragment both messages together like RunspacePool::open() does
    let mut fragmenter = Fragmenter::new(32768);
    let messages = vec![
        &session_capability as &dyn crate::PsObjectWithType,
        &init_runspace_pool,
    ];
    let fragmented_bytes = fragmenter
        .fragment_multiple(&messages, runspace_id, None)
        .unwrap();

    info!(
        "Combined messages fragmented bytes len: {}",
        fragmented_bytes.len()
    );

    // Concatenate all fragment bytes for defragmenter
    let mut all_bytes = Vec::new();
    for fragment_bytes in &fragmented_bytes {
        all_bytes.extend_from_slice(fragment_bytes);
    }

    // Try to decode it back using defragmenter
    let mut defragmenter = Defragmenter::new();
    let result = defragmenter.defragment(&all_bytes);
    assert!(
        result.is_ok(),
        "Failed to defragment our own combined messages: {:?}",
        result.err()
    );

    match result.unwrap() {
        DefragmentResult::Complete(messages) => {
            info!("Successfully decoded {} messages!", messages.len());
            assert_eq!(
                messages.len(),
                2,
                "Expected 2 messages (SessionCapability + InitRunspacePool), got {}",
                messages.len()
            );
        }
        DefragmentResult::Incomplete => panic!("Combined messages defragmentation incomplete"),
    }

    info!("Combined messages roundtrip successful!");
}


--- File: crates/protocol-powershell-remoting/src/tests/creation_xml_roundtrip.rs ---
use crate::{
    DefragmentResult, Defragmenter,
    ps_value::{
        PsValue,
        deserialize::{DeserializationContext, PsXmlDeserialize},
    },
};
use base64::Engine;
use base64::engine::general_purpose::STANDARD as B64;
use tracing::info;

/// Integration test that reads creationXml, defragments it, deserializes it,
/// and performs a round-trip serialization/deserialization test
#[test]
#[tracing_test::traced_test]
fn test_creation_xml_roundtrip() {
    // Read the creationXml resource file
    let creation_xml_base64 = include_str!("resource/creationXml");

    // Decode from base64
    let fragment_data = B64
        .decode(creation_xml_base64.trim())
        .expect("Failed to decode base64 creationXml");

    println!("Fragment data length: {} bytes", fragment_data.len());

    // Step 1: Defragment the data
    let mut defragmenter = Defragmenter::new();
    let defrag_result = defragmenter
        .defragment(&fragment_data)
        .expect("Failed to defragment creationXml");

    let messages = match defrag_result {
        DefragmentResult::Complete(messages) => {
            println!("Successfully defragmented {} messages", messages.len());
            messages
        }
        DefragmentResult::Incomplete => {
            panic!("Defragmentation was incomplete - this shouldn't happen with test data");
        }
    };

    // Step 2: Deserialize the first message and clone it
    let first_message = &messages[0];
    println!("First message type: {:?}", first_message.message_type);

    // Parse the XML data from the first message
    let xml_data =
        String::from_utf8(first_message.data.clone()).expect("Message data should be valid UTF-8");
    println!("XML data length: {} bytes", xml_data.len());

    // Parse XML and deserialize to PsValue using context-aware deserialization
    let doc = xml::parser::parse(&xml_data).expect("Failed to parse XML");
    let root_node = doc.root_element();

    let mut context = DeserializationContext::new();
    let original_ps_value = PsValue::from_node_with_context(root_node, &mut context)
        .expect("Failed to deserialize XML to PsValue");

    // Clone the deserialized value for comparison
    let cloned_ps_value = original_ps_value.clone();

    println!("Successfully deserialized original message to PsValue");

    // Step 3: Re-serialize the cloned PsValue back to XML
    let reserialized_element = cloned_ps_value
        .to_element_as_root()
        .expect("Failed to re-serialize PsValue to XML element");

    let reserialized_xml = reserialized_element.to_xml_string().unwrap();
    println!("Re-serialized XML length: {} bytes", reserialized_xml.len());

    // Step 4: Deserialize the re-serialized XML
    let reserialized_doc =
        xml::parser::parse(&reserialized_xml).expect("Failed to parse re-serialized XML");
    let reserialized_root = reserialized_doc.root_element();

    let mut round_trip_context = DeserializationContext::new();
    let round_trip_ps_value =
        PsValue::from_node_with_context(reserialized_root, &mut round_trip_context)
            .expect("Failed to deserialize re-serialized XML");

    println!("Successfully deserialized round-trip message to PsValue");

    // Step 5: Compare original and round-trip deserialized values
    assert_eq!(
        original_ps_value, round_trip_ps_value,
        "Round-trip serialization/deserialization should preserve the original data"
    );

    println!("✅ Round-trip test passed! Original and round-trip values are identical.");

    // Optional: Test all messages if there are multiple
    if messages.len() > 1 {
        println!("Testing additional messages...");

        for (i, message) in messages.iter().enumerate().skip(1) {
            println!(
                "Testing message {} (type: {:?})",
                i + 1,
                message.message_type
            );

            let xml_data = String::from_utf8(message.data.clone())
                .expect("Message data should be valid UTF-8");

            let doc = xml::parser::parse(&xml_data).expect("Failed to parse XML");
            let root_node = doc.root_element();

            // Try to deserialize using context-aware system
            let mut message_context = DeserializationContext::new();
            match PsValue::from_node_with_context(root_node, &mut message_context) {
                Ok(original) => {
                    info!(?original, "Successfully deserialized message {}", i + 1);
                    // Re-serialize
                    let reserialized_element = original
                        .to_element_as_root()
                        .expect("Failed to re-serialize PsValue to XML element");

                    let reserialized_xml = reserialized_element.to_xml_string().unwrap();

                    // Deserialize again
                    let reserialized_doc = xml::parser::parse(&reserialized_xml)
                        .expect("Failed to parse re-serialized XML");

                    let reserialized_root = reserialized_doc.root_element();

                    let mut context2 = DeserializationContext::new();
                    let round_trip =
                        PsValue::from_node_with_context(reserialized_root, &mut context2)
                            .expect("Failed to deserialize re-serialized XML");

                    assert_eq!(
                        original,
                        round_trip,
                        "Round-trip test failed for message {}",
                        i + 1
                    );

                    println!("✅ Message {} round-trip test passed!", i + 1);
                }
                Err(e) => {
                    println!("⚠️ Message {} skipped: {:?}", i + 1, e);
                    if e.to_string().contains("Object reference") {
                        println!(
                            "   (This is expected for messages with object references - serialization needs reference preservation)"
                        )
                    } else {
                        println!("   (Unexpected error - investigate further)");
                    }
                }
            }
        }
    }

    println!("🎉 All round-trip tests completed successfully!");
}

#[test]
#[tracing_test::traced_test]
fn test_creation_xml_structure_analysis() {
    // Read and decode the creationXml
    let creation_xml_base64 = include_str!("resource/creationXml");
    let fragment_data = B64
        .decode(creation_xml_base64.trim())
        .expect("Failed to decode base64 creationXml");

    // Defragment
    let mut defragmenter = Defragmenter::new();
    let defrag_result = defragmenter
        .defragment(&fragment_data)
        .expect("Failed to defragment");

    let messages = match defrag_result {
        DefragmentResult::Complete(messages) => messages,
        DefragmentResult::Incomplete => panic!("Defragmentation incomplete"),
    };

    // Analyze each message
    for (i, message) in messages.iter().enumerate() {
        println!("=== Message {} ===", i + 1);
        println!("Destination: {:?}", message.destination);
        println!("Message Type: {:?}", message.message_type);
        println!("RPID: {}", message.rpid);
        println!("PID: {:?}", message.pid);
        println!("Data length: {} bytes", message.data.len());

        // Try to parse as XML to see structure
        let xml_data =
            String::from_utf8(message.data.clone()).expect("Message data should be valid UTF-8");

        println!("XML Content Preview:");
        let preview_len = std::cmp::min(200, xml_data.len());
        println!("  {}", &xml_data[..preview_len]);
        if xml_data.len() > preview_len {
            println!("  ... (truncated)");
        }
        println!();
    }
}


--- File: crates/protocol-powershell-remoting/src/tests/exact_xml_tests.rs ---
use crate::ps_value::{
    ComplexObject, ComplexObjectContent, Container, PsEnums, PsPrimitiveValue, PsProperty, PsType,
    PsValue,
    deserialize::{DeserializationContext, PsXmlDeserialize},
};
use base64::Engine;
use std::borrow::Cow;
use std::collections::BTreeMap;
use xml::parser::parse;

#[test]
fn test_session_capability_message() {
    // First message: Session capability with timezone
    let mut complex_obj = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    // Add extended properties (MS section)
    complex_obj.extended_properties.insert(
        "protocolversion".to_string(),
        PsProperty {
            name: "protocolversion".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Version("2.2".to_string())),
        },
    );

    complex_obj.extended_properties.insert(
        "PSVersion".to_string(),
        PsProperty {
            name: "PSVersion".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Version("2.0".to_string())),
        },
    );

    complex_obj.extended_properties.insert(
        "SerializationVersion".to_string(),
        PsProperty {
            name: "SerializationVersion".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Version("1.1.0.1".to_string())),
        },
    );

    // The base64 encoded timezone data from the example
    let timezone_data = "AAEAAAD/////AQAAAAAAAAAEAQAAABxTeXN0ZW0uQ3VycmVudFN5c3RlbVRpbWVab25lBAAAABdtX0NhY2hlZERheWxpZ2h0Q2hhbmdlcw1tX3RpY2tzT2Zmc2V0Dm1fc3RhbmRhcmROYW1lDm1fZGF5bGlnaHROYW1lAwABARxTeXN0ZW0uQ29sbGVjdGlvbnMuSGFzaHRhYmxlCQkCAAAAAMDc8bz///8KCgQCAAAAHFN5c3RlbS5Db2xsZWN0aW9ucy5IYXNodGFibGUHAAAACkxvYWRGYWN0b3IHVmVyc2lvbghDb21wYXJlchBIYXNoQ29kZVByb3ZpZGVyCEhhc2hTaXplBEtleXMGVmFsdWVzAAADAwAFBQsIHFN5c3RlbS5Db2xsZWN0aW9ucy5JQ29tcGFyZXIkU3lzdGVtLkNvbGxlY3Rpb25zLklIYXNoQ29kZVByb3ZpZGVyCOxROD8BAAAACgoLAAAACQMAAAAJBAAAABADAAAAAQAAAAgI2QcAABAEAAAAAQAAAAkFAAAABAUAAAAhU3lzdGVtLkdsb2JhbGl6YXRpb24uRGF5bGlnaHRUaW1lAwAAAAdtX3N0YXJ0BW1fZW5kB21fZGVsdGEAAAANDQwAkOq4qG3LiAAQOyeuKMyIAGjEYQgAAAAL";
    let timezone_bytes = base64::engine::general_purpose::STANDARD
        .decode(timezone_data)
        .unwrap();

    complex_obj.extended_properties.insert(
        "TimeZone".to_string(),
        PsProperty {
            name: "TimeZone".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Bytes(timezone_bytes)),
        },
    );

    // Generate XML
    let element = complex_obj.to_element_as_root().unwrap();
    let xml = element.to_xml_string().unwrap();

    println!("Generated XML:");
    println!("{}", xml);

    // Verify basic structure
    assert!(xml.contains(r#"RefId="0""#));
    assert!(xml.contains(r#"<Version N="protocolversion">2.2</Version>"#));
    assert!(xml.contains(r#"<Version N="PSVersion">2.0</Version>"#));
    assert!(xml.contains(r#"<Version N="SerializationVersion">1.1.0.1</Version>"#));
    assert!(xml.contains(r#"<BA N="TimeZone">"#));
    assert!(xml.contains("<MS>"));
}

#[test]
fn test_runspace_pool_message() {
    // Second message: Complex runspace pool configuration
    let mut complex_obj = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    // Add MinRunspaces property
    complex_obj.extended_properties.insert(
        "MinRunspaces".to_string(),
        PsProperty {
            name: "MinRunspaces".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::I32(1)),
        },
    );

    // Add MaxRunspaces property
    complex_obj.extended_properties.insert(
        "MaxRunspaces".to_string(),
        PsProperty {
            name: "MaxRunspaces".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::I32(1)),
        },
    );

    // Create PSThreadOptions enum object
    let ps_thread_options = ComplexObject {
        type_def: Some(PsType {
            type_names: vec![
                Cow::Borrowed("System.Management.Automation.Runspaces.PSThreadOptions"),
                Cow::Borrowed("System.Enum"),
                Cow::Borrowed("System.ValueType"),
                Cow::Borrowed("System.Object"),
            ],
        }),
        to_string: Some("Default".to_string()),
        content: ComplexObjectContent::PsEnums(PsEnums { value: 0 }),
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    complex_obj.extended_properties.insert(
        "PSThreadOptions".to_string(),
        PsProperty {
            name: "PSThreadOptions".to_string(),
            value: PsValue::Object(ps_thread_options),
        },
    );

    // Create ApartmentState enum object
    let apartment_state = ComplexObject {
        type_def: Some(PsType {
            type_names: vec![
                Cow::Borrowed("System.Threading.ApartmentState"),
                Cow::Borrowed("System.Enum"),
                Cow::Borrowed("System.ValueType"),
                Cow::Borrowed("System.Object"),
            ],
        }),
        to_string: Some("MTA".to_string()),
        content: ComplexObjectContent::PsEnums(PsEnums { value: 1 }),
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    complex_obj.extended_properties.insert(
        "ApartmentState".to_string(),
        PsProperty {
            name: "ApartmentState".to_string(),
            value: PsValue::Object(apartment_state),
        },
    );

    // Create the complex HostInfo object structure
    let mut host_data_dict = BTreeMap::new();

    // Add dictionary entries for host data
    for (key, value_type, value_obj) in [
        (
            9,
            "System.String",
            create_string_value_object("Windows PowerShell V2 (MS Internal Only)"),
        ),
        (
            8,
            "System.Management.Automation.Host.Size",
            create_size_value_object(181, 98),
        ),
        (
            7,
            "System.Management.Automation.Host.Size",
            create_size_value_object(120, 98),
        ),
        (
            6,
            "System.Management.Automation.Host.Size",
            create_size_value_object(120, 79),
        ),
        (
            5,
            "System.Management.Automation.Host.Size",
            create_size_value_object(120, 3000),
        ),
        (4, "System.Int32", create_int32_value_object(25)),
        (
            3,
            "System.Management.Automation.Host.Coordinates",
            create_coordinates_value_object(0, 0),
        ),
        (
            2,
            "System.Management.Automation.Host.Coordinates",
            create_coordinates_value_object(0, 4),
        ),
        (
            1,
            "System.ConsoleColor",
            create_console_color_value_object(5),
        ),
        (
            0,
            "System.ConsoleColor",
            create_console_color_value_object(6),
        ),
    ] {
        host_data_dict.insert(PsValue::Primitive(PsPrimitiveValue::I32(key)), value_obj);
    }

    let host_hashtable = ComplexObject {
        type_def: Some(PsType {
            type_names: vec![
                Cow::Borrowed("System.Collections.Hashtable"),
                Cow::Borrowed("System.Object"),
            ],
        }),
        to_string: None,
        content: ComplexObjectContent::Container(Container::Dictionary(host_data_dict)),
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    // Create _hostDefaultData object
    let mut host_default_data = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    host_default_data.extended_properties.insert(
        "data".to_string(),
        PsProperty {
            name: "data".to_string(),
            value: PsValue::Object(host_hashtable),
        },
    );

    // Create the main HostInfo object
    let mut host_info = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    host_info.extended_properties.insert(
        "_hostDefaultData".to_string(),
        PsProperty {
            name: "_hostDefaultData".to_string(),
            value: PsValue::Object(host_default_data),
        },
    );

    host_info.extended_properties.insert(
        "_isHostNull".to_string(),
        PsProperty {
            name: "_isHostNull".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Bool(false)),
        },
    );

    host_info.extended_properties.insert(
        "_isHostUINull".to_string(),
        PsProperty {
            name: "_isHostUINull".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Bool(false)),
        },
    );

    host_info.extended_properties.insert(
        "_isHostRawUINull".to_string(),
        PsProperty {
            name: "_isHostRawUINull".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Bool(false)),
        },
    );

    host_info.extended_properties.insert(
        "_useRunspaceHost".to_string(),
        PsProperty {
            name: "_useRunspaceHost".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Bool(false)),
        },
    );

    complex_obj.extended_properties.insert(
        "HostInfo".to_string(),
        PsProperty {
            name: "HostInfo".to_string(),
            value: PsValue::Object(host_info),
        },
    );

    // Add ApplicationArguments as Nil
    complex_obj.extended_properties.insert(
        "ApplicationArguments".to_string(),
        PsProperty {
            name: "ApplicationArguments".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Nil),
        },
    );

    // Generate XML
    let element = complex_obj.to_element_as_root().unwrap();
    let xml = element.to_xml_string().unwrap();

    println!("Generated XML:");
    println!("{}", xml);

    // Verify basic structure
    assert!(xml.contains(r#"RefId="1""#));
    assert!(xml.contains(r#"<I32 N="MinRunspaces">1</I32>"#));
    assert!(xml.contains(r#"<I32 N="MaxRunspaces">1</I32>"#));
    assert!(xml.contains("PSThreadOptions"));
    assert!(xml.contains("ApartmentState"));
    assert!(xml.contains("HostInfo"));
    assert!(xml.contains(r#"<Nil N="ApplicationArguments"/>"#));
}

// Helper functions to create the complex nested objects
fn create_string_value_object(value: &str) -> PsValue {
    let mut obj = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    obj.extended_properties.insert(
        "T".to_string(),
        PsProperty {
            name: "T".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Str("System.String".to_string())),
        },
    );

    obj.extended_properties.insert(
        "V".to_string(),
        PsProperty {
            name: "V".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Str(value.to_string())),
        },
    );

    PsValue::Object(obj)
}

fn create_size_value_object(width: i32, height: i32) -> PsValue {
    let mut size_obj = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    size_obj.extended_properties.insert(
        "width".to_string(),
        PsProperty {
            name: "width".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::I32(width)),
        },
    );

    size_obj.extended_properties.insert(
        "height".to_string(),
        PsProperty {
            name: "height".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::I32(height)),
        },
    );

    let mut wrapper_obj = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    wrapper_obj.extended_properties.insert(
        "T".to_string(),
        PsProperty {
            name: "T".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Str(
                "System.Management.Automation.Host.Size".to_string(),
            )),
        },
    );

    wrapper_obj.extended_properties.insert(
        "V".to_string(),
        PsProperty {
            name: "V".to_string(),
            value: PsValue::Object(size_obj),
        },
    );

    PsValue::Object(wrapper_obj)
}

fn create_coordinates_value_object(x: i32, y: i32) -> PsValue {
    let mut coords_obj = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    coords_obj.extended_properties.insert(
        "x".to_string(),
        PsProperty {
            name: "x".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::I32(x)),
        },
    );

    coords_obj.extended_properties.insert(
        "y".to_string(),
        PsProperty {
            name: "y".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::I32(y)),
        },
    );

    let mut wrapper_obj = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    wrapper_obj.extended_properties.insert(
        "T".to_string(),
        PsProperty {
            name: "T".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Str(
                "System.Management.Automation.Host.Coordinates".to_string(),
            )),
        },
    );

    wrapper_obj.extended_properties.insert(
        "V".to_string(),
        PsProperty {
            name: "V".to_string(),
            value: PsValue::Object(coords_obj),
        },
    );

    PsValue::Object(wrapper_obj)
}

fn create_int32_value_object(value: i32) -> PsValue {
    let mut obj = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    obj.extended_properties.insert(
        "T".to_string(),
        PsProperty {
            name: "T".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Str("System.Int32".to_string())),
        },
    );

    obj.extended_properties.insert(
        "V".to_string(),
        PsProperty {
            name: "V".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::I32(value)),
        },
    );

    PsValue::Object(obj)
}

fn create_console_color_value_object(value: i32) -> PsValue {
    let mut obj = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    obj.extended_properties.insert(
        "T".to_string(),
        PsProperty {
            name: "T".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Str("System.ConsoleColor".to_string())),
        },
    );

    obj.extended_properties.insert(
        "V".to_string(),
        PsProperty {
            name: "V".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::I32(value)),
        },
    );

    PsValue::Object(obj)
}

/// ================================================================================================
/// ROUND-TRIP TESTS: Serialize → Deserialize
/// ================================================================================================

#[test]
fn test_round_trip_session_capability() {
    // Create the original session capability object
    let mut original = ComplexObject {
        type_def: None,
        to_string: None,
        content: ComplexObjectContent::Standard,
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    original.extended_properties.insert(
        "protocolversion".to_string(),
        PsProperty {
            name: "protocolversion".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Version("2.2".to_string())),
        },
    );

    original.extended_properties.insert(
        "PSVersion".to_string(),
        PsProperty {
            name: "PSVersion".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Version("2.0".to_string())),
        },
    );

    let timezone_data = "AAEAAAD/////AQAAAAAAAAAEAQAAABxTeXN0ZW0uQ3VycmVudFN5c3RlbVRpbWVab25lBAAAABdtX0NhY2hlZERheWxpZ2h0Q2hhbmdlcw1tX3RpY2tzT2Zmc2V0Dm1fc3RhbmRhcmROYW1lDm1fZGF5bGlnaHROYW1lAwABARxTeXN0ZW0uQ29sbGVjdGlvbnMuSGFzaHRhYmxlCQkCAAAAAMDc8bz///8KCgQCAAAAHFN5c3RlbS5Db2xsZWN0aW9ucy5IYXNodGFibGUHAAAACkxvYWRGYWN0b3IHVmVyc2lvbghDb21wYXJlchBIYXNoQ29kZVByb3ZpZGVyCEhhc2hTaXplBEtleXMGVmFsdWVzAAADAwAFBQsIHFN5c3RlbS5Db2xsZWN0aW9ucy5JQ29tcGFyZXIkU3lzdGVtLkNvbGxlY3Rpb25zLklIYXNoQ29kZVByb3ZpZGVyCOxROD8BAAAACgoLAAAACQMAAAAJBAAAABADAAAAAQAAAAgI2QcAABAEAAAAAQAAAAkFAAAABAUAAAAhU3lzdGVtLkdsb2JhbGl6YXRpb24uRGF5bGlnaHRUaW1lAwAAAAdtX3N0YXJ0BW1fZW5kB21fZGVsdGEAAAANDQwAkOq4qG3LiAAQOyeuKMyIAGjEYQgAAAAL";
    let timezone_bytes = base64::engine::general_purpose::STANDARD
        .decode(timezone_data)
        .unwrap();

    original.extended_properties.insert(
        "TimeZone".to_string(),
        PsProperty {
            name: "TimeZone".to_string(),
            value: PsValue::Primitive(PsPrimitiveValue::Bytes(timezone_bytes.clone())),
        },
    );

    // Step 1: Serialize to XML
    let element = original.to_element_as_root().unwrap();
    let xml = element.to_xml_string().unwrap();

    println!("Round-trip XML: {}", xml);

    // Step 2: Parse the XML and deserialize
    let doc = parse(&xml).expect("Failed to parse XML");
    let root = doc.root_element();
    let mut context = DeserializationContext::new();
    let deserialized =
        ComplexObject::from_node_with_context(root, &mut context).expect("Failed to deserialize");

    // Step 3: Compare key properties
    assert_eq!(
        deserialized.extended_properties.len(),
        original.extended_properties.len()
    );

    // Check protocolversion
    let proto_version = &deserialized.extended_properties["protocolversion"];
    assert_eq!(proto_version.name, "protocolversion");
    if let PsValue::Primitive(PsPrimitiveValue::Version(version)) = &proto_version.value {
        assert_eq!(version, "2.2");
    } else {
        panic!("Expected Version value for protocolversion");
    }

    // Check TimeZone bytes
    let timezone = &deserialized.extended_properties["TimeZone"];
    if let PsValue::Primitive(PsPrimitiveValue::Bytes(bytes)) = &timezone.value {
        assert_eq!(bytes, &timezone_bytes);
    } else {
        panic!("Expected Bytes value for TimeZone");
    }

    println!("✅ Session capability round-trip successful!");
}

#[test]
fn test_round_trip_enum_object() {
    // Create a PSThreadOptions enum
    let original = ComplexObject {
        type_def: Some(PsType {
            type_names: vec![
                Cow::Borrowed("System.Management.Automation.Runspaces.PSThreadOptions"),
                Cow::Borrowed("System.Enum"),
                Cow::Borrowed("System.ValueType"),
                Cow::Borrowed("System.Object"),
            ],
        }),
        to_string: Some("Default".to_string()),
        content: ComplexObjectContent::PsEnums(PsEnums { value: 0 }),
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    // Serialize
    let element = original.to_element_as_root().unwrap();
    let xml = element.to_xml_string().unwrap();

    println!("Enum round-trip XML: {}", xml);

    // Deserialize
    let doc = parse(&xml).expect("Failed to parse XML");
    let root = doc.root_element();
    let mut context = DeserializationContext::new();
    let deserialized =
        ComplexObject::from_node_with_context(root, &mut context).expect("Failed to deserialize");

    // Verify
    assert!(deserialized.type_def.is_some());
    let type_def = deserialized.type_def.as_ref().unwrap();
    assert_eq!(
        type_def.type_names[0].as_ref(),
        "System.Management.Automation.Runspaces.PSThreadOptions"
    );
    assert_eq!(deserialized.to_string.as_ref().unwrap(), "Default");

    if let ComplexObjectContent::PsEnums(enum_obj) = &deserialized.content {
        assert_eq!(enum_obj.value, 0);
    } else {
        panic!("Expected PsEnums content");
    }

    println!("✅ Enum object round-trip successful!");
}

#[test]
fn test_round_trip_dictionary_container() {
    // Create a dictionary container
    let mut dict = BTreeMap::new();
    dict.insert(
        PsValue::Primitive(PsPrimitiveValue::Str("key1".to_string())),
        PsValue::Primitive(PsPrimitiveValue::I32(42)),
    );
    dict.insert(
        PsValue::Primitive(PsPrimitiveValue::I32(2)),
        PsValue::Primitive(PsPrimitiveValue::Bool(true)),
    );

    let original = ComplexObject {
        type_def: Some(PsType {
            type_names: vec![
                Cow::Borrowed("System.Collections.Hashtable"),
                Cow::Borrowed("System.Object"),
            ],
        }),
        to_string: None,
        content: ComplexObjectContent::Container(Container::Dictionary(dict)),
        adapted_properties: BTreeMap::new(),
        extended_properties: BTreeMap::new(),
    };

    // Serialize
    let element = original.to_element_as_root().unwrap();
    let xml = element.to_xml_string().unwrap();

    println!("Dictionary round-trip XML: {}", xml);

    // Deserialize
    let doc = parse(&xml).expect("Failed to parse XML");
    let root = doc.root_element();
    let mut context = DeserializationContext::new();
    let deserialized =
        ComplexObject::from_node_with_context(root, &mut context).expect("Failed to deserialize");

    // Verify structure
    if let ComplexObjectContent::Container(Container::Dictionary(deserialized_dict)) =
        &deserialized.content
    {
        assert_eq!(deserialized_dict.len(), 2);

        // Check that we have the expected key-value pairs
        let has_string_key = deserialized_dict.keys().any(|k| {
            if let PsValue::Primitive(PsPrimitiveValue::Str(s)) = k {
                s == "key1"
            } else {
                false
            }
        });
        assert!(has_string_key, "Should have string key 'key1'");

        let has_int_key = deserialized_dict.keys().any(|k| {
            if let PsValue::Primitive(PsPrimitiveValue::I32(i)) = k {
                *i == 2
            } else {
                false
            }
        });
        assert!(has_int_key, "Should have int key '2'");
    } else {
        panic!("Expected Dictionary container");
    }

    println!("✅ Dictionary container round-trip successful!");
}

/// ================================================================================================
/// PREDEFINED XML DESERIALIZATION TESTS
/// ================================================================================================

#[test]
fn test_deserialize_predefined_session_capability_xml() {
    // This is the first XML message from our previous conversation
    let xml = r#"<Obj RefId="0">
   <MS>
     <Version N="protocolversion">2.2</Version>
     <Version N="PSVersion">2.0</Version>
     <Version N="SerializationVersion">1.1.0.1</Version>
     <BA N="TimeZone">AAEAAAD/////AQAAAAAAAAAEAQAAABxTeXN0ZW0uQ3VycmVudFN5c3RlbVRpbWVab25lBAAAABdtX0NhY2hlZERheWxpZ2h0Q2hhbmdlcw1tX3RpY2tzT2Zmc2V0Dm1fc3RhbmRhcmROYW1lDm1fZGF5bGlnaHROYW1lAwABARxTeXN0ZW0uQ29sbGVjdGlvbnMuSGFzaHRhYmxlCQkCAAAAAMDc8bz///8KCgQCAAAAHFN5c3RlbS5Db2xsZWN0aW9ucy5IYXNodGFibGUHAAAACkxvYWRGYWN0b3IHVmVyc2lvbghDb21wYXJlchBIYXNoQ29kZVByb3ZpZGVyCEhhc2hTaXplBEtleXMGVmFsdWVzAAADAwAFBQsIHFN5c3RlbS5Db2xsZWN0aW9ucy5JQ29tcGFyZXIkU3lzdGVtLkNvbGxlY3Rpb25zLklIYXNoQ29kZVByb3ZpZGVyCOxROD8BAAAACgoLAAAACQMAAAAJBAAAABADAAAAAQAAAAgI2QcAABAEAAAAAQAAAAkFAAAABAUAAAAhU3lzdGVtLkdsb2JhbGl6YXRpb24uRGF5bGlnaHRUaW1lAwAAAAdtX3N0YXJ0BW1fZW5kB21fZGVsdGEAAAANDQwAkOq4qG3LiAAQOyeuKMyIAGjEYQgAAAAL</BA>
   </MS>
 </Obj>"#;

    // Parse and deserialize
    let doc = parse(xml).expect("Failed to parse predefined XML");
    let root = doc.root_element();
    let mut context = DeserializationContext::new();
    let deserialized = ComplexObject::from_node_with_context(root, &mut context)
        .expect("Failed to deserialize predefined XML");

    // Verify structure
    assert_eq!(deserialized.content, ComplexObjectContent::Standard);
    assert_eq!(deserialized.extended_properties.len(), 4);

    // Check protocolversion
    let proto_version = &deserialized.extended_properties["protocolversion"];
    if let PsValue::Primitive(PsPrimitiveValue::Version(version)) = &proto_version.value {
        assert_eq!(version, "2.2");
    } else {
        panic!("Expected Version value for protocolversion");
    }

    // Check PSVersion
    let ps_version = &deserialized.extended_properties["PSVersion"];
    if let PsValue::Primitive(PsPrimitiveValue::Version(version)) = &ps_version.value {
        assert_eq!(version, "2.0");
    } else {
        panic!("Expected Version value for PSVersion");
    }

    // Check TimeZone (base64 data)
    let timezone = &deserialized.extended_properties["TimeZone"];
    if let PsValue::Primitive(PsPrimitiveValue::Bytes(bytes)) = &timezone.value {
        assert!(!bytes.is_empty());
    } else {
        panic!("Expected Bytes value for TimeZone");
    }

    println!("✅ Predefined session capability XML deserialized successfully!");
}

#[test]
fn test_deserialize_simple_enum_xml() {
    // Simple enum XML structure
    let xml = r#"<Obj RefId="2">
       <TN RefId="0">
         <T>System.Management.Automation.Runspaces.PSThreadOptions</T>
         <T>System.Enum</T>
         <T>System.ValueType</T>
         <T>System.Object</T>
       </TN>
       <ToString>Default</ToString>
       <I32>0</I32>
     </Obj>"#;

    // Parse and deserialize
    let doc = parse(xml).expect("Failed to parse enum XML");
    let root = doc.root_element();
    let mut context = DeserializationContext::new();
    let deserialized = ComplexObject::from_node_with_context(root, &mut context)
        .expect("Failed to deserialize enum XML");

    // Verify enum structure
    assert!(deserialized.type_def.is_some());
    let type_def = deserialized.type_def.as_ref().unwrap();
    assert_eq!(
        type_def.type_names[0].as_ref(),
        "System.Management.Automation.Runspaces.PSThreadOptions"
    );
    assert_eq!(deserialized.to_string.as_ref().unwrap(), "Default");

    if let ComplexObjectContent::PsEnums(enum_obj) = &deserialized.content {
        assert_eq!(enum_obj.value, 0);
    } else {
        panic!("Expected PsEnums content, got: {:?}", deserialized.content);
    }

    println!("✅ Simple enum XML deserialized successfully!");
}

#[test]
fn test_deserialize_dictionary_xml() {
    // Simple dictionary structure
    let xml = r#"<Obj RefId="4">
       <TN RefId="2">
         <T>System.Collections.Hashtable</T>
         <T>System.Object</T>
       </TN>
       <DCT>
         <En>
           <I32 N="Key">9</I32>
           <S N="Value">Windows PowerShell</S>
         </En>
         <En>
           <S N="Key">test</S>
           <I32 N="Value">42</I32>
         </En>
       </DCT>
     </Obj>"#;

    // Parse and deserialize
    let doc = parse(xml).expect("Failed to parse dictionary XML");
    let root = doc.root_element();
    let mut context = DeserializationContext::new();
    let deserialized = ComplexObject::from_node_with_context(root, &mut context)
        .expect("Failed to deserialize dictionary XML");

    // Verify dictionary structure
    if let ComplexObjectContent::Container(Container::Dictionary(dict)) = &deserialized.content {
        assert_eq!(dict.len(), 2);

        // Verify we have the expected entries
        let has_int_key = dict.keys().any(|k| {
            if let PsValue::Primitive(PsPrimitiveValue::I32(9)) = k {
                true
            } else {
                false
            }
        });
        assert!(has_int_key, "Should have integer key 9");

        let has_string_key = dict.keys().any(|k| {
            if let PsValue::Primitive(PsPrimitiveValue::Str(s)) = k {
                s == "test"
            } else {
                false
            }
        });
        assert!(has_string_key, "Should have string key 'test'");
    } else {
        panic!(
            "Expected Dictionary container, got: {:?}",
            deserialized.content
        );
    }

    println!("✅ Dictionary XML deserialized successfully!");
}

#[test]
fn test_primitive_values_round_trip() {
    let test_cases = vec![
        ("String", PsPrimitiveValue::Str("Hello World".to_string())),
        ("Boolean true", PsPrimitiveValue::Bool(true)),
        ("Boolean false", PsPrimitiveValue::Bool(false)),
        ("I32", PsPrimitiveValue::I32(-42)),
        ("U32", PsPrimitiveValue::U32(42)),
        ("I64", PsPrimitiveValue::I64(-1234567890)),
        ("Nil", PsPrimitiveValue::Nil),
        ("Version", PsPrimitiveValue::Version("1.2.3.4".to_string())),
        (
            "Guid",
            PsPrimitiveValue::Guid("12345678-1234-1234-1234-123456789012".to_string()),
        ),
        (
            "Bytes",
            PsPrimitiveValue::Bytes(vec![0x48, 0x65, 0x6c, 0x6c, 0x6f]),
        ),
    ];

    for (test_name, original_primitive) in test_cases {
        println!("Testing {}", test_name);

        // Create object with primitive content
        let original = ComplexObject {
            type_def: None,
            to_string: None,
            content: ComplexObjectContent::ExtendedPrimitive(original_primitive.clone()),
            adapted_properties: BTreeMap::new(),
            extended_properties: BTreeMap::new(),
        };

        // Serialize
        let element = original.to_element_as_root().unwrap();
        let xml = element.to_xml_string().expect("Failed to serialize to XML");

        println!("  XML: {}", xml);

        // Deserialize
        let doc = parse(&xml).expect("Failed to parse XML");
        let root = doc.root_element();
        let mut context = DeserializationContext::new();
        let deserialized = ComplexObject::from_node_with_context(root, &mut context)
            .expect("Failed to deserialize");

        // Verify
        if let ComplexObjectContent::ExtendedPrimitive(deserialized_primitive) =
            &deserialized.content
        {
            assert_eq!(
                deserialized_primitive, &original_primitive,
                "Mismatch in {}",
                test_name
            );
        } else {
            panic!("Expected ExtendedPrimitive content for {}", test_name);
        }
    }

    println!("✅ All primitive values round-trip successful!");
}


--- File: crates/protocol-powershell-remoting/src/tests/mod.rs ---
pub mod creation_xml;
pub mod creation_xml_roundtrip;
pub mod exact_xml_tests;
pub mod parse_real_pipeline_output;

pub mod parse_real_pipeline_host_call;


--- File: crates/protocol-powershell-remoting/src/tests/parse_real_pipeline_host_call.rs ---
use crate::{
    messages::PipelineHostCall,
    ps_value::ComplexObject,
    ps_value::PsValue,
    ps_value::deserialize::{DeserializationContext, PsXmlDeserialize},
};

const PIPELINE_HOST_CALL: &'static str = r#"
<Obj RefId="0"><MS><I64 N="ci">-100</I64><Obj N="mi" RefId="1"><TN RefId="0"><T>System.Management.Automation.Remoting.RemoteHostMethoodId</T><T>System.Enum</T><T>System.ValueType</T><T>System.Object</T></TN><ToString>WriteProgress</ToString><I32>20</I32></Obj><Obj N="mp" RefId="2"><TN RefId="1"><T>System.Collections.ArrayList</T><T>System.Object</T></TN><LST><I64>3</I64><Obj RefId="3"><MS><S N="Activity">Preparing modules for first use.</S><I32 N="ActivityId">0</I32><S N="StatusDescription"> </S><Nil N="CurrentOperation" /><I32 N="ParentActivityId">-1</I32><I32 N="PercentComplete">-1</I32><Obj N="Type" RefId="4"><TN RefId="2"><T>System.Management.Automation.ProgressRecordType</T><T>System.Enum</T><T>System.ValueType</T><T>System.Object</T></TN><ToString>Completed</ToString><I32>1</I32></Obj><I32 N="SecondsRemaining">-1</I32></MS></Obj></LST></Obj></MS></Obj>
"#;

#[test]
fn test_parse_real_pipeline_host_call() {
    // Parse the XML and deserialize
    let parsed = xml::parser::parse(PIPELINE_HOST_CALL).expect("Failed to parse XML");
    let root = parsed.root_element();
    let mut context = DeserializationContext::new();
    let complex_obj =
        ComplexObject::from_node_with_context(root, &mut context).expect("Failed to deserialize");

    println!("Complex Object: {:#?}", complex_obj);

    // Debug the method identifier structure
    if let Some(mi_prop) = complex_obj.extended_properties.get("mi") {
        if let PsValue::Object(mi_obj) = &mi_prop.value {
            println!("Method identifier object content: {:?}", mi_obj.content);
            println!("Method identifier to_string: {:?}", mi_obj.to_string);
        }
    }

    let pipeline_host_call =
        PipelineHostCall::try_from(complex_obj).expect("Failed to convert to PipelineHostCall");

    println!("PipelineHostCall: {:#?}", pipeline_host_call);

    // Verify the parsed values
    assert_eq!(pipeline_host_call.call_id, -100);
    assert_eq!(pipeline_host_call.method_id, 20);
    assert_eq!(pipeline_host_call.method_name, "WriteProgress");
    assert_eq!(pipeline_host_call.parameters.len(), 2); // I64(3) and the progress record object
}


--- File: crates/protocol-powershell-remoting/src/tests/parse_real_pipeline_output.rs ---
use crate::{
    ps_value::deserialize::PsXmlDeserialize,
    ps_value::{
        ComplexObjectContent, Container, PsPrimitiveValue, PsValue,
        deserialize::DeserializationContext,
    },
};

const PIPELINE_OUTPUT: &'static str = r#"
<Obj RefId="0"><TN RefId="0"><T>System.IO.DirectoryInfo</T><T>System.IO.FileSystemInfo</T><T>System.MarshalByRefObject</T><T>System.Object</T></TN><ToString>ADMF</ToString><Props><S N="Name">ADMF</S><S N="FullName">C:\Users\Administrator\Documents\ADMF</S><S N="Parent">Documents</S><B N="Exists">true</B><S N="Root">C:\</S><S N="Extension"></S><DT N="CreationTime">2023-08-31T14:40:37.0592148-04:00</DT><DT N="CreationTimeUtc">2023-08-31T18:40:37.0592148Z</DT><DT N="LastAccessTime">2023-08-31T14:40:41.2433837-04:00</DT><DT N="LastAccessTimeUtc">2023-08-31T18:40:41.2433837Z</DT><DT N="LastWriteTime">2023-08-31T14:40:40.6107368-04:00</DT><DT N="LastWriteTimeUtc">2023-08-31T18:40:40.6107368Z</DT><S N="Attributes">Directory</S></Props><MS><S N="PSPath">Microsoft.PowerShell.Core\FileSystem::C:\Users\Administrator\Documents\ADMF</S><S N="PSParentPath">Microsoft.PowerShell.Core\FileSystem::C:\Users\Administrator\Documents</S><S N="PSChildName">ADMF</S><Obj N="PSDrive" RefId="1"><TN RefId="1"><T>System.Management.Automation.PSDriveInfo</T><T>System.Object</T></TN><ToString>C</ToString><Props><S N="CurrentLocation">Users\Administrator\Documents</S><S N="Name">C</S><S N="Provider">Microsoft.PowerShell.Core\FileSystem</S><S N="Root">C:\</S><S N="Description">System</S><Nil N="MaximumSize" /><Obj N="Credential" RefId="2"><TN RefId="2"><T>System.Management.Automation.PSCredential</T><T>System.Object</T></TN><ToString>System.Management.Automation.PSCredential</ToString><Props><Nil N="UserName" /><Nil N="Password" /></Props></Obj><Nil N="DisplayRoot" /></Props><MS><U64 N="Used">66251223040</U64><U64 N="Free">70923485184</U64></MS></Obj><Obj N="PSProvider" RefId="3"><TN RefId="3"><T>System.Management.Automation.ProviderInfo</T><T>System.Object</T></TN><ToString>Microsoft.PowerShell.Core\FileSystem</ToString><Props><S N="ImplementingType">Microsoft.PowerShell.Commands.FileSystemProvider</S><S N="HelpFile">System.Management.Automation.dll-Help.xml</S><S N="Name">FileSystem</S><S N="PSSnapIn">Microsoft.PowerShell.Core</S><S N="ModuleName">Microsoft.PowerShell.Core</S><Nil N="Module" /><S N="Description"></S><S N="Capabilities">Filter, ShouldProcess, Credentials</S><S N="Home">C:\Users\Administrator</S><Obj N="Drives" RefId="4"><TN RefId="4"><T>System.Collections.ObjectModel.Collection`1[[System.Management.Automation.PSDriveInfo, System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]]</T><T>System.Object</T></TN><LST><Ref RefId="1" /><S>A</S><S>D</S></LST></Obj></Props></Obj><B N="PSIsContainer">true</B><S N="Mode">d-----</S><S N="BaseName">ADMF</S><Obj N="Target" RefId="5"><TN RefId="5"><T>System.Collections.Generic.List`1[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]</T><T>System.Object</T></TN><LST /></Obj><Nil N="LinkType" /></MS></Obj>
"#;

#[test]
fn test_parse_real_pipeline_output() {
    // Parse the XML
    let parsed = xml::parser::parse(PIPELINE_OUTPUT).expect("Failed to parse XML");
    let root = parsed.root_element();

    // Create deserialization context
    let mut context = DeserializationContext::default();

    // Parse to PsValue
    let ps_value = PsValue::from_node_with_context(root, &mut context)
        .expect("Failed to parse XML to PsValue");

    // Verify that we got a complex object
    let complex_obj = ps_value.as_object().expect("Expected complex object");

    // Test basic structure
    assert!(
        complex_obj.type_def.is_some(),
        "Should have type definition"
    );

    let type_def = complex_obj.type_def.as_ref().unwrap();
    assert!(!type_def.type_names.is_empty(), "Should have type names");
    assert_eq!(
        type_def.type_names[0], "System.IO.DirectoryInfo",
        "First type should be DirectoryInfo"
    );

    // Test ToString
    assert_eq!(
        complex_obj.to_string,
        Some("ADMF".to_string()),
        "ToString should be ADMF"
    );

    // Test adapted properties
    assert!(
        !complex_obj.adapted_properties.is_empty(),
        "Should have adapted properties"
    );

    // Check specific properties
    let name_prop = complex_obj
        .adapted_properties
        .get("Name")
        .expect("Should have Name property");
    if let PsValue::Primitive(PsPrimitiveValue::Str(name)) = &name_prop.value {
        assert_eq!(name, "ADMF", "Name should be ADMF");
    } else {
        panic!("Name property should be a string");
    }

    let full_name_prop = complex_obj
        .adapted_properties
        .get("FullName")
        .expect("Should have FullName property");
    if let PsValue::Primitive(PsPrimitiveValue::Str(full_name)) = &full_name_prop.value {
        assert_eq!(
            full_name, "C:\\Users\\Administrator\\Documents\\ADMF",
            "FullName should match"
        );
    } else {
        panic!("FullName property should be a string");
    }

    let exists_prop = complex_obj
        .adapted_properties
        .get("Exists")
        .expect("Should have Exists property");
    if let PsValue::Primitive(PsPrimitiveValue::Bool(exists)) = &exists_prop.value {
        assert!(exists, "Exists should be true");
    } else {
        panic!("Exists property should be a boolean");
    }

    // Test extended properties (MS section)
    assert!(
        !complex_obj.extended_properties.is_empty(),
        "Should have extended properties"
    );

    let ps_path_prop = complex_obj
        .extended_properties
        .get("PSPath")
        .expect("Should have PSPath property");
    if let PsValue::Primitive(PsPrimitiveValue::Str(ps_path)) = &ps_path_prop.value {
        assert_eq!(
            ps_path,
            "Microsoft.PowerShell.Core\\FileSystem::C:\\Users\\Administrator\\Documents\\ADMF",
            "PSPath should match"
        );
    } else {
        panic!("PSPath property should be a string");
    }

    // Test nested objects (PSDrive)
    let ps_drive_prop = complex_obj
        .extended_properties
        .get("PSDrive")
        .expect("Should have PSDrive property");
    if let PsValue::Object(ps_drive_obj) = &ps_drive_prop.value {
        assert!(
            ps_drive_obj.type_def.is_some(),
            "PSDrive should have type definition"
        );
        let ps_drive_type = ps_drive_obj.type_def.as_ref().unwrap();
        assert_eq!(
            ps_drive_type.type_names[0], "System.Management.Automation.PSDriveInfo",
            "PSDrive type should be correct"
        );

        // Test PSDrive ToString
        assert_eq!(
            ps_drive_obj.to_string,
            Some("C".to_string()),
            "PSDrive ToString should be C"
        );

        // Test PSDrive properties
        let name_prop = ps_drive_obj
            .adapted_properties
            .get("Name")
            .expect("PSDrive should have Name property");
        if let PsValue::Primitive(PsPrimitiveValue::Str(name)) = &name_prop.value {
            assert_eq!(name, "C", "PSDrive Name should be C");
        } else {
            panic!("PSDrive Name property should be a string");
        }
    } else {
        panic!("PSDrive property should be an object");
    }

    // Test object references (in the Drives collection)
    let ps_provider_prop = complex_obj
        .extended_properties
        .get("PSProvider")
        .expect("Should have PSProvider property");
    if let PsValue::Object(ps_provider_obj) = &ps_provider_prop.value {
        let drives_prop = ps_provider_obj
            .adapted_properties
            .get("Drives")
            .expect("PSProvider should have Drives property");
        if let PsValue::Object(drives_obj) = &drives_prop.value {
            if let ComplexObjectContent::Container(Container::List(drives_list)) =
                &drives_obj.content
            {
                assert!(!drives_list.is_empty(), "Drives list should not be empty");

                // The first item should be a reference to the PSDrive object
                if let PsValue::Object(ref_obj) = &drives_list[0] {
                    // This should be the same PSDrive object referenced earlier
                    assert_eq!(
                        ref_obj.to_string,
                        Some("C".to_string()),
                        "Referenced PSDrive should have ToString C"
                    );
                } else {
                    panic!("First drive should be an object");
                }
            } else {
                panic!("Drives should be a list container");
            }
        } else {
            panic!("Drives property should be an object");
        }
    } else {
        panic!("PSProvider property should be an object");
    }

    println!("Successfully parsed complex PowerShell DirectoryInfo object!");
    println!(
        "Object type: {:?}",
        complex_obj.type_def.as_ref().unwrap().type_names[0]
    );
    println!("ToString: {:?}", complex_obj.to_string);
    println!(
        "Adapted properties count: {}",
        complex_obj.adapted_properties.len()
    );
    println!(
        "Extended properties count: {}",
        complex_obj.extended_properties.len()
    );
}

#[test]
fn test_parse_real_pipeline_output_detailed_inspection() {
    // Parse the XML
    let parsed = xml::parser::parse(PIPELINE_OUTPUT).expect("Failed to parse XML");
    let root = parsed.root_element();

    // Create deserialization context
    let mut context = DeserializationContext::default();

    // Parse to PsValue
    let ps_value = PsValue::from_node_with_context(root, &mut context)
        .expect("Failed to parse XML to PsValue");

    // Print detailed structure for inspection
    match &ps_value {
        PsValue::Object(obj) => {
            println!("=== COMPLEX OBJECT STRUCTURE ===");

            if let Some(type_def) = &obj.type_def {
                println!("Type names: {:?}", type_def.type_names);
            }

            println!("ToString: {:?}", obj.to_string);

            println!("\nAdapted Properties ({}):", obj.adapted_properties.len());
            for (name, prop) in &obj.adapted_properties {
                println!("  {}: {:?}", name, classify_ps_value(&prop.value));
            }

            println!("\nExtended Properties ({}):", obj.extended_properties.len());
            for (name, prop) in &obj.extended_properties {
                println!("  {}: {:?}", name, classify_ps_value(&prop.value));
            }

            // Check if we have any container content
            match &obj.content {
                ComplexObjectContent::Standard => println!("\nContent: Standard"),
                ComplexObjectContent::ExtendedPrimitive(prim) => {
                    println!("\nContent: ExtendedPrimitive({:?})", prim)
                }
                ComplexObjectContent::Container(container) => {
                    println!("\nContent: Container({:?})", container);
                }
                ComplexObjectContent::PsEnums(enums) => {
                    println!("\nContent: Enum({})", enums.value)
                }
            }
        }
        PsValue::Primitive(prim) => {
            println!("=== PRIMITIVE VALUE ===");
            println!("{:?}", prim);
        }
    }
}

fn classify_ps_value(value: &PsValue) -> String {
    match value {
        PsValue::Primitive(prim) => format!("Primitive({:?})", prim),
        PsValue::Object(obj) => {
            let type_name = obj
                .type_def
                .as_ref()
                .and_then(|t| t.type_names.first())
                .map(|s| s.as_ref())
                .unwrap_or("Unknown");

            let content_type = match &obj.content {
                ComplexObjectContent::Standard => "Standard",
                ComplexObjectContent::ExtendedPrimitive(_) => "ExtendedPrimitive",
                ComplexObjectContent::Container(container) => match container {
                    Container::List(_) => "List",
                    Container::Dictionary(_) => "Dictionary",
                    Container::Stack(_) => "Stack",
                    Container::Queue(_) => "Queue",
                },
                ComplexObjectContent::PsEnums(_) => "Enum",
            };

            format!(
                "Object({}, content: {}, props: {}, ext_props: {})",
                type_name,
                content_type,
                obj.adapted_properties.len(),
                obj.extended_properties.len()
            )
        }
    }
}


--- File: crates/protocol-powershell-remoting/src/tests/resource/creationXml ---
AAAAAAAAAAEAAAAAAAAAAAMAAADKAgAAAAIAAQDQNGUtEmvjQLdzy6JkWc+oAAAAAAAAAAAAAAAAAAAAAO+7vzxPYmogUmVmSWQ9IjAiPjxNUz48VmVyc2lvbiBOPSJwcm90b2NvbHZlcnNpb24iPjIuMzwvVmVyc2lvbj48VmVyc2lvbiBOPSJQU1ZlcnNpb24iPjIuMDwvVmVyc2lvbj48VmVyc2lvbiBOPSJTZXJpYWxpemF0aW9uVmVyc2lvbiI+MS4xLjAuMTwvVmVyc2lvbj48L01TPjwvT2JqPgAAAAAAAAACAAAAAAAAAAADAAAO7QIAAAAEAAEA0DRlLRJr40C3c8uiZFnPqAAAAAAAAAAAAAAAAAAAAADvu788T2JqIFJlZklkPSIwIj48TVM+PEkzMiBOPSJNaW5SdW5zcGFjZXMiPjE8L0kzMj48STMyIE49Ik1heFJ1bnNwYWNlcyI+MTwvSTMyPjxPYmogTj0iUFNUaHJlYWRPcHRpb25zIiBSZWZJZD0iMSI+PFROIFJlZklkPSIwIj48VD5TeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLlJ1bnNwYWNlcy5QU1RocmVhZE9wdGlvbnM8L1Q+PFQ+U3lzdGVtLkVudW08L1Q+PFQ+U3lzdGVtLlZhbHVlVHlwZTwvVD48VD5TeXN0ZW0uT2JqZWN0PC9UPjwvVE4+PFRvU3RyaW5nPkRlZmF1bHQ8L1RvU3RyaW5nPjxJMzI+MDwvSTMyPjwvT2JqPjxPYmogTj0iQXBhcnRtZW50U3RhdGUiIFJlZklkPSIyIj48VE4gUmVmSWQ9IjEiPjxUPlN5c3RlbS5UaHJlYWRpbmcuQXBhcnRtZW50U3RhdGU8L1Q+PFQ+U3lzdGVtLkVudW08L1Q+PFQ+U3lzdGVtLlZhbHVlVHlwZTwvVD48VD5TeXN0ZW0uT2JqZWN0PC9UPjwvVE4+PFRvU3RyaW5nPlVua25vd248L1RvU3RyaW5nPjxJMzI+MjwvSTMyPjwvT2JqPjxPYmogTj0iQXBwbGljYXRpb25Bcmd1bWVudHMiIFJlZklkPSIzIj48VE4gUmVmSWQ9IjIiPjxUPlN5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uUFNQcmltaXRpdmVEaWN0aW9uYXJ5PC9UPjxUPlN5c3RlbS5Db2xsZWN0aW9ucy5IYXNodGFibGU8L1Q+PFQ+U3lzdGVtLk9iamVjdDwvVD48L1ROPjxEQ1Q+PEVuPjxTIE49IktleSI+UFNWZXJzaW9uVGFibGU8L1M+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjQiPjxUTlJlZiBSZWZJZD0iMiIgLz48RENUPjxFbj48UyBOPSJLZXkiPlBsYXRmb3JtPC9TPjxTIE49IlZhbHVlIj5XaW4zMk5UPC9TPjwvRW4+PEVuPjxTIE49IktleSI+U2VyaWFsaXphdGlvblZlcnNpb248L1M+PFZlcnNpb24gTj0iVmFsdWUiPjEuMS4wLjE8L1ZlcnNpb24+PC9Fbj48RW4+PFMgTj0iS2V5Ij5QU1ZlcnNpb248L1M+PFZlcnNpb24gTj0iVmFsdWUiPjcuNC4xMDwvVmVyc2lvbj48L0VuPjxFbj48UyBOPSJLZXkiPlBTQ29tcGF0aWJsZVZlcnNpb25zPC9TPjxPYmogTj0iVmFsdWUiIFJlZklkPSI1Ij48VE4gUmVmSWQ9IjMiPjxUPlN5c3RlbS5WZXJzaW9uW108L1Q+PFQ+U3lzdGVtLkFycmF5PC9UPjxUPlN5c3RlbS5PYmplY3Q8L1Q+PC9UTj48TFNUPjxWZXJzaW9uPjEuMDwvVmVyc2lvbj48VmVyc2lvbj4yLjA8L1ZlcnNpb24+PFZlcnNpb24+My4wPC9WZXJzaW9uPjxWZXJzaW9uPjQuMDwvVmVyc2lvbj48VmVyc2lvbj41LjA8L1ZlcnNpb24+PFZlcnNpb24+NS4xPC9WZXJzaW9uPjxWZXJzaW9uPjYuMDwvVmVyc2lvbj48VmVyc2lvbj43LjA8L1ZlcnNpb24+PC9MU1Q+PC9PYmo+PC9Fbj48RW4+PFMgTj0iS2V5Ij5XU01hblN0YWNrVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+My4wPC9WZXJzaW9uPjwvRW4+PEVuPjxTIE49IktleSI+UFNTZW1hbnRpY1ZlcnNpb248L1M+PFMgTj0iVmFsdWUiPjcuNC4xMDwvUz48L0VuPjxFbj48UyBOPSJLZXkiPlBTUmVtb3RpbmdQcm90b2NvbFZlcnNpb248L1M+PFZlcnNpb24gTj0iVmFsdWUiPjIuMzwvVmVyc2lvbj48L0VuPjxFbj48UyBOPSJLZXkiPkdpdENvbW1pdElkPC9TPjxTIE49IlZhbHVlIj43LjQuMTA8L1M+PC9Fbj48RW4+PFMgTj0iS2V5Ij5QU0VkaXRpb248L1M+PFMgTj0iVmFsdWUiPkNvcmU8L1M+PC9Fbj48RW4+PFMgTj0iS2V5Ij5PUzwvUz48UyBOPSJWYWx1ZSI+TWljcm9zb2Z0IFdpbmRvd3MgMTAuMC4yMjYzMTwvUz48L0VuPjwvRENUPjwvT2JqPjwvRW4+PC9EQ1Q+PC9PYmo+PE9iaiBOPSJIb3N0SW5mbyIgUmVmSWQ9IjYiPjxNUz48QiBOPSJfaXNIb3N0VUlOdWxsIj5mYWxzZTwvQj48QiBOPSJfaXNIb3N0UmF3VUlOdWxsIj5mYWxzZTwvQj48QiBOPSJfaXNIb3N0TnVsbCI+ZmFsc2U8L0I+PE9iaiBOPSJfaG9zdERlZmF1bHREYXRhIiBSZWZJZD0iNyI+PE1TPjxPYmogTj0iZGF0YSIgUmVmSWQ9IjgiPjxUTiBSZWZJZD0iNCI+PFQ+U3lzdGVtLkNvbGxlY3Rpb25zLkhhc2h0YWJsZTwvVD48VD5TeXN0ZW0uT2JqZWN0PC9UPjwvVE4+PERDVD48RW4+PEkzMiBOPSJLZXkiPjk8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iOSI+PE1TPjxTIE49IlQiPlN5c3RlbS5TdHJpbmc8L1M+PFMgTj0iViI+UG93ZXJTaGVsbDwvUz48L01TPjwvT2JqPjwvRW4+PEVuPjxJMzIgTj0iS2V5Ij44PC9JMzI+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjEwIj48TVM+PFMgTj0iVCI+U3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5Ib3N0LlNpemU8L1M+PE9iaiBOPSJWIiBSZWZJZD0iMTEiPjxNUz48STMyIE49IndpZHRoIj4zODI0PC9JMzI+PEkzMiBOPSJoZWlnaHQiPjIxMjE8L0kzMj48L01TPjwvT2JqPjwvTVM+PC9PYmo+PC9Fbj48RW4+PEkzMiBOPSJLZXkiPjc8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iMTIiPjxNUz48UyBOPSJUIj5TeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLkhvc3QuU2l6ZTwvUz48T2JqIE49IlYiIFJlZklkPSIxMyI+PE1TPjxJMzIgTj0id2lkdGgiPjEyMDwvSTMyPjxJMzIgTj0iaGVpZ2h0Ij4zMDwvSTMyPjwvTVM+PC9PYmo+PC9NUz48L09iaj48L0VuPjxFbj48STMyIE49IktleSI+NjwvSTMyPjxPYmogTj0iVmFsdWUiIFJlZklkPSIxNCI+PE1TPjxTIE49IlQiPlN5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uSG9zdC5TaXplPC9TPjxPYmogTj0iViIgUmVmSWQ9IjE1Ij48TVM+PEkzMiBOPSJ3aWR0aCI+MTIwPC9JMzI+PEkzMiBOPSJoZWlnaHQiPjMwPC9JMzI+PC9NUz48L09iaj48L01TPjwvT2JqPjwvRW4+PEVuPjxJMzIgTj0iS2V5Ij41PC9JMzI+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjE2Ij48TVM+PFMgTj0iVCI+U3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5Ib3N0LlNpemU8L1M+PE9iaiBOPSJWIiBSZWZJZD0iMTciPjxNUz48STMyIE49IndpZHRoIj4xMjA8L0kzMj48STMyIE49ImhlaWdodCI+MzA8L0kzMj48L01TPjwvT2JqPjwvTVM+PC9PYmo+PC9Fbj48RW4+PEkzMiBOPSJLZXkiPjQ8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iMTgiPjxNUz48UyBOPSJUIj5TeXN0ZW0uSW50MzI8L1M+PEkzMiBOPSJWIj4yNTwvSTMyPjwvTVM+PC9PYmo+PC9Fbj48RW4+PEkzMiBOPSJLZXkiPjM8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iMTkiPjxNUz48UyBOPSJUIj5TeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLkhvc3QuQ29vcmRpbmF0ZXM8L1M+PE9iaiBOPSJWIiBSZWZJZD0iMjAiPjxNUz48STMyIE49IngiPjA8L0kzMj48STMyIE49InkiPjA8L0kzMj48L01TPjwvT2JqPjwvTVM+PC9PYmo+PC9Fbj48RW4+PEkzMiBOPSJLZXkiPjI8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iMjEiPjxNUz48UyBOPSJUIj5TeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLkhvc3QuQ29vcmRpbmF0ZXM8L1M+PE9iaiBOPSJWIiBSZWZJZD0iMjIiPjxNUz48STMyIE49IngiPjA8L0kzMj48STMyIE49InkiPjI3PC9JMzI+PC9NUz48L09iaj48L01TPjwvT2JqPjwvRW4+PEVuPjxJMzIgTj0iS2V5Ij4xPC9JMzI+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjIzIj48TVM+PFMgTj0iVCI+U3lzdGVtLkNvbnNvbGVDb2xvcjwvUz48STMyIE49IlYiPjA8L0kzMj48L01TPjwvT2JqPjwvRW4+PEVuPjxJMzIgTj0iS2V5Ij4wPC9JMzI+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjI0Ij48TVM+PFMgTj0iVCI+U3lzdGVtLkNvbnNvbGVDb2xvcjwvUz48STMyIE49IlYiPjc8L0kzMj48L01TPjwvT2JqPjwvRW4+PC9EQ1Q+PC9PYmo+PC9NUz48L09iaj48QiBOPSJfdXNlUnVuc3BhY2VIb3N0Ij5mYWxzZTwvQj48L01TPjwvT2JqPjwvTVM+PC9PYmo+

--- File: crates/protocol-winrm/Cargo.toml ---
[package]
name = "protocol-winrm"
version = "0.1.0"
edition = "2024"

[dependencies]
hyper = { version = "1.6.0", features = ["http2"] }
thiserror = "2.0.12"
tracing = "0.1.41"
tracing-subscriber = "0.3.19"
typed-builder = "0.21.0"
xml = { path = "../xml" }
protocol-macros = { path = "../protocol-macros" }
byteorder = "1.5.0"
base64 = "0.22.1"
paste = "1.0.15"
uuid = { version = "1.0", features = ["v4"] }

[dev-dependencies]
tracing-test =  {version = "0.2.4", features = ["no-env-filter"] }


--- File: crates/protocol-winrm/src/cores/anytag.rs ---
use xml::parser::{XmlDeserialize, XmlVisitor};

use crate::{
    cores::{Tag, TagList, TagName, tag_name::*, tag_value::Text},
    rsp::{receive::ReceiveValue, rsp::ShellValue},
};

#[macro_export]
macro_rules! define_any_tag {
    ($enum_name:ident, $visitor_name:ident, $(($variant:ident, $tag_name:ty, $tag_type:ty)),* $(,)?) => {
        #[derive(Debug, Clone)]
        pub enum $enum_name<'a> {
            $($variant($tag_type),)*
        }

        $(
            impl<'a> std::convert::TryInto<$tag_type> for AnyTag<'a> {
                type Error = xml::XmlError;

                fn try_into(self) -> Result<$tag_type, Self::Error> {
                    match self {
                        $enum_name::$variant(tag) => Ok(tag),
                        _ => Err(xml::XmlError::InvalidXml(format!(
                            "Cannot convert {:?} to any tag type",
                            self
                        ))),
                    }
                }
            }

            impl<'a> std::convert::From<$tag_type> for $enum_name<'a> {
                fn from(tag: $tag_type) -> Self {
                    $enum_name::$variant(tag)
                }
            }
        )*


        impl<'a> $enum_name<'a> {
            pub fn into_element(self) -> xml::builder::Element<'a> {
                match self {
                    $($enum_name::$variant(tag) => tag.into_element(),)*
                }
            }
        }

        pub struct $visitor_name<'a> {
            tag: Option<$enum_name<'a>>,
        }

        impl<'a> XmlVisitor<'a> for $visitor_name<'a> {
            type Value = $enum_name<'a>;

            fn visit_children(
                &mut self,
                node: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
            ) -> Result<(), xml::XmlError> {
                Err(xml::XmlError::InvalidXml(format!(
                    "Expected a single tag, found {} children",
                    node.count()
                )))
            }

            fn visit_node(&mut self, node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
                match node.tag_name().name() {
                    $(
                        <$tag_name>::TAG_NAME => {
                            let tag = <$tag_type>::from_node(node)?;
                            self.tag = Some($enum_name::$variant(tag));
                        }
                    )*
                    _ => {
                        return Err(xml::XmlError::InvalidXml(format!(
                            "Unknown tag: {}",
                            node.tag_name().name()
                        )));
                    }
                };

                Ok(())
            }

            fn finish(self) -> Result<Self::Value, xml::XmlError> {
                self.tag
                    .ok_or(xml::XmlError::InvalidXml("No valid tag found".to_string()))
            }
        }

        impl<'a> XmlDeserialize<'a> for $enum_name<'a> {
            type Visitor = $visitor_name<'a>;

            fn visitor() -> Self::Visitor {
                $visitor_name { tag: None }
            }

            fn from_node(node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
                xml::parser::NodeDeserializer::new(node).deserialize(Self::visitor())
            }
        }
    };
}

// Define the `AnyTag` enum for the following purposes:
// Right now, since we are having all tag and tag name definations defined in compile time (i.e Sized, no dynamic trait objects),
// Hence, for the purpose of having a dynamic representation of any tag, we define `AnyTag`.
// This will allow us to have a single enum that can represent any tag type, which can be useful for generic processing of XML documents.
// while perserving the compile-time safety of tag definitions.
define_any_tag!(
    AnyTag,
    AnyTagVisitor,
    // SOAP elements
    (Envelope, Envelope, Tag<'a, TagList<'a>, Envelope>),
    (Header, Header, Tag<'a, TagList<'a>, Header>),
    (Body, Body, Tag<'a, TagList<'a>, Body>),
    // WS-Addressing headers
    (Action, Action, Tag<'a, Text<'a>, Action>),
    (To, To, Tag<'a, Text<'a>, To>),
    (MessageID, MessageID, Tag<'a, Text<'a>, MessageID>),
    (RelatesTo, RelatesTo, Tag<'a, Text<'a>, RelatesTo>),
    (ReplyTo, ReplyTo, Tag<'a, TagList<'a>, ReplyTo>),
    (FaultTo, FaultTo, Tag<'a, Text<'a>, FaultTo>),
    (From, From, Tag<'a, Text<'a>, From>),
    (Address, Address, Tag<'a, Text<'a>, Address>),
    // PowerShell remoting shell elements
    (ShellId, ShellId, Tag<'a, Text<'a>, ShellId>),
    (Shell, Shell, Tag<'a, ShellValue<'a>, Shell>),
    (Receive, Receive, Tag<'a, ReceiveValue<'a>, Receive>),
    (Name, Name, Tag<'a, Text<'a>, Name>),
    (ResourceUri, ResourceUri, Tag<'a, Text<'a>, ResourceUri>),
    (Owner, Owner, Tag<'a, Text<'a>, Owner>),
    (ClientIP, ClientIP, Tag<'a, Text<'a>, ClientIP>),
    (ProcessId, ProcessId, Tag<'a, Text<'a>, ProcessId>),
    (IdleTimeOut, IdleTimeOut, Tag<'a, Text<'a>, IdleTimeOut>),
    (InputStreams, InputStreams, Tag<'a, Text<'a>, InputStreams>),
    (
        OutputStreams,
        OutputStreams,
        Tag<'a, Text<'a>, OutputStreams>
    ),
    (
        MaxIdleTimeOut,
        MaxIdleTimeOut,
        Tag<'a, Text<'a>, MaxIdleTimeOut>
    ),
    (Locale, Locale, Tag<'a, Text<'a>, Locale>),
    (DataLocale, DataLocale, Tag<'a, Text<'a>, DataLocale>),
    (
        CompressionMode,
        CompressionMode,
        Tag<'a, Text<'a>, CompressionMode>
    ),
    (
        ProfileLoaded,
        ProfileLoaded,
        Tag<'a, Text<'a>, ProfileLoaded>
    ),
    (Encoding, Encoding, Tag<'a, Text<'a>, Encoding>),
    (BufferMode, BufferMode, Tag<'a, Text<'a>, BufferMode>),
    (State, State, Tag<'a, Text<'a>, State>),
    (ShellRunTime, ShellRunTime, Tag<'a, Text<'a>, ShellRunTime>),
    (
        ShellInactivity,
        ShellInactivity,
        Tag<'a, Text<'a>, ShellInactivity>
    ),
    (CreationXml, CreationXml, Tag<'a, TagList<'a>, CreationXml>),
    (Version, Version, Tag<'a, Text<'a>, Version>),
    (BA, BA, Tag<'a, Text<'a>, BA>),
    // PowerShell Serialization Format
    (I32TagName, I32TagName, Tag<'a, Text<'a>, I32TagName>), // 32-bit integer
    (TN, TN, Tag<'a, TagList<'a>, TN>),
    (T, T, Tag<'a, Text<'a>, T>),
    (ToString, ToString, Tag<'a, Text<'a>, ToString>),
    (DCT, DCT, Tag<'a, TagList<'a>, DCT>),
    (En, En, Tag<'a, TagList<'a>, En>),
    (Key, Key, Tag<'a, Text<'a>, Key>),
    (Value, Value, Tag<'a, Text<'a>, Value>),
    (Nil, Nil, Tag<'a, Text<'a>, Nil>),
    (B, B, Tag<'a, Text<'a>, B>),
    (S, S, Tag<'a, Text<'a>, S>),
    // Complex objects
    (Obj, Obj, Tag<'a, TagList<'a>, Obj>),
    (MS, MS, Tag<'a, TagList<'a>, MS>),
);


--- File: crates/protocol-winrm/src/cores/attribute.rs ---
use std::borrow::Cow;

use uuid::Uuid;

// Macro that ensures compile-time safety by generating all the boilerplate
macro_rules! define_attributes {
    (
        $(
            $variant:ident($type:ty) => ($namespace:expr, $attr_name:literal), $parser:expr, $serializer:expr
        ),* $(,)?
    ) => {
        #[derive(Debug, Clone)]
        pub enum Attribute<'a> {
            $(
                $variant($type),
            )*
        }

        impl<'a> Attribute<'a> {
            /// Convert an attribute name to the corresponding enum variant type
            /// This is automatically generated to match all enum variants
            fn from_name_and_value(name: &str, value: &'a str) -> Result<Option<Self>, xml::XmlError> {
                match name {
                    $(
                        $attr_name => {
                            match $parser(value) {
                                Ok(val) => Ok(Some(Attribute::$variant(val))),
                                Err(e) => Err(xml::XmlError::InvalidXml(
                                    format!("Invalid value for {}: {}", $attr_name, e)
                                )),
                            }
                        }
                    )*
                    _ => Ok(None), // Unknown attribute, ignore
                }
            }

            /// Get the attribute name for this enum variant
            /// This is automatically generated to be exhaustive
            pub fn attribute_name(&self) -> &'static str {
                match self {
                    $(
                        Attribute::$variant(_) => $attr_name,
                    )*
                }
            }

            /// Get the namespace for this enum variant
            /// This is automatically generated to be exhaustive
            pub fn namespace(&self) -> Option<crate::cores::namespace::Namespace> {
                match self {
                    $(
                        Attribute::$variant(_) => $namespace,
                    )*
                }
            }
        }

        impl<'a> From<Attribute<'a>> for xml::builder::Attribute<'a> {
            fn from(val: Attribute<'a>) -> Self {
                let namespace = val.namespace().map(|ns| {
                    let (uri, _alias) = ns.as_tuple();
                    xml::builder::Namespace::new(uri)
                });

                match val {
                    $(
                        Attribute::$variant(value) => {
                            let serialized_value = $serializer(value);
                            let attr = xml::builder::Attribute::new($attr_name, Cow::Owned(serialized_value));
                            if let Some(ns) = namespace {
                                attr.set_namespace(ns)
                            } else {
                                attr
                            }
                        }
                    )*
                }
            }
        }

    };
}

// Define all attributes here - adding a new one automatically updates ALL related code
define_attributes!(
    MustUnderstand(bool) => (Some(crate::cores::namespace::Namespace::SoapEnvelope2003), "mustUnderstand"),
        |v: &str| v.parse::<bool>().map_err(|e| e.to_string()),
        |v: bool| v.to_string(),
    Name(Cow<'a, str>) => (None, "Name"),
        |v: &str| -> Result<Cow<'a, str>, String> { Ok(Cow::Owned(v.to_string())) },
        |v: Cow<'a, str>| v.into_owned(),
    MustComply(bool) => (None, "MustComply"),
        |v: &str| v.parse::<bool>().map_err(|e| e.to_string()),
        |v: bool| v.to_string(),
    ShellId(Cow<'a, str>) => (None, "ShellId"),
        |v: &str| -> Result<Cow<'a, str>, String> { Ok(Cow::Owned(v.to_string())) },
        |v: Cow<'a, str>| v.into_owned(),
    RefId(Cow<'a, str>) => (None, "RefId"),
        |v: &str| -> Result<Cow<'a, str>, String> { Ok(Cow::Owned(v.to_string())) },
        |v: Cow<'a, str>| v.into_owned(),
    N(Cow<'a, str>) => (None, "N"),
        |v: &str| -> Result<Cow<'a, str>, String> { Ok(Cow::Owned(v.to_string())) },
        |v: Cow<'a, str>| v.into_owned(),
    XmlLang(Cow<'a, str>) => (None, "xml:lang"),
        |v: &str| -> Result<Cow<'a, str>, String> { Ok(Cow::Owned(v.to_string())) },
        |v: Cow<'a, str>| v.into_owned(),
    CommandId(Uuid) => (None, "CommandId"),
        |v: &str| -> Result<Uuid, String> {
            Uuid::parse_str(v).map_err(|e| e.to_string())
        },
        |v: Uuid| v.to_string().to_uppercase(),
    State(Cow<'a, str>) => (None, "State"),
        |v: &str| -> Result<Cow<'a, str>, String> { Ok(Cow::Owned(v.to_string())) },
        |v: Cow<'a, str>| v.into_owned(),
    End(bool) => (None, "End"),
        |v: &str| v.parse::<bool>().map_err(|e| e.to_string()),
        |v: bool| v.to_string(),
    Unit(Cow<'a, str>) => (None, "Unit"),
        |v: &str| -> Result<Cow<'a, str>, String> { Ok(Cow::Owned(v.to_string())) },
        |v: Cow<'a, str>| v.into_owned(),
    EndUnit(bool) => (None, "EndUnit"),
        |v: &str| v.parse::<bool>().map_err(|e| e.to_string()),
        |v: bool| v.to_string(),
    SequenceID(u64) => (None, "SequenceID"),
        |v: &str| v.parse::<u64>().map_err(|e| e.to_string()),
        |v: u64| v.to_string(),
    // Add new attributes here and they automatically get handled everywhere!
);

pub struct AttributeVisitor<'a> {
    attribute: Option<Attribute<'a>>,
}

impl<'a> xml::parser::XmlVisitor<'a> for AttributeVisitor<'a> {
    type Value = Attribute<'a>;

    fn visit_attribute(
        &mut self,
        _attribute: xml::parser::Attribute<'a, 'a>,
    ) -> Result<(), xml::XmlError> {
        Attribute::from_name_and_value(_attribute.name(), _attribute.value())
            .map(|attr| {
                if let Some(parsed_attr) = attr {
                    self.attribute = Some(parsed_attr);
                }
            })
            .map_err(|e| xml::XmlError::InvalidXml(e.to_string()))
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        self.attribute
            .ok_or(xml::XmlError::InvalidXml("No attribute found".to_string()))
    }
}

impl<'a> xml::parser::XmlDeserialize<'a> for Attribute<'a> {
    type Visitor = AttributeVisitor<'a>;

    fn visitor() -> Self::Visitor {
        AttributeVisitor { attribute: None }
    }

    fn from_node(_node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
        Err(xml::XmlError::InvalidXml(
            "Attributes should not be parsed from nodes directly".to_string(),
        ))
    }

    fn from_children(
        _children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<Self, xml::XmlError> {
        Err(xml::XmlError::InvalidXml(
            "Attributes should not be parsed from children directly".to_string(),
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compile_time_exhaustiveness() {
        // This test demonstrates that the macro generates exhaustive matches
        let attrs = vec![
            Attribute::MustUnderstand(true),
            Attribute::Name(Cow::Borrowed("test")),
            Attribute::MustComply(false),
            // If you add a new variant, the macro will automatically handle it
        ];

        for attr in attrs {
            let _name = attr.attribute_name();
            let _xml_attr: xml::builder::Attribute = attr.clone().into();
        }
    }

    #[test]
    fn test_parsing_round_trip() {
        let test_cases = [
            ("mustUnderstand", "true"),
            ("Name", "test-name"),
            ("MustComply", "false"),
        ];

        for (attr_name, attr_value) in test_cases {
            if let Some(parsed) = Attribute::from_name_and_value(attr_name, attr_value).unwrap() {
                // Test that we can get the name back
                assert_eq!(parsed.attribute_name(), attr_name);

                // Test round trip to XML attribute
                let _xml_attr: xml::builder::Attribute = parsed.into();
            }
        }
    }
}


--- File: crates/protocol-winrm/src/cores/mod.rs ---
pub mod anytag;
pub mod attribute;
pub mod namespace;
pub mod tag;
pub mod tag_list;
pub mod tag_name;
pub mod tag_value;

pub use attribute::*;
pub use namespace::*;
pub use tag::*;
pub use tag_list::*;
pub use tag_name::*;
pub use tag_value::*;


--- File: crates/protocol-winrm/src/cores/namespace.rs ---
use std::fmt::Debug;

// -----------------------------------------------------------------------------
//                               THE MACRO
// -----------------------------------------------------------------------------
#[macro_export]
macro_rules! define_namespaces {
    // public interface ────────────────────────────────────────────────────────
    ( $( $variant:ident => { alias: $alias:expr, uri: $uri:expr } ),+ $(,)? ) => {
        // ---------- enum -----------------------------------------------------
        #[derive(Debug, Clone, Eq, PartialEq)]
        pub enum Namespace {
            $( $variant, )+
        }

        // ---------- core helpers --------------------------------------------
        impl Namespace {
            /// `(uri, alias)`
            #[inline]
            pub const fn as_tuple(&self) -> (&'static str, Option<&'static str>) {
                match self {
                    $( Self::$variant => ($uri, $alias), )+
                }
            }

            #[inline] pub const fn uri(&self)   -> &'static str         { self.as_tuple().0 }
            #[inline] pub const fn alias(&self) -> Option<&'static str> { self.as_tuple().1 }
        }

        // ---------- conversions ---------------------------------------------
        impl TryFrom<&str> for Namespace {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                match value {
                    $( $uri => Ok(Self::$variant), )+
                    _ => Err("Unknown namespace"),
                }
            }
        }

        impl<'a> TryFrom<&xml::parser::Namespace<'a>> for Namespace {
            type Error = &'static str;
            #[inline]
            fn try_from(ns: &xml::parser::Namespace<'a>) -> Result<Self, Self::Error> {
                Self::try_from(ns.uri())
            }
        }

        // ---------- XmlDeserialize support -----------------------------------
        pub struct NamespaceVisitor { namespace: Option<Namespace> }

        impl<'a> xml::parser::XmlVisitor<'a> for NamespaceVisitor {
            type Value = Namespace;

            fn visit_children(
                &mut self,
                _children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
            ) -> Result<(), xml::XmlError> { Ok(()) }

            fn visit_node(
                &mut self,
                node: xml::parser::Node<'a, 'a>,
            ) -> Result<(), xml::XmlError> {
                let Some(ns) = node.tag_name().namespace() else {
                    return Err(xml::XmlError::InvalidXml("No namespace found".into()));
                };
                self.namespace = Some(
                    Namespace::try_from(ns)
                        .map_err(|_| xml::XmlError::InvalidXml(format!("Unknown namespace: {ns}")))?,
                );
                Ok(())
            }

            fn finish(self) -> Result<Self::Value, xml::XmlError> {
                self.namespace.ok_or_else(|| xml::XmlError::InvalidXml("No namespace found".into()))
            }
        }

        impl<'a> xml::parser::XmlDeserialize<'a> for Namespace {
            type Visitor = NamespaceVisitor;
            #[inline] fn visitor() -> Self::Visitor { NamespaceVisitor { namespace: None } }
        }
    };
}

// -----------------------------------------------------------------------------
//                           MACRO INVOCATION
// -----------------------------------------------------------------------------
define_namespaces! {
    WsmanShell        => { alias: Some("rsp") , uri: "http://schemas.microsoft.com/wbem/wsman/1/windows/shell" },
    WsAddressing2004  => { alias: Some("a")   , uri: "http://schemas.xmlsoap.org/ws/2004/08/addressing" },
    SoapEnvelope2003  => { alias: Some("s")   , uri: "http://www.w3.org/2003/05/soap-envelope" },
    MsWsmanSchema     => { alias: Some("p")   , uri: "http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd" },
    DmtfWsmanSchema   => { alias: Some("w")   , uri: "http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd" },
    WsTransfer2004    => { alias: Some("x")   , uri: "http://schemas.xmlsoap.org/ws/2004/09/transfer" },
    PowerShellRemoting=> { alias: None        , uri: "http://schemas.microsoft.com/powershell" },
    XmlSchemaInstance => { alias: Some("xsi") , uri: "http://www.w3.org/2001/XMLSchema-instance" },
}

// -----------------------------------------------------------------------------
//                   OPTIONAL GROUPING / DECLARATION TYPES
// -----------------------------------------------------------------------------
#[derive(Debug, Clone)]
pub struct NamespaceDeclaration(Vec<Namespace>);

impl Default for NamespaceDeclaration {
    fn default() -> Self {
        Self::new()
    }
}
impl NamespaceDeclaration {
    pub fn new() -> Self {
        Self(Vec::new())
    }
    pub fn namespaces(&self) -> &[Namespace] {
        &self.0
    }
    pub fn push(&mut self, ns: Namespace) {
        self.0.push(ns);
    }
}
impl IntoIterator for NamespaceDeclaration {
    type Item = Namespace;
    type IntoIter = std::vec::IntoIter<Namespace>;
    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

pub struct NamespaceDeclarationVisitor {
    namespaces: Vec<Namespace>,
}

impl<'a> xml::parser::XmlVisitor<'a> for NamespaceDeclarationVisitor {
    type Value = NamespaceDeclaration;

    fn visit_children(
        &mut self,
        _c: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        Ok(())
    }

    fn visit_node(&mut self, node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
        for ns in node.namespaces() {
            self.namespaces
                .push(Namespace::try_from(ns).map_err(|_| {
                    xml::XmlError::InvalidXml(format!("Unknown namespace: {ns:?}"))
                })?);
        }
        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        Ok(NamespaceDeclaration(self.namespaces))
    }
}

impl<'a> xml::parser::XmlDeserialize<'a> for NamespaceDeclaration {
    type Visitor = NamespaceDeclarationVisitor;
    #[inline]
    fn visitor() -> Self::Visitor {
        NamespaceDeclarationVisitor {
            namespaces: Vec::new(),
        }
    }
    fn from_node(node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
        xml::parser::NodeDeserializer::new(node).deserialize(Self::visitor())
    }
}


--- File: crates/protocol-winrm/src/cores/tag.rs ---
use tracing::{debug, trace, warn};
use xml::builder::Element;
use xml::parser::{XmlDeserialize, XmlVisitor};

use crate::cores::namespace::NamespaceDeclaration;
use crate::cores::tag_value::{Text, U32};
use crate::cores::{Namespace, WsUuid};
use crate::impl_tag_from;

use super::attribute::Attribute;
use super::tag_name::TagName;
use super::tag_value::TagValue;

#[derive(Debug, Clone)]
pub struct Tag<'a, V, N>
where
    V: TagValue<'a>,
    N: TagName,
{
    pub value: V,
    pub attributes: Vec<Attribute<'a>>,
    /// The namespaces are the declaration of namespaces used in this tag.
    /// For example
    /// <s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
    /// would have a namespace declaration for "s" with the URI "http://schemas.xmlsoap.org/soap/envelope/".
    pub namespaces_declaration: NamespaceDeclaration,

    __phantom: std::marker::PhantomData<&'a V>,
    __phantom_name: std::marker::PhantomData<N>,
}

pub struct TagNameHolder<'a, N, V>
where
    N: TagName,
    V: TagValue<'a>,
{
    name: N,
    attributes: Option<Vec<Attribute<'a>>>,
    namespaces_declaration: NamespaceDeclaration,
    __phantom: std::marker::PhantomData<&'a V>,
}

impl<'a, N, V> TagNameHolder<'a, N, V>
where
    N: TagName,
    V: TagValue<'a>,
{
    pub fn with_value(self, value: V) -> Tag<'a, V, N> {
        let mut tag = Tag::new(value).with_name(self.name);

        if let Some(attrs) = self.attributes {
            for attr in attrs {
                tag = tag.with_attribute(attr);
            }
        }

        for declaration in self.namespaces_declaration {
            tag = tag.with_declaration(declaration);
        }

        tag
    }

    pub fn with_attribute(mut self, attribute: Attribute<'a>) -> Self {
        if let Some(ref mut attrs) = self.attributes {
            attrs.push(attribute);
        } else {
            self.attributes = Some(vec![attribute]);
        }
        self
    }

    pub fn with_declaration(mut self, declaration: Namespace) -> Self {
        self.namespaces_declaration.push(declaration);
        self
    }
}

impl<'a, V, N> Tag<'a, V, N>
where
    V: TagValue<'a>,
    N: TagName,
{
    pub fn new(value: impl Into<V>) -> Self {
        Self {
            value: value.into(),
            attributes: Vec::new(),
            namespaces_declaration: NamespaceDeclaration::new(),
            __phantom: std::marker::PhantomData,
            __phantom_name: std::marker::PhantomData,
        }
    }

    pub fn from_name(name: N) -> TagNameHolder<'a, N, V>
    where
        N: TagName,
    {
        TagNameHolder {
            name,
            attributes: None,
            namespaces_declaration: NamespaceDeclaration::new(),
            __phantom: std::marker::PhantomData,
        }
    }

    /// Does not do anything, just returns self.
    /// This is useful for compiler to infer the type of `N` when using `Tag::new`.
    pub fn with_name(self, _name: N) -> Self {
        self
    }

    pub fn with_attribute(mut self, attribute: Attribute<'a>) -> Self {
        self.attributes.push(attribute);
        self
    }

    pub fn with_declaration(mut self, declaration: Namespace) -> Self {
        self.namespaces_declaration.push(declaration);
        self
    }

    pub fn into_element(self) -> Element<'a> {
        let mut element = Element::new(N::TAG_NAME);
        if let Some(ns) = N::NAMESPACE {
            element = element.set_namespace(ns);
        }

        // Add namespace declarations to the element
        for namespace in self.namespaces_declaration.namespaces() {
            let (url, alias) = namespace.as_tuple();
            element = element.add_namespace_declaration(url, alias);
        }

        for attribute in self.attributes {
            element = element.add_attribute(attribute.into());
        }

        self.value.append_to_element(element)
    }

    pub fn name(&self) -> &'static str {
        N::TAG_NAME
    }

    pub fn clone_value(&self) -> V
    where
        V: Clone,
    {
        self.value.clone()
    }
}

impl<'a, V, N> From<V> for Tag<'a, V, N>
where
    V: TagValue<'a>,
    N: TagName + 'a,
{
    fn from(value: V) -> Self {
        Tag::new(value)
    }
}

pub struct TagVisitor<'a, V, N>
where
    V: TagValue<'a>,
    N: TagName,
{
    pub tag: Option<V>,
    pub attributes: Vec<Attribute<'a>>,
    pub namespaces: NamespaceDeclaration,
    pub namespace: Option<Namespace>,
    __phantom: std::marker::PhantomData<&'a N>,
}

pub struct NodeDeserializer<'a> {
    root: xml::parser::Node<'a, 'a>,
}

impl<'a> NodeDeserializer<'a> {
    pub fn new(root: xml::parser::Node<'a, 'a>) -> Self {
        Self { root }
    }

    /// Drive any visitor over the subtree rooted at `self.root`
    pub fn deserialize<V>(self, mut visitor: V) -> Result<V::Value, xml::XmlError>
    where
        V: XmlVisitor<'a>,
    {
        visitor.visit_node(self.root)?;
        visitor.finish()
    }
}

impl<'a, V, N> XmlVisitor<'a> for TagVisitor<'a, V, N>
where
    V: TagValue<'a> + 'a + XmlDeserialize<'a>,
    N: TagName,
{
    type Value = Tag<'a, V, N>;

    fn visit_node(&mut self, node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
        trace!(
            expected_tag_name = N::TAG_NAME,
            actual_tag_name = node.tag_name().name(),
            namespace = ?node.tag_name().namespace(),
            "TagVisitor visiting node",
        );

        if node.is_element() && node.tag_name().name() == N::TAG_NAME {
            let value =
                V::from_children(node.children().filter(|c| c.is_element() || c.is_text()))?;
            self.tag = Some(value);
            trace!(tag_name = N::TAG_NAME, "Successfully created tag value");
        } else {
            warn!(
                actual_tag_name = node.tag_name().name(),
                expected_tag_name = N::TAG_NAME,
                "Tag name doesn't match or node is not an element"
            );
        }

        for attr in node.attributes() {
            trace!(
                name = attr.name(),
                value = attr.value(),
                "Processing attribute"
            );
            if let Ok(attribute) = Attribute::from_attribute(attr) {
                trace!("Successfully parsed attribute: {:?}", attribute);
                self.attributes.push(attribute);
            } else {
                debug!("Failed to parse attribute: {}", attr.name());
            }
        }

        self.namespaces = NamespaceDeclaration::from_node(node)?;

        self.namespace = Namespace::from_node(node).ok();

        Ok(())
    }

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        for child in children {
            if child.is_element()
                && child.tag_name().name() == N::TAG_NAME
                && child.tag_name().namespace() == N::NAMESPACE
            {
                debug!("Visiting child node: {}", child.tag_name().name());
                self.visit_node(child)?;
            } else {
                warn!(
                    "Skipping child node: {} (namespace: {:?})",
                    child.tag_name().name(),
                    child.tag_name().namespace()
                );

                return Err(xml::XmlError::InvalidXml(format!(
                    "Unexpected child node: {} (namespace: {:?})",
                    child.tag_name().name(),
                    child.tag_name().namespace()
                )));
            }
        }

        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        self.tag
            .map(|value| Tag {
                value,
                attributes: self.attributes,
                namespaces_declaration: self.namespaces,
                __phantom: std::marker::PhantomData,
                __phantom_name: std::marker::PhantomData,
            })
            .ok_or(xml::XmlError::InvalidXml(format!(
                "Tag visitor cannot built for tag: {}",
                N::TAG_NAME
            )))
    }
}

impl<'a, V, N> XmlDeserialize<'a> for Tag<'a, V, N>
where
    V: TagValue<'a> + XmlDeserialize<'a>,
    N: TagName + 'a,
{
    type Visitor = TagVisitor<'a, V, N>;

    fn visitor() -> Self::Visitor {
        TagVisitor {
            tag: None,
            attributes: Vec::new(),
            namespaces: NamespaceDeclaration::new(),
            namespace: None,
            __phantom: std::marker::PhantomData,
        }
    }

    fn from_node(node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
        NodeDeserializer::new(node).deserialize(Self::visitor())
    }
}

impl<'a, V, N> AsRef<V> for Tag<'a, V, N>
where
    V: TagValue<'a>,
    N: TagName,
{
    fn as_ref(&self) -> &V {
        &self.value
    }
}

impl<'a, V, N> From<Tag<'a, V, N>> for Element<'a>
where
    V: TagValue<'a>,
    N: TagName,
{
    fn from(val: Tag<'a, V, N>) -> Self {
        val.into_element()
    }
}

impl<'a, V, N> TagValue<'a> for Tag<'a, V, N>
where
    V: TagValue<'a>,
    N: TagName,
{
    fn append_to_element(self, element: Element<'a>) -> Element<'a> {
        let inner_element = self.into_element();
        element.add_child(inner_element)
    }
}

impl_tag_from!(&'a str => Tag<'a, Text<'a>, N>);
impl_tag_from!(String => Tag<'a, Text<'a>, N>);
impl_tag_from!(u32 => Tag<'a, U32, N>);
impl_tag_from!(uuid::Uuid => Tag<'a, WsUuid, N>);


--- File: crates/protocol-winrm/src/cores/tag_list.rs ---
use xml::{
    builder::Element,
    parser::{XmlDeserialize, XmlVisitor},
};

use crate::cores::{TagValue, anytag::AnyTag};

#[derive(Debug, Clone)]
pub struct TagList<'a> {
    items: Vec<crate::cores::anytag::AnyTag<'a>>,
}

impl<'a> Default for TagList<'a> {
    fn default() -> Self {
        Self::new()
    }
}

impl<'a> TagList<'a> {
    pub fn new() -> Self {
        Self { items: Vec::new() }
    }

    pub fn add_tag(&mut self, tag: AnyTag<'a>) {
        self.items.push(tag);
    }

    pub fn with_tag(mut self, tag: AnyTag<'a>) -> Self {
        self.add_tag(tag);
        self
    }

    pub fn into_iter(self) -> impl Iterator<Item = AnyTag<'a>> {
        self.items.into_iter()
    }
}

impl<'a> TagValue<'a> for TagList<'a> {
    fn append_to_element(self, element: Element<'a>) -> Element<'a> {
        element.add_children(
            self.items
                .into_iter()
                .map(|tag| tag.into_element())
                .collect(),
        )
    }
}

pub struct TagListVisitor<'a> {
    items: Vec<AnyTag<'a>>,
}

impl<'a> XmlVisitor<'a> for TagListVisitor<'a> {
    type Value = TagList<'a>;

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        for child in children {
            if child.is_element() {
                let tag = AnyTag::from_node(child)?;
                self.items.push(tag);
            } else {
                return Err(xml::XmlError::InvalidXml(format!(
                    "Expected element child, found: {:?}",
                    child.node_type()
                )));
            }
        }
        Ok(())
    }

    fn visit_node(&mut self, _node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
        Err(xml::XmlError::InvalidXml(
            "TagListVisitor should not be called with a single node".to_string(),
        ))
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        Ok(TagList { items: self.items })
    }
}

impl<'a> XmlDeserialize<'a> for TagList<'a> {
    type Visitor = TagListVisitor<'a>;

    fn visitor() -> Self::Visitor {
        TagListVisitor { items: Vec::new() }
    }
}


--- File: crates/protocol-winrm/src/cores/tag_name.rs ---
use crate::cores::namespace::*;
use crate::{define_custom_tagname, define_tagname};

pub trait TagName {
    const TAG_NAME: &'static str;
    const NAMESPACE: Option<&'static str>;

    fn tag_name(&self) -> &'static str {
        Self::TAG_NAME
    }

    fn namespace(&self) -> Option<&'static str> {
        Self::NAMESPACE
    }
}

// ==========================
// PowerShell Remoting Shell (rsp namespace)
// ==========================
define_tagname!(ShellId, Some(Namespace::WsmanShell.uri()));
define_tagname!(Name, Some(Namespace::WsmanShell.uri()));
define_tagname!(ResourceUri, Some(Namespace::WsmanShell.uri()));
define_tagname!(Owner, Some(Namespace::WsmanShell.uri()));
define_tagname!(ClientIP, Some(Namespace::WsmanShell.uri()));
define_tagname!(ProcessId, Some(Namespace::WsmanShell.uri()));
define_tagname!(IdleTimeOut, Some(Namespace::WsmanShell.uri()));
define_tagname!(InputStreams, Some(Namespace::WsmanShell.uri()));
define_tagname!(OutputStreams, Some(Namespace::WsmanShell.uri()));
define_tagname!(MaxIdleTimeOut, Some(Namespace::WsmanShell.uri()));
define_tagname!(CompressionMode, Some(Namespace::WsmanShell.uri()));
define_tagname!(ProfileLoaded, Some(Namespace::WsmanShell.uri()));
define_tagname!(Encoding, Some(Namespace::WsmanShell.uri()));
define_tagname!(BufferMode, Some(Namespace::WsmanShell.uri()));
define_tagname!(State, Some(Namespace::WsmanShell.uri()));
define_tagname!(ShellRunTime, Some(Namespace::WsmanShell.uri()));
define_tagname!(ShellInactivity, Some(Namespace::WsmanShell.uri()));
define_tagname!(CompressionType, Some(Namespace::WsmanShell.uri()));
define_tagname!(DesiredStream, Some(Namespace::WsmanShell.uri()));

define_custom_tagname!(CreationXml, "creationXml", None);

define_tagname!(CommandLine, Some(Namespace::WsmanShell.uri()));
define_tagname!(Shell, Some(Namespace::WsmanShell.uri()));
define_tagname!(Command, Some(Namespace::WsmanShell.uri()));
define_tagname!(Receive, Some(Namespace::WsmanShell.uri()));
define_tagname!(ReceiveResponse, Some(Namespace::WsmanShell.uri()));
define_tagname!(CommandResponse, Some(Namespace::WsmanShell.uri()));
define_tagname!(CommandId, Some(Namespace::WsmanShell.uri()));
define_tagname!(Stream, Some(Namespace::WsmanShell.uri()));
define_tagname!(CommandState, Some(Namespace::WsmanShell.uri()));
define_tagname!(ExitCode, Some(Namespace::WsmanShell.uri()));
define_tagname!(Send, Some(Namespace::WsmanShell.uri()));
define_tagname!(Signal, Some(Namespace::WsmanShell.uri()));
define_tagname!(Arguments, Some(Namespace::WsmanShell.uri()));

// ====================
// WS-Addressing (a namespace)
// ====================
define_tagname!(Action, Some(Namespace::WsAddressing2004.uri()));
define_tagname!(To, Some(Namespace::WsAddressing2004.uri()));
define_tagname!(MessageID, Some(Namespace::WsAddressing2004.uri()));
define_tagname!(RelatesTo, Some(Namespace::WsAddressing2004.uri()));
define_tagname!(ReplyTo, Some(Namespace::WsAddressing2004.uri()));
define_tagname!(FaultTo, Some(Namespace::WsAddressing2004.uri()));
define_tagname!(From, Some(Namespace::WsAddressing2004.uri()));
define_tagname!(Address, Some(Namespace::WsAddressing2004.uri()));
define_tagname!(ReferenceParameters, Some(Namespace::WsAddressing2004.uri()));

// =============
// SOAP (s namespace)
// =============
define_tagname!(Envelope, Some(Namespace::SoapEnvelope2003.uri()));
define_tagname!(Header, Some(Namespace::SoapEnvelope2003.uri()));
define_tagname!(Body, Some(Namespace::SoapEnvelope2003.uri()));

// ===============================
// WS-Management DMTF (w namespace)
// ===============================
define_tagname!(Identify, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(Get, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(Put, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(Delete, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(Enumerate, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(Pull, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(Release, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(GetStatus, Some(Namespace::DmtfWsmanSchema.uri()));

// WS-Management DMTF Headers (w namespace)
define_tagname!(ResourceURI, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(OperationTimeout, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(MaxEnvelopeSize, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(FragmentTransfer, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(SelectorSet, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(OptionSet, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(Locale, Some(Namespace::DmtfWsmanSchema.uri()));
define_tagname!(Selector, Some(Namespace::DmtfWsmanSchema.uri()));
define_custom_tagname!(
    OptionTagName,
    "Option",
    Some(Namespace::DmtfWsmanSchema.uri())
);

// ===================================
// WS-Transfer (x namespace)
// ===================================
define_tagname!(Create, Some(Namespace::WsTransfer2004.uri()));

define_tagname!(ResourceCreated, Some(Namespace::WsTransfer2004.uri()));

// ====================================
// Microsoft WS-Management (p namespace)
// ====================================
define_tagname!(SequenceId, Some(Namespace::MsWsmanSchema.uri()));
define_tagname!(OperationID, Some(Namespace::MsWsmanSchema.uri()));
define_tagname!(SessionId, Some(Namespace::MsWsmanSchema.uri()));
define_tagname!(DataLocale, Some(Namespace::MsWsmanSchema.uri()));

// PowerShell Remoting Protocol;
define_tagname!(Obj, None);
define_tagname!(MS, None);
define_tagname!(Version, None);
define_tagname!(BA, None);

// PowerShell Serialization Format
// define_tagname!(I32, None); // 32-bit integer
define_custom_tagname!(I32TagName, "I32", None); // 32-bit integer
define_tagname!(TN, None); // Type Name
define_tagname!(T, None); // Type
define_custom_tagname!(ToString, "ToString", None); // ToString representation
define_tagname!(DCT, None); // Dictionary
define_tagname!(En, None); // Dictionary Entry
define_tagname!(Key, None); // Dictionary Key
define_tagname!(Value, None); // Dictionary Value
define_tagname!(Nil, None); // Null Value
define_tagname!(B, None); // Boolean
define_tagname!(S, None); // String

// PowerShell InitRunspacepool Message Tags
define_tagname!(MinRunspaces, None); // Minimum number of runspaces
define_tagname!(MaxRunspaces, None); // Maximum number of runspaces
define_tagname!(PSThreadOptions, None); // PowerShell thread options
define_tagname!(ApartmentState, None); // Apartment state for runspace
define_tagname!(HostInfo, None); // Host information
define_tagname!(ApplicationArguments, None); // Application arguments


--- File: crates/protocol-winrm/src/cores/tag_value.rs ---
use std::borrow::Cow;

use xml::{
    builder::Element,
    parser::{XmlDeserialize, XmlVisitor},
};

use crate::xml_num_value;

pub trait TagValue<'a> {
    fn append_to_element(self, element: Element<'a>) -> Element<'a>;
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Text<'a>(Cow<'a, str>);

impl<'a> std::convert::From<&'a str> for Text<'a> {
    fn from(value: &'a str) -> Self {
        Text(value.into())
    }
}

impl<'a> std::convert::From<String> for Text<'a> {
    fn from(value: String) -> Self {
        Text(value.into())
    }
}

impl<'a> AsRef<str> for Text<'a> {
    fn as_ref(&self) -> &str {
        self.0.as_ref()
    }
}

impl<'a> From<Text<'a>> for Cow<'a, str> {
    fn from(val: Text<'a>) -> Self {
        val.0
    }
}

impl<'a> From<&'a Text<'a>> for &'a str {
    fn from(val: &'a Text<'a>) -> Self {
        val.0.as_ref()
    }
}

impl<'a> TagValue<'a> for Text<'a> {
    fn append_to_element(self, element: Element<'a>) -> Element<'a> {
        element.set_text(self.0)
    }
}

impl<'a> TagValue<'a> for () {
    fn append_to_element(self, element: Element<'a>) -> Element<'a> {
        element
    }
}

pub struct TextVisitor<'a> {
    value: Option<Text<'a>>,
}

impl<'a> XmlVisitor<'a> for TextVisitor<'a> {
    type Value = Text<'a>;

    fn visit_node(&mut self, _node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
        Ok(())
    }

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        let child_nodes: Vec<_> = children.collect();

        // Validate there's only one child node
        if child_nodes.len() != 1 {
            return Err(xml::XmlError::InvalidXml(format!(
                "Expected exactly one text node, found {} children",
                child_nodes.len()
            )));
        }

        let child = child_nodes.first().ok_or_else(|| {
            xml::XmlError::InvalidXml("Expected at least one child node".to_string())
        })?;

        // Validate that child node is a text node
        if !child.is_text() {
            return Err(xml::XmlError::InvalidXml(
                "Expected text node, found non-text child".to_string(),
            ));
        }

        if let Some(text) = child.text() {
            self.value = Some(Text(text.trim().into()));
        }

        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        self.value.ok_or(xml::XmlError::InvalidXml(
            "No text found in the node".to_string(),
        ))
    }
}

impl<'a> XmlDeserialize<'a> for Text<'a> {
    type Visitor = TextVisitor<'a>;

    fn visitor() -> Self::Visitor {
        TextVisitor { value: None }
    }

    fn from_node(node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
        xml::parser::NodeDeserializer::new(node).deserialize(Self::visitor())
    }
}

pub struct EmptyVisitor;

impl<'a> XmlVisitor<'a> for EmptyVisitor {
    type Value = Empty;

    fn visit_node(&mut self, _node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
        Ok(())
    }

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        let child_count = children.count();

        if child_count != 0 {
            return Err(xml::XmlError::InvalidXml(format!(
                "Expected empty tag with no children, found {child_count} children"
            )));
        }

        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        Ok(Empty)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Empty;

impl<'a> XmlDeserialize<'a> for Empty {
    type Visitor = EmptyVisitor;

    fn visitor() -> Self::Visitor {
        EmptyVisitor
    }

    fn from_node(node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
        xml::parser::NodeDeserializer::new(node).deserialize(Self::visitor())
    }
}

impl<'a> TagValue<'a> for Empty {
    fn append_to_element(self, element: Element<'a>) -> Element<'a> {
        element
    }
}

impl From<()> for Empty {
    fn from(_: ()) -> Self {
        Empty
    }
}

xml_num_value!(U8, u8);
xml_num_value!(U32, u32);
xml_num_value!(U64, u64);
xml_num_value!(I32, i32);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct WsUuid(pub uuid::Uuid);

impl<'a> TagValue<'a> for WsUuid {
    fn append_to_element(self, element: Element<'a>) -> Element<'a> {
        element.set_text(format!("uuid:{}", self.0))
    }
}

pub struct WsUuidVisitor {
    value: Option<WsUuid>,
}

impl<'a> XmlVisitor<'a> for WsUuidVisitor {
    type Value = WsUuid;

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        let child_nodes: Vec<_> = children.collect();

        // Validate there's only one child node
        if child_nodes.len() != 1 {
            return Err(xml::XmlError::InvalidXml(format!(
                "Expected exactly one text node, found {} children",
                child_nodes.len()
            )));
        }

        let child = child_nodes.first().ok_or_else(|| {
            xml::XmlError::InvalidXml("Expected at least one child node".to_string())
        })?;

        // Validate that child node is a text node
        if !child.is_text() {
            return Err(xml::XmlError::InvalidXml(
                "Expected text node, found non-text child".to_string(),
            ));
        }

        if let Some(text) = child.text() {
            let uuid_str = text.trim();
            // Handle WS-Management format: "uuid:9EC885D6-F5A4-4771-9D47-4BDF7DAAEA8C"
            let uuid_part = if let Some(stripped) = uuid_str.strip_prefix("uuid:") {
                stripped
            } else {
                uuid_str
            };

            match uuid::Uuid::parse_str(uuid_part) {
                Ok(uuid) => self.value = Some(WsUuid(uuid)),
                Err(_) => {
                    return Err(xml::XmlError::InvalidXml(format!(
                        "Invalid UUID format: {uuid_str}"
                    )));
                }
            }
        }

        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        self.value.ok_or(xml::XmlError::InvalidXml(
            "No UUID found in the node".to_string(),
        ))
    }
}

impl<'a> XmlDeserialize<'a> for WsUuid {
    type Visitor = WsUuidVisitor;

    fn visitor() -> Self::Visitor {
        WsUuidVisitor { value: None }
    }

    fn from_node(node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
        xml::parser::NodeDeserializer::new(node).deserialize(Self::visitor())
    }
}

impl From<uuid::Uuid> for WsUuid {
    fn from(value: uuid::Uuid) -> Self {
        WsUuid(value)
    }
}

impl From<WsUuid> for uuid::Uuid {
    fn from(value: WsUuid) -> Self {
        value.0
    }
}

impl AsRef<uuid::Uuid> for WsUuid {
    fn as_ref(&self) -> &uuid::Uuid {
        &self.0
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Time(pub f64);

impl<'a> TagValue<'a> for Time {
    fn append_to_element(self, element: Element<'a>) -> Element<'a> {
        element.set_text(format!("PT{:.3}S", self.0))
    }
}

pub struct TimeVisitor {
    value: Option<Time>,
}

impl<'a> XmlVisitor<'a> for TimeVisitor {
    type Value = Time;

    fn visit_node(&mut self, _node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
        Ok(())
    }

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        let child_nodes: Vec<_> = children.collect();

        // Validate there's only one child node
        if child_nodes.len() != 1 {
            return Err(xml::XmlError::InvalidXml(format!(
                "Expected exactly one text node, found {} children",
                child_nodes.len()
            )));
        }

        let child = child_nodes.first().ok_or_else(|| {
            xml::XmlError::InvalidXml("Expected at least one child node".to_string())
        })?;

        // Validate that child node is a text node
        if !child.is_text() {
            return Err(xml::XmlError::InvalidXml(
                "Expected text node, found non-text child".to_string(),
            ));
        }

        if let Some(text) = child.text() {
            let time_str = text.trim();
            // Handle WS-Management timeout format: "PT180.000S"
            if let Some(stripped) = time_str.strip_prefix("PT") {
                if let Some(time_part) = stripped.strip_suffix("S") {
                    match time_part.parse::<f64>() {
                        Ok(seconds) => self.value = Some(Time(seconds)),
                        Err(_) => {
                            return Err(xml::XmlError::InvalidXml(format!(
                                "Invalid time format: {time_str}"
                            )));
                        }
                    }
                } else {
                    return Err(xml::XmlError::InvalidXml(format!(
                        "Invalid time format, missing 'S' suffix: {time_str}"
                    )));
                }
            } else {
                return Err(xml::XmlError::InvalidXml(format!(
                    "Invalid time format, missing 'PT' prefix: {time_str}"
                )));
            }
        }

        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        self.value.ok_or(xml::XmlError::InvalidXml(
            "No time found in the node".to_string(),
        ))
    }
}

impl<'a> XmlDeserialize<'a> for Time {
    type Visitor = TimeVisitor;

    fn visitor() -> Self::Visitor {
        TimeVisitor { value: None }
    }

    fn from_node(node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
        xml::parser::NodeDeserializer::new(node).deserialize(Self::visitor())
    }
}

impl From<f64> for Time {
    fn from(value: f64) -> Self {
        Time(value)
    }
}

impl From<u32> for Time {
    fn from(value: u32) -> Self {
        Time(value as f64)
    }
}

impl From<Time> for f64 {
    fn from(value: Time) -> Self {
        value.0
    }
}

impl AsRef<f64> for Time {
    fn as_ref(&self) -> &f64 {
        &self.0
    }
}


--- File: crates/protocol-winrm/src/error.rs ---
#[derive(Debug, thiserror::Error)]
pub enum ProtocolError {
    #[error("Invalid SOAP version: {0}")]
    InvalidSoapVersion(String),

    #[error("SOAP envelope is missing")]
    MissingSoapEnvelope,

    #[error("SOAP body is missing")]
    MissingSoapBody,

    #[error("SOAP header is missing")]
    MissingSoapHeader,

    #[error("XML parsing error: {0}")]
    XmlParsingError(String),

    #[error("Unexpected error: {0}")]
    Unexpected(String),

    #[error("IO Error: {0}")]
    IoError(#[from] std::io::Error),
}


--- File: crates/protocol-winrm/src/http/mod.rs ---



--- File: crates/protocol-winrm/src/lib.rs ---
pub mod cores;
pub mod error;
pub mod http;
pub(crate) mod macros;
pub mod rsp;
pub mod soap;
pub mod test_macro;
pub mod ws_addressing;
pub mod ws_management;


--- File: crates/protocol-winrm/src/macros.rs ---
#[macro_export]
macro_rules! define_custom_tagname {
    ($name:ident, $tagName:expr, $namespace:expr) => {
        #[derive(Debug, Clone, PartialEq, Eq)]
        pub struct $name;

        impl $crate::cores::TagName for $name {
            const TAG_NAME: &'static str = $tagName;
            const NAMESPACE: Option<&'static str> = $namespace;

            fn tag_name(&self) -> &'static str {
                Self::TAG_NAME
            }

            fn namespace(&self) -> Option<&'static str> {
                Self::NAMESPACE
            }
        }

        impl<'a> $name {
            pub fn new_tag<V>(value: V) -> $crate::cores::tag::Tag<'a, V, Self>
            where
                V: $crate::cores::TagValue<'a>,
            {
                $crate::cores::tag::Tag::new(value)
            }
        }
    };
}

#[macro_export]
macro_rules! define_tagname {
    ($name:ident, $namespace:expr) => {
        $crate::define_custom_tagname!($name, stringify!($name), $namespace);
    };
}

#[macro_export]
macro_rules! impl_tag_value {
    (
        struct -> $struct_name:ident<$lifetime:lifetime>
        required -> [
            $(
                $req_field:ident
            ),* $(,)?
        ]
        optional -> [
            $(
                $opt_field:ident
            ),* $(,)?
        ]
    ) => {
        impl<$lifetime> $crate::cores::TagValue<$lifetime> for $struct_name<$lifetime> {
            fn append_to_element(self, mut element: xml::builder::Element<$lifetime>) -> xml::builder::Element<$lifetime> {
                // Append required fields
                $(
                    element = element.add_child(self.$req_field.into_element());
                )*

                // Append optional fields conditionally
                $(
                    element = match self.$opt_field {
                        Some(tag) => element.add_child(tag.into_element()),
                        None => element,
                    };
                )*

                element
            }
        }
    };
}

#[macro_export]
macro_rules! impl_xml_deserialize {
    (
        struct -> $struct_name:ident<$lifetime:lifetime>
        required -> [
            $(
                $req_field:ident: $req_field_type:ty
            ),* $(,)?
        ]
        optional -> [
            $(
                $opt_field:ident: $opt_field_type:ty
            ),* $(,)?
        ]
    ) => {
        paste::paste! {
            pub struct [<$struct_name Visitor>]<$lifetime> {
                $(
                    $req_field: Option<$req_field_type>,
                )*
                $(
                    $opt_field: Option<$opt_field_type>,  // This will be Option<Tag<...>>
                )*
            }

            impl<$lifetime> Default for [<$struct_name Visitor>]<$lifetime> {
                fn default() -> Self {
                    Self {
                        $(
                            $req_field: None,
                        )*
                        $(
                            $opt_field: None,
                        )*
                    }
                }
            }

            impl<$lifetime> xml::parser::XmlVisitor<$lifetime> for [<$struct_name Visitor>]<$lifetime> {
                type Value = $struct_name<$lifetime>;

                fn visit_children(
                    &mut self,
                    children: impl Iterator<Item = xml::parser::Node<$lifetime, $lifetime>>,
                ) -> Result<(), xml::XmlError> {
                    for child in children {
                        if !child.is_element() {
                            continue;
                        }

                        let tag_name = child.tag_name().name();
                        let namespace = child.tag_name().namespace();

                        // We need a way to match tag names to field types
                        // For now, let's use a simpler approach where we try to deserialize each field type
                        let mut matched = false;

                        $(
                            // Try to match required fields
                            if !matched {
                                if let Ok(tag) = <$req_field_type as xml::parser::XmlDeserialize>::from_node(child) {
                                    if self.$req_field.is_some() {
                                        return Err(xml::XmlError::InvalidXml(format!(
                                            "Duplicate {} tag in {}",
                                            tag_name,
                                            stringify!($struct_name)
                                        )));
                                    }
                                    self.$req_field = Some(tag);
                                    matched = true;
                                }
                            }
                        )*

                        $(
                            // Try to match optional fields - deserialize the Tag type and wrap in Some
                            if !matched {
                                if let Ok(tag) = <$opt_field_type as xml::parser::XmlDeserialize>::from_node(child) {
                                    if self.$opt_field.is_some() {
                                        return Err(xml::XmlError::InvalidXml(format!(
                                            "Duplicate {} tag in {}",
                                            tag_name,
                                            stringify!($struct_name)
                                        )));
                                    }
                                    self.$opt_field = Some(tag);
                                    matched = true;
                                }
                            }
                        )*

                        if !matched {
                            return Err(xml::XmlError::InvalidXml(format!(
                                "Unknown tag in {}: {} (namespace: {:?})",
                                stringify!($struct_name),
                                tag_name,
                                namespace
                            )));
                        }
                    }

                    Ok(())
                }

                fn visit_node(&mut self, node: xml::parser::Node<$lifetime, $lifetime>) -> Result<(), xml::XmlError> {
                    let children: Vec<_> = node.children().collect();
                    self.visit_children(children.into_iter())?;
                    Ok(())
                }

                fn finish(self) -> Result<Self::Value, xml::XmlError> {
                    // Required fields must be present
                    $(
                        let $req_field = self.$req_field.ok_or_else(|| {
                            xml::XmlError::InvalidXml(format!(
                                "Missing {} in {}",
                                stringify!($req_field),
                                stringify!($struct_name)
                            ))
                        })?;
                    )*

                    // Optional fields - wrap in Some() if present, None if not
                    $(
                        let $opt_field = self.$opt_field;
                    )*

                    Ok($struct_name {
                        $(
                            $req_field,
                        )*
                        $(
                            $opt_field,
                        )*
                    })
                }
            }

            impl<$lifetime> xml::parser::XmlDeserialize<$lifetime> for $struct_name<$lifetime> {
                type Visitor = [<$struct_name Visitor>]<$lifetime>;

                fn visitor() -> Self::Visitor {
                    [<$struct_name Visitor>]::default()
                }

                fn from_node(node: xml::parser::Node<$lifetime, $lifetime>) -> Result<Self, xml::XmlError> {
                    xml::parser::NodeDeserializer::new(node).deserialize(Self::visitor())
                }
            }
        }
    };
}

#[macro_export]
macro_rules! impl_tag_from {
    ($src:ty => $taggen:ty) => {
        impl<'a, N> From<$src> for $taggen
        where
            N: TagName,
        {
            fn from(value: $src) -> Self {
                Tag::new(value)
            }
        }
    };
}

#[macro_export]
macro_rules! xml_num_value {
    ($name:ident, $inner:ty) => {
        paste::paste! {
            #[derive(Debug, Clone, Copy, PartialEq, Eq)]
            pub struct $name(pub $inner);

            // ------------ TagValue ---------------
            impl<'a> TagValue<'a> for $name {
                fn append_to_element(self, e: Element<'a>) -> Element<'a> { e.set_text(self.0.to_string()) }
            }

            // ------------ Visitor -----------------
            pub struct [<$name Visitor>] { value: Option<$name> }

            impl<'a> XmlVisitor<'a> for [<$name Visitor>] {
                type Value = $name;

                fn visit_node(&mut self, _n: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> { Ok(()) }

                fn visit_children(
                    &mut self,
                    children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
                ) -> Result<(), xml::XmlError> {
                    let nodes: Vec<_> = children.collect();
                    if nodes.len() != 1 {
                        return Err(xml::XmlError::InvalidXml(
                            format!("{} expects exactly one text child", stringify!($name))
                        ));
                    }
                    if let Some(t) = nodes[0].text() {
                        self.value = Some($name(t.trim().parse::<$inner>().map_err(|_| {
                            xml::XmlError::InvalidXml(format!("invalid {} value: {}", stringify!($name), t))
                        })?));
                    }
                    Ok(())
                }

                fn finish(self) -> Result<Self::Value, xml::XmlError> {
                    self.value.ok_or(xml::XmlError::InvalidXml(
                        format!("no {} value found", stringify!($name))
                    ))
                }
            }

            // ------------ Deserialize -------------
            impl<'a> XmlDeserialize<'a> for $name {
                type Visitor = [<$name Visitor>];
                fn visitor() -> Self::Visitor { [<$name Visitor>] { value: None } }
                fn from_node(node: xml::parser::Node<'a, 'a>) -> Result<Self, xml::XmlError> {
                    xml::parser::NodeDeserializer::new(node).deserialize(Self::visitor())
                }
            }

            // ------------ Conversions -------------
            impl From<$inner> for $name        { fn from(v: $inner) -> Self { Self(v) } }
            impl From<$name>  for $inner       { fn from(v: $name)  -> Self { v.0 } }
        }
    }
}


--- File: crates/protocol-winrm/src/rsp/commandline.rs ---
use tracing::warn;

use crate::cores::{
    Tag, TagName, TagValue, Text,
    tag_name::{Arguments, Command},
};

#[derive(Debug, Clone)]
pub struct CommandLineValue {
    pub command: Option<String>,
    pub arguments: Vec<String>,
}

impl<'a> TagValue<'a> for CommandLineValue {
    fn append_to_element(self, mut element: xml::builder::Element) -> xml::builder::Element {
        let command_element = self
            .command
            .map(|cmd| {
                Tag::from_name(Command)
                    .with_value(Text::from(cmd))
                    .into_element()
            })
            .unwrap_or(Tag::from_name(Command).with_value(()).into_element());

        element = element.add_child(command_element);

        for arg in self.arguments {
            let arg_element = Tag::from_name(Arguments)
                .with_value(Text::from(arg))
                .into_element();
            element = element.add_child(arg_element);
        }

        element
    }
}

pub struct CommandLineValueVisitor {
    command_line: Option<String>,
    arguments: Vec<String>,
}

impl<'a> xml::parser::XmlVisitor<'a> for CommandLineValueVisitor {
    type Value = CommandLineValue;

    fn visit_children(
        &mut self,
        nodes: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        for node in nodes {
            match (node.tag_name().name(), node.tag_name().namespace()) {
                (Command::TAG_NAME, Command::NAMESPACE) => {
                    let cmd_text = node.text().map(|t| t.to_string());
                    self.command_line = cmd_text;
                }
                (Arguments::TAG_NAME, Arguments::NAMESPACE) => {
                    if let Some(text) = node.text() {
                        self.arguments.push(text.to_string());
                    }
                }
                _ => {
                    warn!(
                        "Unexpected tag in CommandLineValue: {}",
                        node.tag_name().name()
                    );
                }
            }
        }
        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        Ok(CommandLineValue {
            command: self.command_line,
            arguments: self.arguments,
        })
    }
}

impl<'a> xml::parser::XmlDeserialize<'a> for CommandLineValue {
    type Visitor = CommandLineValueVisitor;

    fn visitor() -> Self::Visitor {
        CommandLineValueVisitor {
            command_line: None,
            arguments: Vec::new(),
        }
    }
}


--- File: crates/protocol-winrm/src/rsp/mod.rs ---
pub mod commandline;
pub mod receive;
pub mod rsp;


--- File: crates/protocol-winrm/src/rsp/receive.rs ---
use protocol_macros::{SimpleTagValue, SimpleXmlDeserialize};
use tracing::warn;

use crate::cores::{
    CommandState, DesiredStream, ExitCode, Stream, Tag, TagName, TagValue, Text, tag_value,
};
use xml::{
    XmlError,
    builder::Element,
    parser::{XmlDeserialize, XmlVisitor},
};

#[derive(Debug, Clone, typed_builder::TypedBuilder)]
pub struct ReceiveValue<'a> {
    pub desired_streams: Vec<Tag<'a, Text<'a>, DesiredStream>>,
}

impl<'a> TagValue<'a> for ReceiveValue<'a> {
    fn append_to_element(self, mut element: Element<'a>) -> Element<'a> {
        for stream in self.desired_streams {
            element = element.add_child(stream.into_element());
        }
        element
    }
}

pub struct ReceiveVisitor<'a> {
    pub desired_stream: Vec<Tag<'a, Text<'a>, DesiredStream>>,
}

impl<'a> XmlVisitor<'a> for ReceiveVisitor<'a> {
    type Value = ReceiveValue<'a>;

    fn visit_children(
        &mut self,
        nodes: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        for node in nodes {
            match (node.tag_name().name(), node.tag_name().namespace()) {
                (DesiredStream::TAG_NAME, DesiredStream::NAMESPACE) => {
                    let stream = Tag::from_node(node)?;
                    self.desired_stream.push(stream);
                }
                _ => {
                    warn!("Unexpected tag in Receive: {}", node.tag_name().name());
                }
            }
        }
        Ok(())
    }

    fn finish(self) -> Result<Self::Value, XmlError> {
        Ok(ReceiveValue {
            desired_streams: self.desired_stream,
        })
    }
}

impl<'a> XmlDeserialize<'a> for ReceiveValue<'a> {
    type Visitor = ReceiveVisitor<'a>;

    fn visitor() -> Self::Visitor {
        ReceiveVisitor {
            desired_stream: Vec::new(),
        }
    }
}

#[derive(Debug, Clone)]
pub enum CommandStateValueState {
    Done,
    Pending,
    Running,
}

impl CommandStateValueState {
    pub fn value(&self) -> &'static str {
        match self {
            CommandStateValueState::Done => {
                "http://schemas.microsoft.com/powershell/Microsoft.PowerShell/CommandState/Done"
            }
            CommandStateValueState::Pending => {
                "http://schemas.microsoft.com/powershell/Microsoft.PowerShell/CommandState/Pending"
            }
            CommandStateValueState::Running => {
                "http://schemas.microsoft.com/powershell/Microsoft.PowerShell/CommandState/Running"
            }
        }
    }
}

impl TryFrom<&str> for CommandStateValueState {
    type Error = XmlError;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "http://schemas.microsoft.com/powershell/Microsoft.PowerShell/CommandState/Done" => {
                Ok(CommandStateValueState::Done)
            }
            "http://schemas.microsoft.com/powershell/Microsoft.PowerShell/CommandState/Pending" => {
                Ok(CommandStateValueState::Pending)
            }
            "http://schemas.microsoft.com/powershell/Microsoft.PowerShell/CommandState/Running" => {
                Ok(CommandStateValueState::Running)
            }
            _ => Err(XmlError::GenericError(format!(
                "Unknown CommandStateValueState: {value}"
            ))),
        }
    }
}

#[derive(Debug, Clone, SimpleTagValue, SimpleXmlDeserialize)]
pub struct CommandStateValue<'a> {
    pub exit_code: Option<Tag<'a, tag_value::I32, ExitCode>>,
}

// ReceiveResponse main structure
#[derive(Debug, Clone, typed_builder::TypedBuilder)]
pub struct ReceiveResponseValue<'a> {
    pub streams: Vec<Tag<'a, Text<'a>, Stream>>,
    pub command_state: Option<Tag<'a, CommandStateValue<'a>, CommandState>>,
}

impl<'a> TagValue<'a> for ReceiveResponseValue<'a> {
    fn append_to_element(self, mut element: Element<'a>) -> Element<'a> {
        for stream in self.streams {
            element = element.add_child(stream.into_element());
        }

        element
    }
}

pub struct ReceiveResponseVisitor<'a> {
    pub streams: Vec<Tag<'a, Text<'a>, Stream>>,
    pub command_state: Option<Tag<'a, CommandStateValue<'a>, CommandState>>,
}

impl<'a> XmlVisitor<'a> for ReceiveResponseVisitor<'a> {
    type Value = ReceiveResponseValue<'a>;

    fn visit_children(
        &mut self,
        nodes: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        for node in nodes {
            match (node.tag_name().name(), node.tag_name().namespace()) {
                (Stream::TAG_NAME, Stream::NAMESPACE) => {
                    let stream = Tag::from_node(node)?;
                    self.streams.push(stream);
                }
                (CommandState::TAG_NAME, CommandState::NAMESPACE) => {
                    let command_state = Tag::from_node(node)?;
                    self.command_state = Some(command_state);
                }
                _ => {
                    warn!(
                        "Unexpected tag in ReceiveResponse: {}",
                        node.tag_name().name()
                    );
                }
            }
        }
        Ok(())
    }

    fn finish(self) -> Result<Self::Value, XmlError> {
        Ok(ReceiveResponseValue {
            streams: self.streams,
            command_state: self.command_state,
        })
    }
}

impl<'a> XmlDeserialize<'a> for ReceiveResponseValue<'a> {
    type Visitor = ReceiveResponseVisitor<'a>;

    fn visitor() -> Self::Visitor {
        ReceiveResponseVisitor {
            streams: Vec::new(),
            command_state: None,
        }
    }
}


--- File: crates/protocol-winrm/src/rsp/rsp.rs ---
use crate::cores::{
    Tag, Text, Time,
    tag_name::{
        BufferMode, ClientIP, CompressionMode, CreationXml, DataLocale, Encoding, IdleTimeOut,
        InputStreams, Locale, MaxIdleTimeOut, Name, OutputStreams, Owner, ProcessId, ProfileLoaded,
        ResourceUri, ShellId, ShellInactivity, ShellRunTime, State, TagName,
    },
};
use protocol_macros::{SimpleTagValue, SimpleXmlDeserialize};

// The XmlTagContainer derive macro generates:
// - TagValue implementation
// - ShellValueVisitor struct
// - XmlVisitor implementation for ShellValueVisitor
// - XmlDeserialize implementation
#[derive(Debug, Clone, typed_builder::TypedBuilder, SimpleTagValue, SimpleXmlDeserialize)]
pub struct ShellValue<'a> {
    #[builder(default, setter(strip_option, into))]
    pub shell_id: Option<Tag<'a, Text<'a>, ShellId>>,
    #[builder(default, setter(strip_option, into))]
    pub name: Option<Tag<'a, Text<'a>, Name>>,
    #[builder(default, setter(strip_option, into))]
    pub resource_uri: Option<Tag<'a, Text<'a>, ResourceUri>>,
    #[builder(default, setter(strip_option, into))]
    pub owner: Option<Tag<'a, Text<'a>, Owner>>,
    #[builder(default, setter(strip_option, into))]
    pub client_ip: Option<Tag<'a, Text<'a>, ClientIP>>,
    #[builder(default, setter(strip_option, into))]
    pub process_id: Option<Tag<'a, Text<'a>, ProcessId>>,
    #[builder(default, setter(strip_option(fallback_suffix = "_opt"), into))]
    pub idle_time_out: Option<Tag<'a, Time, IdleTimeOut>>,
    #[builder(default, setter(strip_option, into))]
    pub input_streams: Option<Tag<'a, Text<'a>, InputStreams>>,
    #[builder(default, setter(strip_option, into))]
    pub output_streams: Option<Tag<'a, Text<'a>, OutputStreams>>,
    #[builder(default, setter(strip_option, into))]
    pub max_idle_time_out: Option<Tag<'a, Text<'a>, MaxIdleTimeOut>>,
    #[builder(default, setter(strip_option, into))]
    pub locale: Option<Tag<'a, Text<'a>, Locale>>,
    #[builder(default, setter(strip_option, into))]
    pub data_locale: Option<Tag<'a, Text<'a>, DataLocale>>,
    #[builder(default, setter(strip_option, into))]
    pub compression_mode: Option<Tag<'a, Text<'a>, CompressionMode>>,
    #[builder(default, setter(strip_option, into))]
    pub profile_loaded: Option<Tag<'a, Text<'a>, ProfileLoaded>>,
    #[builder(default, setter(strip_option, into))]
    pub encoding: Option<Tag<'a, Text<'a>, Encoding>>,
    #[builder(default, setter(strip_option, into))]
    pub buffer_mode: Option<Tag<'a, Text<'a>, BufferMode>>,
    #[builder(default, setter(strip_option, into))]
    pub state: Option<Tag<'a, Text<'a>, State>>,
    #[builder(default, setter(strip_option, into))]
    pub shell_run_time: Option<Tag<'a, Text<'a>, ShellRunTime>>,
    #[builder(default, setter(strip_option, into))]
    pub shell_inactivity: Option<Tag<'a, Text<'a>, ShellInactivity>>,
    #[builder(default, setter(strip_option, into))]
    pub creation_xml: Option<Tag<'a, Text<'a>, CreationXml>>,
}


--- File: crates/protocol-winrm/src/soap/body.rs ---
use protocol_macros::{SimpleTagValue, SimpleXmlDeserialize};

use crate::{
    cores::*,
    rsp::{
        commandline::CommandLineValue,
        receive::{ReceiveResponseValue, ReceiveValue},
        rsp::ShellValue,
    },
    ws_management::body::ResourceCreatedValue,
};

#[derive(Debug, Clone, typed_builder::TypedBuilder, SimpleTagValue, SimpleXmlDeserialize)]
pub struct SoapBody<'a> {
    /// WS-Management operations
    #[builder(default, setter(into, strip_option))]
    pub identify: Option<Tag<'a, Empty, Identify>>,
    #[builder(default, setter(into, strip_option))]
    pub get: Option<Tag<'a, Text<'a>, Get>>,
    #[builder(default, setter(into, strip_option))]
    pub put: Option<Tag<'a, Text<'a>, Put>>,
    #[builder(default, setter(into, strip_option))]
    pub create: Option<Tag<'a, Text<'a>, Create>>,
    #[builder(default, setter(into, strip_option))]
    pub delete: Option<Tag<'a, Text<'a>, Delete>>,
    #[builder(default, setter(into, strip_option))]
    pub enumerate: Option<Tag<'a, TagList<'a>, Enumerate>>,
    #[builder(default, setter(into, strip_option))]
    pub pull: Option<Tag<'a, TagList<'a>, Pull>>,
    #[builder(default, setter(into, strip_option))]
    pub release: Option<Tag<'a, TagList<'a>, Release>>,
    #[builder(default, setter(into, strip_option))]
    pub get_status: Option<Tag<'a, TagList<'a>, GetStatus>>,

    /// WS-Transfer operations
    #[builder(default, setter(into, strip_option))]
    pub resource_created: Option<Tag<'a, ResourceCreatedValue<'a>, ResourceCreated>>,

    /// PowerShell Remoting operations
    #[builder(default, setter(into, strip_option))]
    pub shell: Option<Tag<'a, ShellValue<'a>, Shell>>,
    #[builder(default, setter(into, strip_option))]
    pub command: Option<Tag<'a, TagList<'a>, Command>>,
    #[builder(default, setter(into, strip_option))]
    pub command_line: Option<Tag<'a, CommandLineValue, CommandLine>>,
    #[builder(default, setter(into, strip_option))]
    pub receive: Option<Tag<'a, ReceiveValue<'a>, Receive>>,
    #[builder(default, setter(into, strip_option))]
    pub receive_response: Option<Tag<'a, ReceiveResponseValue<'a>, ReceiveResponse>>,
    #[builder(default, setter(into, strip_option))]
    pub command_response: Option<Tag<'a, Tag<'a, WsUuid, CommandId>, CommandResponse>>,
    #[builder(default, setter(into, strip_option))]
    pub send: Option<Tag<'a, Text<'a>, Send>>,
    #[builder(default, setter(into, strip_option))]
    pub signal: Option<Tag<'a, TagList<'a>, Signal>>,
}


--- File: crates/protocol-winrm/src/soap/header.rs ---
use crate::{
    cores::*,
    ws_addressing::AddressValue,
    ws_management::{OptionSetValue, SelectorSetValue},
};

#[derive(
    Debug,
    Clone,
    typed_builder::TypedBuilder,
    protocol_macros::SimpleTagValue,
    protocol_macros::SimpleXmlDeserialize,
)]
pub struct SoapHeaders<'a> {
    /// WS-Addressing headers
    #[builder(default, setter(into, strip_option))]
    pub to: Option<Tag<'a, Text<'a>, To>>,
    #[builder(default, setter(into, strip_option))]
    pub action: Option<Tag<'a, Text<'a>, Action>>,
    #[builder(default, setter(into, strip_option))]
    pub reply_to: Option<Tag<'a, AddressValue<'a>, ReplyTo>>,
    #[builder(default, setter(into, strip_option))]
    pub message_id: Option<Tag<'a, WsUuid, MessageID>>,
    #[builder(default, setter(into, strip_option))]
    pub relates_to: Option<Tag<'a, Text<'a>, RelatesTo>>,

    /// WS-Management headers
    #[builder(default, setter(into, strip_option))]
    pub resource_uri: Option<Tag<'a, Text<'a>, ResourceURI>>,
    #[builder(default, setter(into, strip_option))]
    pub max_envelope_size: Option<Tag<'a, U32, MaxEnvelopeSize>>,
    #[builder(default, setter(into, strip_option))]
    pub locale: Option<Tag<'a, Empty, Locale>>,
    #[builder(default, setter(into, strip_option))]
    pub data_locale: Option<Tag<'a, Empty, DataLocale>>,
    #[builder(default, setter(into, strip_option))]
    pub session_id: Option<Tag<'a, WsUuid, SessionId>>,
    #[builder(default, setter(into, strip_option))]
    pub operation_id: Option<Tag<'a, WsUuid, OperationID>>,
    #[builder(default, setter(into, strip_option))]
    pub sequence_id: Option<Tag<'a, Text<'a>, SequenceId>>,
    #[builder(default, setter(into, strip_option(fallback_suffix = "_opt")))]
    pub option_set: Option<Tag<'a, OptionSetValue, OptionSet>>,
    #[builder(default, setter(into, strip_option(fallback_suffix = "_opt")))]
    pub selector_set: Option<Tag<'a, SelectorSetValue, SelectorSet>>,
    #[builder(default, setter(into, strip_option))]
    pub operation_timeout: Option<Tag<'a, Time, OperationTimeout>>,
    #[builder(default, setter(into, strip_option))]
    pub compression_type: Option<Tag<'a, Text<'a>, CompressionType>>,
}


--- File: crates/protocol-winrm/src/soap/mod.rs ---
pub mod body;
pub mod header;
pub mod parsing;

use xml::parser::{XmlDeserialize, XmlVisitor};

use crate::{
    cores::{Tag, TagValue, tag_name::*},
    soap::{body::SoapBody, header::SoapHeaders},
};

#[derive(Debug, Clone, typed_builder::TypedBuilder)]
pub struct SoapEnvelope<'a> {
    #[builder(default, setter(into, strip_option))]
    pub header: Option<Tag<'a, SoapHeaders<'a>, Header>>,
    #[builder(setter(into))]
    pub body: Tag<'a, SoapBody<'a>, Body>,
}

impl<'a> TagValue<'a> for SoapEnvelope<'a> {
    fn append_to_element(self, element: xml::builder::Element<'a>) -> xml::builder::Element<'a> {
        let envelope = element;

        if let Some(header) = self.header {
            envelope.add_child(header.into_element())
        } else {
            envelope
        }
        .add_child(self.body.into_element())
    }
}

pub struct SoapEnvelopeVisitor<'a> {
    pub header: Option<Tag<'a, SoapHeaders<'a>, Header>>,
    pub body: Option<Tag<'a, SoapBody<'a>, Body>>,
}

impl<'a> XmlVisitor<'a> for SoapEnvelopeVisitor<'a> {
    type Value = SoapEnvelope<'a>;

    fn visit_children(
        &mut self,
        node: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        Err(xml::XmlError::InvalidXml(format!(
            "Expected a single envelope, found {} children",
            node.count()
        )))
    }

    fn visit_node(&mut self, node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
        // Remove the is_root() check as it prevents parsing document root elements
        // The node should be an Envelope element regardless of its root status

        let header: Option<Tag<'_, SoapHeaders<'a>, Header>> = node
            .children()
            .find(|child| child.tag_name().name() == Header::TAG_NAME)
            .map(|child| {
                Tag::from_node(child).map_err(|e| xml::XmlError::InvalidXml(e.to_string()))
            })
            .transpose()?;

        // Header can be none
        self.header = header;

        let body: Option<Tag<'_, SoapBody<'a>, Body>> = node
            .children()
            .find(|child| child.tag_name().name() == Body::TAG_NAME)
            .map(|child| {
                Tag::from_node(child).map_err(|e| xml::XmlError::InvalidXml(e.to_string()))
            })
            .transpose()?;

        if body.is_none() {
            return Err(xml::XmlError::InvalidXml(
                "SoapEnvelope must contain a Body element".to_string(),
            ));
        }

        self.body = body;

        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        Ok(SoapEnvelope {
            header: self.header,
            body: self
                .body
                .ok_or_else(|| xml::XmlError::InvalidXml("Missing Soap Body".to_string()))?,
        })
    }
}

impl<'a> XmlDeserialize<'a> for SoapEnvelope<'a> {
    type Visitor = SoapEnvelopeVisitor<'a>;

    fn visitor() -> Self::Visitor {
        SoapEnvelopeVisitor {
            header: None,
            body: None,
        }
    }
}


--- File: crates/protocol-winrm/src/soap/parsing.rs ---
pub struct Soap<'a> {
    // pub ws_addressing_header: Option<crate::ws_addressing::WsAddressingHeaders<'a>>,
    // pub ws_management_header: Option<crate::ws_management::WsManagementHeader<'a>>,
    __phantom: std::marker::PhantomData<&'a ()>,
}


--- File: crates/protocol-winrm/src/test_macro.rs ---
use crate::cores::tag_name::*;
use crate::cores::{Tag, Text};
use protocol_macros::{SimpleTagValue, SimpleXmlDeserialize};

// Example struct with mixed required and optional fields using new derive macros
#[derive(Debug, Clone, SimpleTagValue, SimpleXmlDeserialize)]
pub struct TestStruct<'a> {
    pub action: Tag<'a, Text<'a>, Action>,        // Required
    pub message_id: Tag<'a, Text<'a>, MessageID>, // Required
    pub to: Option<Tag<'a, Text<'a>, To>>,        // Optional
    pub relates_to: Option<Tag<'a, Text<'a>, RelatesTo>>, // Optional
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cores::TagValue;
    use xml::parser::XmlDeserialize;

    #[test]
    fn test_serialization_and_deserialization_roundtrip() {
        // Create a test struct with both required and optional fields
        let original = TestStruct {
            action: Tag::new(Text::from("test-action")),
            message_id: Tag::new(Text::from("msg-123")),
            to: Some(Tag::new(Text::from("destination"))),
            relates_to: None, // This optional field is not set
        };

        // Test that the TagValue implementation works (serialize to XML)
        let element = xml::builder::Element::new("test");
        let _serialized_element = original.append_to_element(element);

        // The TagValue implementation worked if we got here without panicking

        // Test deserialization with a simple XML string
        let test_xml = r#"<test>
            <Action>test-action</Action>
            <MessageID>msg-123</MessageID>
            <To>destination</To>
        </test>"#;

        // Parse the XML back
        let doc = xml::parser::parse(test_xml).expect("Failed to parse XML");
        let root = doc.root_element();

        // Deserialize back to struct
        let deserialized = TestStruct::from_node(root).expect("Failed to deserialize");

        println!("Deserialized struct: {:#?}", deserialized);

        // Verify deserialization matches original
        assert_eq!(deserialized.action.value.as_ref(), "test-action");
        assert_eq!(deserialized.message_id.value.as_ref(), "msg-123");
        assert!(deserialized.to.is_some());
        assert_eq!(deserialized.to.unwrap().value.as_ref(), "destination");
        assert!(deserialized.relates_to.is_none());
    }

    #[test]
    fn test_deserialize_with_all_fields() {
        let xml = r#"
            <test xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing">
                <a:Action>test-action</a:Action>
                <a:MessageID>msg-123</a:MessageID>
                <a:To>destination</a:To>
                <a:RelatesTo>relation-123</a:RelatesTo>
            </test>
        "#;

        let doc = xml::parser::parse(xml).expect("Failed to parse XML");
        let root = doc.root_element();

        let result = TestStruct::from_node(root).expect("Failed to deserialize");
        println!("Deserialized with all fields: {:#?}", result);

        // Verify required fields
        assert_eq!(result.action.value.as_ref(), "test-action");
        assert_eq!(result.message_id.value.as_ref(), "msg-123");

        // Verify optional fields
        assert!(result.to.is_some());
        assert_eq!(result.to.unwrap().value.as_ref(), "destination");
        assert!(result.relates_to.is_some());
        assert_eq!(result.relates_to.unwrap().value.as_ref(), "relation-123");
    }

    #[test]
    fn test_deserialize_with_only_required_fields() {
        let xml = r#"
            <test xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing">
                <a:Action>test-action</a:Action>
                <a:MessageID>msg-123</a:MessageID>
            </test>
        "#;

        let doc = xml::parser::parse(xml).expect("Failed to parse XML");
        let root = doc.root_element();

        let result = TestStruct::from_node(root).expect("Failed to deserialize");
        println!("Deserialized with required fields only: {:#?}", result);

        // Verify required fields
        assert_eq!(result.action.value.as_ref(), "test-action");
        assert_eq!(result.message_id.value.as_ref(), "msg-123");

        // Verify optional fields are None
        assert!(result.to.is_none());
        assert!(result.relates_to.is_none());
    }

    #[test]
    fn test_deserialize_missing_required_field() {
        let xml = r#"
            <test xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing">
                <a:Action>test-action</a:Action>
                <!-- Missing MessageID -->
            </test>
        "#;

        let doc = xml::parser::parse(xml).expect("Failed to parse XML");
        let root = doc.root_element();

        let result = TestStruct::from_node(root);
        assert!(result.is_err());
        println!(
            "Expected error for missing required field: {:?}",
            result.err()
        );
    }
}


--- File: crates/protocol-winrm/src/ws_addressing/mod.rs ---
use protocol_macros::{SimpleTagValue, SimpleXmlDeserialize};

use crate::cores::{Tag, tag_name::*, tag_value::Text};

#[derive(Debug, Clone, SimpleTagValue, SimpleXmlDeserialize)]
pub struct AddressValue<'a> {
    pub url: Tag<'a, Text<'a>, Address>,
}

// impl<'a> TagValue<'a> for AddressValue<'a> {
//     fn append_to_element(self, element: xml::builder::Element<'a>) -> xml::builder::Element<'a> {
//         let inner_element = self.url.into_element();
//         element.add_child(inner_element)
//     }
// }

// pub struct AddressVisitor<'a> {
//     address: Option<AddressValue<'a>>,
// }

// impl<'a> XmlVisitor<'a> for AddressVisitor<'a> {
//     type Value = AddressValue<'a>;

//     fn visit_children(
//         &mut self,
//         children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
//     ) -> Result<(), xml::XmlError> {
//         for child in children {
//             if !child.is_element() {
//                 continue;
//             }

//             match (child.tag_name().name(), child.tag_name().namespace()) {
//                 (Address::TAG_NAME, Address::NAMESPACE) => {
//                     let tag = Tag::from_node(child)?;
//                     self.address = Some(AddressValue { url: tag });
//                 }
//                 _ => {
//                     warn!(
//                         "Unexpected child element in AddressValue: {}",
//                         child.tag_name().name()
//                     );
//                 }
//             }
//         }

//         Ok(())
//     }

//     fn finish(self) -> Result<Self::Value, xml::XmlError> {
//         Ok(AddressValue {
//             url: self.address.ok_or_else(|| {
//                 xml::XmlError::NotSupposeToBeCalled {
//                     extra_info: "AddressValue must contain an Address element".to_string(),
//                 }
//             }?),
//         })
//     }
// }

// impl<'a> XmlDeserialize<'a> for AddressValue<'a> {
//     type Visitor = AddressVisitor<'a>;

//     fn visitor() -> Self::Visitor {
//         AddressVisitor { address: None }
//     }
// }


--- File: crates/protocol-winrm/src/ws_management/body.rs ---
use protocol_macros::{SimpleTagValue, SimpleXmlDeserialize};
use xml::builder::Element;

use crate::{
    cores::{ResourceURI, SelectorSet, Tag, TagValue, tag_name::*, tag_value::Text},
    ws_management::SelectorSetValue,
};

// Enumeration operations
#[derive(Debug, Clone)]
pub struct EnumerateValue<'a> {
    pub optimize_enumeration: Option<bool>,
    pub max_elements: Option<u32>,
    pub filter: Option<Text<'a>>,
}

impl<'a> EnumerateValue<'a> {
    pub fn new() -> Self {
        Self {
            optimize_enumeration: None,
            max_elements: None,
            filter: None,
        }
    }

    pub fn with_optimization(mut self, optimize: bool) -> Self {
        self.optimize_enumeration = Some(optimize);
        self
    }

    pub fn with_max_elements(mut self, max: u32) -> Self {
        self.max_elements = Some(max);
        self
    }

    pub fn with_filter(mut self, filter: Text<'a>) -> Self {
        self.filter = Some(filter);
        self
    }
}

impl<'a> Default for EnumerateValue<'a> {
    fn default() -> Self {
        Self::new()
    }
}

impl<'a> TagValue<'a> for EnumerateValue<'a> {
    fn append_to_element(self, _element: Element<'a>) -> Element<'a> {
        todo!("[EnumerateValue] Implement into_element");
    }
}

#[derive(Debug, Clone)]
pub struct PullValue<'a> {
    pub enumeration_context: Text<'a>,
    pub max_elements: Option<u32>,
}

impl<'a> PullValue<'a> {
    pub fn new(enumeration_context: Text<'a>) -> Self {
        Self {
            enumeration_context,
            max_elements: None,
        }
    }

    pub fn with_max_elements(mut self, max: u32) -> Self {
        self.max_elements = Some(max);
        self
    }
}

impl<'a> TagValue<'a> for PullValue<'a> {
    fn append_to_element(self, mut element: Element<'a>) -> Element<'a> {
        let context_elem = Element::new("EnumerationContext")
            .set_namespace("http://schemas.xmlsoap.org/ws/2004/09/enumeration")
            .set_text(self.enumeration_context);

        element = element.add_child(context_elem);

        if let Some(max) = self.max_elements {
            let max_elem = Element::new("MaxElements").set_text_owned(max.to_string());

            element = element.add_child(max_elem);
        }

        element
    }
}

#[derive(Debug, Clone)]
pub struct ReleaseValue<'a> {
    pub enumeration_context: Text<'a>,
}

impl<'a> ReleaseValue<'a> {
    pub fn new(enumeration_context: Text<'a>) -> Self {
        Self {
            enumeration_context,
        }
    }
}

impl<'a> TagValue<'a> for ReleaseValue<'a> {
    fn append_to_element(self, element: Element<'a>) -> Element<'a> {
        let context_elem = Element::new("EnumerationContext")
            .set_namespace("http://schemas.xmlsoap.org/ws/2004/09/enumeration")
            .set_text(self.enumeration_context);

        element.add_child(context_elem)
    }
}

#[derive(Debug, Clone)]
pub struct GetStatusValue<'a> {
    pub enumeration_context: Text<'a>,
}

impl<'a> GetStatusValue<'a> {
    pub fn new(enumeration_context: Text<'a>) -> Self {
        Self {
            enumeration_context,
        }
    }
}

impl<'a> TagValue<'a> for GetStatusValue<'a> {
    fn append_to_element(self, element: Element<'a>) -> Element<'a> {
        let context_elem = Element::new("EnumerationContext")
            .set_namespace("http://schemas.xmlsoap.org/ws/2004/09/enumeration")
            .set_text(self.enumeration_context);

        element.add_child(context_elem)
    }
}

#[derive(Debug, Clone, SimpleTagValue, SimpleXmlDeserialize)]
pub struct ReferenceParametersValue<'a> {
    pub resource_uri: Tag<'a, Text<'a>, ResourceURI>,
    pub selector_set: Tag<'a, SelectorSetValue, SelectorSet>,
}

#[derive(Debug, Clone, SimpleTagValue, SimpleXmlDeserialize)]
pub struct ResourceCreatedValue<'a> {
    pub address: Tag<'a, Text<'a>, Address>,
    pub reference_parameters: Tag<'a, ReferenceParametersValue<'a>, ReferenceParameters>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use xml::parser::XmlDeserialize;

    #[test]
    fn test_resource_created_value_deserialize() {
        let xml = r#"
            <x:ResourceCreated 
                xmlns:x="http://schemas.xmlsoap.org/ws/2004/09/transfer"
                xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"
                xmlns:w="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"
            >
    <a:Address>
        http://10.10.0.3:5985/wsman?PSVersion=7.4.10
        </a:Address>
    <a:ReferenceParameters>
        <w:ResourceURI>
            http://schemas.microsoft.com/powershell/Microsoft.PowerShell
            </w:ResourceURI>
        <w:SelectorSet>
            <w:Selector
                Name="ShellId">
                2D6534D0-6B12-40E3-B773-CBA26459CFA8
                </w:Selector>
            </w:SelectorSet>
        </a:ReferenceParameters>
    </x:ResourceCreated>
        "#;

        let element = xml::parser::parse(xml).unwrap();
        let root = element.root_element();
        let tag: Tag<'_, ResourceCreatedValue, ResourceCreated> = Tag::from_node(root).unwrap();
        let value = tag.value;

        assert_eq!(
            value.address.value,
            "http://10.10.0.3:5985/wsman?PSVersion=7.4.10".into()
        );
        assert_eq!(
            value
                .reference_parameters
                .as_ref()
                .resource_uri
                .as_ref()
                .as_ref(),
            "http://schemas.microsoft.com/powershell/Microsoft.PowerShell"
        );
    }
}


--- File: crates/protocol-winrm/src/ws_management/header.rs ---
use std::collections::HashMap;

use tracing::warn;
use xml::{
    builder::Element,
    parser::{XmlDeserialize, XmlVisitor},
};

use crate::cores::{self, OptionTagName, Selector, Tag, TagName, TagValue, Text};

#[derive(Debug, Clone)]
pub struct SelectorSetValue {
    pub selectors: HashMap<String, String>,
}

impl SelectorSetValue {
    pub fn new() -> Self {
        Self {
            selectors: HashMap::new(),
        }
    }

    /// Add a selector as a key-value pair
    /// Example:
    /// selector_set.add_selector("ShellId", "12345-67890")
    /// Generates: <w:Selector Name="ShellId">12345-67890</w:Selector>
    pub fn add_selector(mut self, name: impl Into<String>, value: impl Into<String>) -> Self {
        self.selectors.insert(name.into(), value.into());
        self
    }

    /// Add a selector using a mutable reference for chaining
    pub fn insert_selector(&mut self, name: impl Into<String>, value: impl Into<String>) {
        self.selectors.insert(name.into(), value.into());
    }

    pub fn get(&self, name: &str) -> Option<&String> {
        self.selectors.get(name)
    }
}

impl Default for SelectorSetValue {
    fn default() -> Self {
        Self::new()
    }
}

impl<'a> TagValue<'a> for SelectorSetValue {
    fn append_to_element(self, mut element: Element<'a>) -> Element<'a> {
        for (name, value) in self.selectors {
            let selector = Tag::from_name(Selector)
                .with_value(Text::from(value))
                .with_attribute(crate::cores::Attribute::Name(name.into()));

            let selector = selector.into_element();

            element = element.add_child(selector);
        }

        element
    }
}

pub struct SelectorSetVisitor {
    selectors: HashMap<String, String>,
}

impl<'a> XmlVisitor<'a> for SelectorSetVisitor {
    type Value = SelectorSetValue;

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        for child in children {
            if !child.is_element() {
                continue;
            }

            match (child.tag_name().name(), child.tag_name().namespace()) {
                (Selector::TAG_NAME, Selector::NAMESPACE) => {
                    // Extract Name attribute and text content
                    let mut name = None;
                    for attr in child.attributes() {
                        if attr.name() == "Name" {
                            name = Some(attr.value().to_string());
                            break;
                        }
                    }

                    if let Some(name) = name {
                        let value = child.text().unwrap_or_default().to_string();
                        self.selectors.insert(name, value);
                    } else {
                        warn!("Selector element missing Name attribute");
                    }
                }
                _ => {
                    warn!(
                        "Unexpected child element in SelectorSetValue: {} (namespace: {:?})",
                        child.tag_name().name(),
                        child.tag_name().namespace()
                    );
                }
            }
        }

        Ok(())
    }

    fn visit_node(&mut self, _node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
        // SelectorSetValue doesn't need to process individual nodes, only children
        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        Ok(SelectorSetValue {
            selectors: self.selectors,
        })
    }
}

impl<'a> XmlDeserialize<'a> for SelectorSetValue {
    type Visitor = SelectorSetVisitor;

    fn visitor() -> Self::Visitor {
        SelectorSetVisitor {
            selectors: HashMap::new(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct OptionSetValue {
    pub options: HashMap<String, String>,
}

impl Default for OptionSetValue {
    fn default() -> Self {
        Self::new()
    }
}

impl OptionSetValue {
    pub fn new() -> Self {
        Self {
            options: HashMap::new(),
        }
    }

    /// Add an option as a key-value pair
    /// Example:
    /// option_set.add_option("WINRS_CONSOLEMODE_STDIN", "TRUE")
    /// Generates: <w:Option Name="WINRS_CONSOLEMODE_STDIN">TRUE</w:Option>
    pub fn add_option(mut self, name: impl Into<String>, value: impl Into<String>) -> Self {
        self.options.insert(name.into(), value.into());
        self
    }

    /// Add an option using a mutable reference for chaining
    pub fn insert_option(&mut self, name: impl Into<String>, value: impl Into<String>) {
        self.options.insert(name.into(), value.into());
    }
}

impl<'a> TagValue<'a> for OptionSetValue {
    fn append_to_element(self, mut element: Element<'a>) -> Element<'a> {
        for (name, value) in self.options {
            let option_element = Element::new("Option")
                .set_namespace(xml::builder::Namespace::from(
                    OptionTagName::NAMESPACE.expect("OptionTagName definately has a namespace"),
                ))
                .set_text(value)
                .add_attribute(cores::Attribute::Name(name.into()).into())
                .add_attribute(cores::Attribute::MustComply(true).into());
            element = element.add_child(option_element);
        }

        element
    }
}

pub struct OptionSetVisitor {
    options: HashMap<String, String>,
}

impl<'a> XmlVisitor<'a> for OptionSetVisitor {
    type Value = OptionSetValue;

    fn visit_children(
        &mut self,
        children: impl Iterator<Item = xml::parser::Node<'a, 'a>>,
    ) -> Result<(), xml::XmlError> {
        for child in children {
            if !child.is_element() {
                continue;
            }

            match (child.tag_name().name(), child.tag_name().namespace()) {
                (OptionTagName::TAG_NAME, OptionTagName::NAMESPACE) => {
                    // Extract Name attribute and text content
                    let mut name = None;
                    for attr in child.attributes() {
                        if attr.name() == "Name" {
                            name = Some(attr.value().to_string());
                            break;
                        }
                    }

                    if let Some(name) = name {
                        let value = child.text().unwrap_or_default().to_string();
                        self.options.insert(name, value);
                    } else {
                        warn!("Option element missing Name attribute");
                    }
                }
                _ => {
                    warn!(
                        "Unexpected child element in OptionSetValue: {} (namespace: {:?})",
                        child.tag_name().name(),
                        child.tag_name().namespace()
                    );
                }
            }
        }

        Ok(())
    }

    fn visit_node(&mut self, _node: xml::parser::Node<'a, 'a>) -> Result<(), xml::XmlError> {
        // OptionSetValue doesn't need to process individual nodes, only children
        Ok(())
    }

    fn finish(self) -> Result<Self::Value, xml::XmlError> {
        Ok(OptionSetValue {
            options: self.options,
        })
    }
}

impl<'a> XmlDeserialize<'a> for OptionSetValue {
    type Visitor = OptionSetVisitor;

    fn visitor() -> Self::Visitor {
        OptionSetVisitor {
            options: HashMap::new(),
        }
    }
}


--- File: crates/protocol-winrm/src/ws_management/mod.rs ---
pub mod body;
pub mod header;
pub use header::*;

use crate::{
    cores::{Attribute, Tag, Time, WsUuid, namespace::Namespace, tag_name::*, tag_value::Text},
    soap::{SoapEnvelope, body::SoapBody, header::SoapHeaders},
    ws_addressing::AddressValue,
};

#[derive(Debug, Clone, typed_builder::TypedBuilder)]
pub struct WsMan {
    #[builder(default = 512000)]
    max_envelope_size: u32,

    #[builder(default = 180)]
    operation_timeout: u32,

    #[builder(default = "en-CA".to_string())]
    data_locale: String,

    #[builder(default = "en-US".to_string())]
    locale: String,

    #[builder(default = "http://schemas.microsoft.com/powershell/Microsoft.PowerShell".to_string())]
    resource_uri: String,

    #[builder(default = uuid::Uuid::new_v4())]
    session_id: uuid::Uuid,

    to: String,
}

impl WsMan {
    pub fn max_envelope_size(&self) -> u32 {
        self.max_envelope_size
    }
}

#[derive(Debug, Clone)]
pub enum WsAction {
    Create,
    Delete,
    Get,
    Put,
    Command,
    CommandResponse,
    ShellReceive,
    ShellCreate,
    Send,
}

impl WsAction {
    pub fn as_str(&self) -> &str {
        match self {
            WsAction::Create => "http://schemas.xmlsoap.org/ws/2004/09/transfer/Create",
            WsAction::Delete => "http://schemas.xmlsoap.org/ws/2004/09/transfer/Delete",
            WsAction::Get => "http://schemas.xmlsoap.org/ws/2004/09/transfer/Get",
            WsAction::Put => "http://schemas.xmlsoap.org/ws/2004/09/transfer/Put",
            WsAction::Command => "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Command",
            WsAction::CommandResponse => {
                "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/CommandResponse"
            }
            WsAction::ShellReceive => {
                "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Receive"
            } // See note below
            WsAction::ShellCreate => {
                "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/create"
            }
            WsAction::Send => "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Send",
        }
    }
}

impl WsMan {
    pub fn invoke<'a>(
        &'a self,
        action: WsAction,
        resource_uri: Option<&'a str>,
        resource_body: SoapBody<'a>,
        option_set: Option<header::OptionSetValue>,
        selector_set: Option<header::SelectorSetValue>,
    ) -> Tag<'a, SoapEnvelope<'a>, Envelope> {
        // Generate a unique message ID and operation ID for this request
        let message_id = uuid::Uuid::new_v4();
        let operation_id = uuid::Uuid::new_v4();

        let resource_uri = resource_uri.unwrap_or(self.resource_uri.as_str());

        // Create reply-to address value
        let reply_to_addr = AddressValue {
            url: Tag::new("http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous"),
        };

        // Create the SOAP header with all required fields
        let header = SoapHeaders::builder()
            .action(
                Tag::new(action.as_str().to_owned())
                    .with_name(Action)
                    .with_attribute(Attribute::MustUnderstand(true)),
            )
            .data_locale(
                Tag::new(())
                    .with_attribute(Attribute::MustUnderstand(false))
                    .with_attribute(Attribute::XmlLang(self.data_locale.clone().into())),
            )
            .locale(
                Tag::new(())
                    .with_attribute(Attribute::XmlLang(self.locale.clone().into()))
                    .with_attribute(Attribute::MustUnderstand(false)),
            )
            .max_envelope_size(
                Tag::new(self.max_envelope_size).with_attribute(Attribute::MustUnderstand(true)),
            )
            .resource_uri(Tag::new(resource_uri).with_attribute(Attribute::MustUnderstand(true)))
            .operation_timeout(Time::from(self.operation_timeout))
            .message_id(message_id)
            .to(self.to.as_ref())
            .reply_to(Tag::new(reply_to_addr).with_attribute(Attribute::MustUnderstand(true)))
            .session_id(
                Tag::new(WsUuid(self.session_id)).with_attribute(Attribute::MustUnderstand(false)),
            )
            .operation_id(
                Tag::new(WsUuid(operation_id)).with_attribute(Attribute::MustUnderstand(false)),
            )
            .sequence_id(Tag::new(Text::from("1")).with_attribute(Attribute::MustUnderstand(false)))
            .option_set_opt(option_set.map(Tag::from).map(|t| {
                t.with_declaration(Namespace::XmlSchemaInstance)
                    .with_attribute(Attribute::MustUnderstand(true))
            }))
            .selector_set_opt(selector_set.map(Tag::from))
            .build();

        // TODO: I don't like this design; it's a bit problematic, but I guess I will live with it right now.
        let add_rsp_declaration = resource_body.command_line.is_some();

        // Create the complete SOAP envelope
        let envelope = SoapEnvelope::builder()
            .header(header)
            .body(resource_body)
            .build();

        // Convert to XML using Tag wrapper with proper namespaces

        let mut soap = Tag::<SoapEnvelope, Envelope>::new(envelope)
            .with_declaration(Namespace::SoapEnvelope2003)
            .with_declaration(Namespace::WsAddressing2004)
            .with_declaration(Namespace::DmtfWsmanSchema)
            .with_declaration(Namespace::MsWsmanSchema);

        if add_rsp_declaration {
            soap = soap.with_declaration(Namespace::WsmanShell)
        }

        soap
    }
}


--- File: crates/protocol-winrm/tests/resources/receive_response.xml ---
<s:Envelope xml:lang="en-US"
	xmlns:s="http://www.w3.org/2003/05/soap-envelope"
	xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"
	xmlns:w="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"
	xmlns:rsp="http://schemas.microsoft.com/wbem/wsman/1/windows/shell"
	xmlns:p="http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd">
	<s:Header>
		<a:Action>http://schemas.microsoft.com/wbem/wsman/1/windows/shell/ReceiveResponse</a:Action>
		<a:MessageID>uuid:6C334787-EF2C-40E4-992F-DE4599ED2505</a:MessageID>
		<a:To>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:To>
		<p:OperationID s:mustUnderstand="false">uuid:672d68a1-9782-4f78-bebc-8b5db2355fda</p:OperationID>
		<p:SequenceId>1</p:SequenceId>
		<a:RelatesTo>uuid:87d0a667-c08e-4311-8d2d-069367f452d8</a:RelatesTo>
	</s:Header>
	<s:Body>
		<rsp:ReceiveResponse>
			<rsp:Stream Name="stdout">AAAAAAAAAAMAAAAAAAAAAAMAAABnAQAAAAUQAgBsDPVb/zVH8pB752JScmEJAAAAAAAAAAAAAAAAAAAAAO+7vzxPYmogUmVmSWQ9IjAiPjxNUz48STMyIE49IlJ1bnNwYWNlU3RhdGUiPjI8L0kzMj48L01TPjwvT2JqPg==</rsp:Stream>
		</rsp:ReceiveResponse>
	</s:Body>
</s:Envelope>

--- File: crates/protocol-winrm/tests/resources/resource_created.xml ---
<s:Envelope xml:lang="en-US"
        xmlns:s="http://www.w3.org/2003/05/soap-envelope"
        xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"
        xmlns:x="http://schemas.xmlsoap.org/ws/2004/09/transfer"
        xmlns:w="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"
        xmlns:rsp="http://schemas.microsoft.com/wbem/wsman/1/windows/shell"
        xmlns:p="http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd">
        <s:Header>
                <a:Action>
            http://schemas.xmlsoap.org/ws/2004/09/transfer/CreateResponse
                </a:Action>
                <a:MessageID>
            uuid:EE5AE413-9C9F-42DA-8692-559D248E1837
                </a:MessageID>
                <p:OperationID s:mustUnderstand="false">
            uuid:9178a378-f1b0-4ede-9ee2-52e43056aa28
                </p:OperationID>
                <p:SequenceId>
            1
                </p:SequenceId>
                <a:To>
            http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous
                </a:To>
                <a:RelatesTo>
            uuid:622d032a-f9b3-498d-b447-1359c3bb14f3
                </a:RelatesTo>
        </s:Header>
        <s:Body>
                <x:ResourceCreated>
                        <a:Address> http://10.10.0.3:5985/wsman?PSVersion=7.4.10
                        </a:Address>
                        <a:ReferenceParameters>
                                <w:ResourceURI>
                    http://schemas.microsoft.com/powershell/Microsoft.PowerShell
                                </w:ResourceURI>
                                <w:SelectorSet>
                                        <w:Selector Name="ShellId">
                        07936B27-7752-4325-8B0D-E7A1E9448320
                                        </w:Selector>
                                </w:SelectorSet>
                        </a:ReferenceParameters>
                </x:ResourceCreated>
                <rsp:Shell xmlns:rsp="http://schemas.microsoft.com/wbem/wsman/1/windows/shell">
                        <rsp:ShellId>
                07936B27-7752-4325-8B0D-E7A1E9448320
                        </rsp:ShellId>
                        <rsp:Name>
                Runspace1
                        </rsp:Name>
                        <rsp:ResourceUri>
                http://schemas.microsoft.com/powershell/Microsoft.PowerShell
                        </rsp:ResourceUri>
                        <rsp:Owner>
                Administrator
                        </rsp:Owner>
                        <rsp:ClientIP>
                10.10.0.1
                        </rsp:ClientIP>
                        <rsp:ProcessId>
                6228
                        </rsp:ProcessId>
                        <rsp:IdleTimeOut>
                PT7200.000S
                        </rsp:IdleTimeOut>
                        <rsp:InputStreams>
                stdin pr
                        </rsp:InputStreams>
                        <rsp:OutputStreams>
                stdout
                        </rsp:OutputStreams>
                        <rsp:MaxIdleTimeOut>
                PT2147483.647S
                        </rsp:MaxIdleTimeOut>
                        <rsp:Locale>
                en-US
                        </rsp:Locale>
                        <rsp:DataLocale>
                en-CA
                        </rsp:DataLocale>
                        <rsp:CompressionMode>
                XpressCompression
                        </rsp:CompressionMode>
                        <rsp:ProfileLoaded>
                Yes
                        </rsp:ProfileLoaded>
                        <rsp:Encoding>
                UTF8
                        </rsp:Encoding>
                        <rsp:BufferMode>
                Block
                        </rsp:BufferMode>
                        <rsp:State>
                Connected
                        </rsp:State>
                        <rsp:ShellRunTime>
                P0DT0H0M0S
                        </rsp:ShellRunTime>
                        <rsp:ShellInactivity>
                P0DT0H0M0S
                        </rsp:ShellInactivity>
                </rsp:Shell>
        </s:Body>
</s:Envelope>


--- File: crates/protocol-winrm/tests/test_initial_build_request.rs ---
use protocol_winrm::{
    cores::{Attribute, Tag, TagList, tag_name::*, tag_value::Text},
    rsp::rsp::ShellValue,
    soap::{SoapEnvelope, body::SoapBody, header::SoapHeaders},
    ws_addressing::AddressValue,
    ws_management::header::OptionSetValue,
};

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use protocol_winrm::cores::Time;

    use super::*;

    #[test]
    fn test_build_soap_envelope_for_shell_creation() {
        // Create an empty TagList for creation_xml (simplified for now)
        let _creation_xml_content = TagList::new();

        // Build the Shell content for the body
        let shell = ShellValue::builder()
            .name("Runspace1")
            .input_streams("stdin pr")
            .output_streams("stdout")
            .creation_xml("Mimic-the-base64-encoded XML content here")
            .build();

        // Create shell tag with attributes
        let shell_tag = Tag::new(shell)
            .with_name(Shell)
            .with_attribute(protocol_winrm::cores::Attribute::ShellId(
                "2D6534D0-6B12-40E3-B773-CBA26459CFA8".into(),
            ))
            .with_attribute(protocol_winrm::cores::Attribute::Name("Runspace1".into()));

        // Build the OptionSet with protocolversion
        let option_set_tag = OptionSetValue::new()
            .add_option("WINRS_CONSOLEMODE_STDIN", "TRUE")
            .add_option("protocolversion", "2.3");

        // Build ReplyTo with Address
        let reply_to_address = Tag::new(AddressValue {
            url: Tag::new(Text::from(
                "http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous",
            ))
            .with_name(Address)
            .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(true)),
        })
        .with_name(ReplyTo)
        .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(true));

        // Build the complete SOAP envelope
        let envelope = SoapEnvelope::builder()
            .header(
                SoapHeaders::builder()
                    // WS-Addressing headers
                    .to("http://10.10.0.3:5985/wsman?PSVersion=7.4.10")
                    .action(
                        Tag::new(Text::from(
                            "http://schemas.xmlsoap.org/ws/2004/09/transfer/Create",
                        ))
                        .with_name(Action)
                        .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(true)),
                    )
                    .reply_to(reply_to_address)
                    .message_id(
                        uuid::Uuid::from_str("D1D65143-B634-4725-BBF6-869CC4D3062F")
                            .expect("Failed to parse UUID"),
                    )
                    // WS-Management headers
                    .resource_uri(
                        Tag::new(Text::from(
                            "http://schemas.microsoft.com/powershell/Microsoft.PowerShell",
                        ))
                        .with_name(ResourceURI)
                        .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(true)),
                    )
                    .max_envelope_size(
                        Tag::new(512000)
                            .with_name(MaxEnvelopeSize)
                            .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(true)),
                    )
                    .locale(
                        Tag::new(()).with_name(Locale).with_attribute(
                            protocol_winrm::cores::Attribute::MustUnderstand(false),
                        ),
                    )
                    .data_locale(
                        Tag::new(()).with_name(DataLocale).with_attribute(
                            protocol_winrm::cores::Attribute::MustUnderstand(false),
                        ),
                    )
                    .session_id(
                        Tag::new(
                            uuid::Uuid::from_str("9EC885D6-F5A4-4771-9D47-4BDF7DAAEA8C")
                                .expect("Failed to parse UUID"),
                        )
                        .with_name(SessionId)
                        .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(false)),
                    )
                    .operation_id(
                        Tag::new(
                            uuid::Uuid::from_str("73C4BCA6-7FF0-4AFE-B8C3-335FB19BA649")
                                .expect("Failed to parse UUID"),
                        )
                        .with_name(OperationID)
                        .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(false)),
                    )
                    .sequence_id(
                        Tag::new(Text::from("1"))
                            .with_name(SequenceId)
                            .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(
                                false,
                            )),
                    )
                    .option_set(
                        Tag::new(option_set_tag)
                            .with_name(OptionSet)
                            .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(true)),
                    )
                    .operation_timeout(Time::from(60000))
                    .compression_type(
                        Tag::new(Text::from("xpress"))
                            .with_name(CompressionType)
                            .with_attribute(protocol_winrm::cores::Attribute::MustUnderstand(true)),
                    )
                    .build(),
            )
            .body(SoapBody::builder().shell(shell_tag).build())
            .build();

        // Convert envelope to Tag and add namespace declarations
        let envelope: Tag<'_, _, Envelope> = envelope.into();
        let envelope = envelope
            .with_declaration(protocol_winrm::cores::namespace::Namespace::SoapEnvelope2003)
            .with_declaration(protocol_winrm::cores::namespace::Namespace::WsAddressing2004)
            .with_declaration(protocol_winrm::cores::namespace::Namespace::MsWsmanSchema)
            .with_declaration(protocol_winrm::cores::namespace::Namespace::WsTransfer2004)
            .with_declaration(protocol_winrm::cores::namespace::Namespace::WsmanShell)
            .with_declaration(protocol_winrm::cores::namespace::Namespace::DmtfWsmanSchema)
            .with_declaration(protocol_winrm::cores::namespace::Namespace::PowerShellRemoting);

        // Convert Tag to Element
        let element = envelope.into_element();

        // Create XML builder and convert to string
        let xml_builder = xml::builder::Builder::new(None, element);
        let xml_string = xml_builder.to_xml_string().expect("Failed to build XML");

        // Assertions to verify the generated XML structure
        assert!(xml_string.contains("s:Envelope"));
        assert!(xml_string.contains("s:Header"));
        assert!(xml_string.contains("s:Body"));
        assert!(xml_string.contains("a:Action"));
        assert!(xml_string.contains("a:MessageID"));
        assert!(xml_string.contains("rsp:Shell"));
        assert!(xml_string.contains("Runspace1"));
        assert!(xml_string.contains("2D6534D0-6B12-40E3-B773-CBA26459CFA8"));
        assert!(xml_string.contains("http://schemas.xmlsoap.org/ws/2004/09/transfer/Create"));

        // Print the XML for debugging purposes
        println!("Generated SOAP Envelope:\n{}", xml_string);
    }

    #[test]
    fn test_shell_value_builder() {
        let shell = ShellValue::builder()
            .name("TestShell")
            .input_streams("stdin")
            .output_streams("stdout stderr")
            .creation_xml("test xml content")
            .build();

        // Verify the shell was built correctly
        // The fields are Tag<Text, TagName> types, so we check if they are present
        assert!(shell.name.is_some());
        assert!(shell.input_streams.is_some());
        assert!(shell.output_streams.is_some());
        assert!(shell.creation_xml.is_some());

        // We can verify the text content by checking the value field
        if let Some(name_tag) = &shell.name {
            assert_eq!(name_tag.value, Text::from("TestShell"));
        }
        if let Some(input_tag) = &shell.input_streams {
            assert_eq!(input_tag.value, Text::from("stdin"));
        }
        if let Some(output_tag) = &shell.output_streams {
            assert_eq!(output_tag.value, Text::from("stdout stderr"));
        }
    }

    #[test]
    fn test_option_set_creation() {
        let option_set = OptionSetValue::new()
            .add_option("WINRS_CONSOLEMODE_STDIN", "TRUE")
            .add_option("protocolversion", "2.3");

        // Verify options were added correctly
        assert_eq!(option_set.options.len(), 2);

        // Find and verify the console mode option
        let console_value = option_set
            .options
            .get("WINRS_CONSOLEMODE_STDIN")
            .expect("Console mode option should exist");
        assert_eq!(console_value, "TRUE");

        // Find and verify the protocol version option
        let protocol_value = option_set
            .options
            .get("protocolversion")
            .expect("Protocol version option should exist");
        assert_eq!(protocol_value, "2.3");
    }
}


--- File: crates/protocol-winrm/tests/test_initial_deserialize_request.rs ---
use protocol_winrm::{cores::Attribute, soap::header::SoapHeaders};
use xml::parser::XmlDeserialize;

const SOAP_HEADER_XML: &'static str = r#"
    <s:Envelope
    xml:lang="en-US"
    xmlns:s="http://www.w3.org/2003/05/soap-envelope"
    xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"
    xmlns:x="http://schemas.xmlsoap.org/ws/2004/09/transfer"
    xmlns:w="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"
    xmlns:rsp="http://schemas.microsoft.com/wbem/wsman/1/windows/shell"
    xmlns:p="http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd">
    <s:Header>
        <a:Action>
            http://schemas.xmlsoap.org/ws/2004/09/transfer/CreateResponse
            </a:Action>
        <a:MessageID>
            uuid:E17CCBB8-6136-4FA1-95B2-0DEF618A9232
            </a:MessageID>
        <p:OperationID
            s:mustUnderstand="false">
            uuid:73C4BCA6-7FF0-4AFE-B8C3-335FB19BA649
            </p:OperationID>
        <p:SequenceId>
            1
            </p:SequenceId>
        <a:To>
            http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous
            </a:To>
        <a:RelatesTo>
            uuid:D1D65143-B634-4725-BBF6-869CC4D3062F
            </a:RelatesTo>
        </s:Header>
    <s:Body>
        <x:ResourceCreated>
            <a:Address>
                http://10.10.0.3:5985/wsman?PSVersion=7.4.10
                </a:Address>
            <a:ReferenceParameters>
                <w:ResourceURI>
                    http://schemas.microsoft.com/powershell/Microsoft.PowerShell
                    </w:ResourceURI>
                <w:SelectorSet>
                    <w:Selector
                        Name="ShellId">
                        2D6534D0-6B12-40E3-B773-CBA26459CFA8
                        </w:Selector>
                    </w:SelectorSet>
                </a:ReferenceParameters>
            </x:ResourceCreated>
        <rsp:Shell
            xmlns:rsp="http://schemas.microsoft.com/wbem/wsman/1/windows/shell">
            <rsp:ShellId>
                2D6534D0-6B12-40E3-B773-CBA26459CFA8
                </rsp:ShellId>
            <rsp:Name>
                Runspace1
                </rsp:Name>
            <rsp:ResourceUri>
                http://schemas.microsoft.com/powershell/Microsoft.PowerShell
                </rsp:ResourceUri>
            <rsp:Owner>
                administrator
                </rsp:Owner>
            <rsp:ClientIP>
                10.10.0.1
                </rsp:ClientIP>
            <rsp:ProcessId>
                5812
                </rsp:ProcessId>
            <rsp:IdleTimeOut>
                PT7200.000S
                </rsp:IdleTimeOut>
            <rsp:InputStreams>
                stdin pr
                </rsp:InputStreams>
            <rsp:OutputStreams>
                stdout
                </rsp:OutputStreams>
            <rsp:MaxIdleTimeOut>
                PT2147483.647S
                </rsp:MaxIdleTimeOut>
            <rsp:Locale>
                en-US
                </rsp:Locale>
            <rsp:DataLocale>
                en-CA
                </rsp:DataLocale>
            <rsp:CompressionMode>
                XpressCompression
                </rsp:CompressionMode>
            <rsp:ProfileLoaded>
                Yes
                </rsp:ProfileLoaded>
            <rsp:Encoding>
                UTF8
                </rsp:Encoding>
            <rsp:BufferMode>
                Block
                </rsp:BufferMode>
            <rsp:State>
                Connected
                </rsp:State>
            <rsp:ShellRunTime>
                P0DT0H0M0S
                </rsp:ShellRunTime>
            <rsp:ShellInactivity>
                P0DT0H0M0S
                </rsp:ShellInactivity>
            </rsp:Shell>
        </s:Body>
    </s:Envelope>
    "#;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deserialize_soap_headers() {
        let node = xml::parser::parse(SOAP_HEADER_XML).expect("Failed to parse XML string");
        let envelope = node.root_element();

        let header = envelope
            .children()
            .find(|n| n.tag_name().name() == "Header")
            .expect("No Header found in SOAP envelope");

        let headers = SoapHeaders::from_node(header).expect("Failed to parse SOAP headers");

        // Test that expected fields are present
        assert!(headers.to.is_some());
        assert!(headers.action.is_some());
        assert!(headers.message_id.is_some());
        assert!(headers.relates_to.is_some());
        assert!(headers.operation_id.is_some());
        assert!(headers.sequence_id.is_some());

        // Test that fields not present in the header section are None
        assert!(headers.resource_uri.is_none());
        assert!(headers.reply_to.is_none());
        assert!(headers.max_envelope_size.is_none());
        assert!(headers.locale.is_none());
        assert!(headers.data_locale.is_none());
        assert!(headers.session_id.is_none());
        assert!(headers.option_set.is_none());
        assert!(headers.operation_timeout.is_none());
        assert!(headers.compression_type.is_none());
    }

    #[test]
    fn test_operation_id_must_understand_attribute() {
        let node = xml::parser::parse(SOAP_HEADER_XML).expect("Failed to parse XML string");
        let envelope = node.root_element();

        let header = envelope
            .children()
            .find(|n| n.tag_name().name() == "Header")
            .expect("No Header found in SOAP envelope");

        let headers = SoapHeaders::from_node(header).expect("Failed to parse SOAP headers");

        // Check that operation_id has the mustUnderstand attribute
        let must_understand_count = headers
            .operation_id
            .as_ref()
            .unwrap()
            .attributes
            .iter()
            .filter(|a| matches!(a, Attribute::MustUnderstand(_)))
            .count();

        assert_eq!(
            must_understand_count, 1,
            "OperationID should have exactly one MustUnderstand attribute"
        );
    }

    #[test]
    fn test_header_field_values() {
        let node = xml::parser::parse(SOAP_HEADER_XML).expect("Failed to parse XML string");
        let envelope = node.root_element();

        let header = envelope
            .children()
            .find(|n| n.tag_name().name() == "Header")
            .expect("No Header found in SOAP envelope");

        let headers = SoapHeaders::from_node(header).expect("Failed to parse SOAP headers");

        // Test specific values in the headers
        if let Some(_action) = &headers.action {
            // Assuming the action tag contains the text as its content
            // Adjust this based on the actual structure of the Tag type
            // This is a placeholder test - adjust based on actual Tag implementation
            // assert!(action.value.contains("CreateResponse"));
        }

        if let Some(_message_id) = &headers.message_id {
            // Test that message_id contains the expected UUID
            // assert!(message_id.value.contains("E17CCBB8-6136-4FA1-95B2-0DEF618A9232"));
        }

        if let Some(_to) = &headers.to {
            // Test that 'to' contains the expected anonymous role
            // assert!(to.value.contains("role/anonymous"));
        }

        // Add more specific assertions based on the actual Tag structure
    }

    #[test]
    fn test_xml_parsing_success() {
        // Test that the XML parsing itself succeeds
        let parse_result = xml::parser::parse(SOAP_HEADER_XML);
        assert!(parse_result.is_ok(), "XML should parse successfully");

        let node = parse_result.unwrap();
        let envelope = node.root_element();

        // Test basic structure
        assert_eq!(envelope.tag_name().name(), "Envelope");

        let header_count = envelope
            .children()
            .filter(|n| n.tag_name().name() == "Header")
            .count();
        assert_eq!(header_count, 1, "Should have exactly one Header element");

        let body_count = envelope
            .children()
            .filter(|n| n.tag_name().name() == "Body")
            .count();
        assert_eq!(body_count, 1, "Should have exactly one Body element");
    }

    #[test]
    #[tracing_test::traced_test]
    fn test_deserialize_with_minimal_header() {
        const MINIMAL_HEADER: &str = r#"
        <s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope"
                    xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing">
            <s:Header>
                <a:Action>test-action</a:Action>
                <a:MessageID>uuid:9178a378-f1b0-4ede-9ee2-52e43056aa28</a:MessageID>
            </s:Header>
            <s:Body></s:Body>
        </s:Envelope>
        "#;

        let node = xml::parser::parse(MINIMAL_HEADER).expect("Failed to parse minimal XML");
        let envelope = node.root_element();

        let header = envelope
            .children()
            .find(|n| n.tag_name().name() == "Header")
            .expect("No Header found in minimal SOAP envelope");

        let headers = SoapHeaders::from_node(header).expect("Failed to parse minimal SOAP headers");

        // Only action and message_id should be present
        assert!(headers.action.is_some());
        assert!(headers.message_id.is_some());

        // All other fields should be None
        assert!(headers.to.is_none());
        assert!(headers.relates_to.is_none());
        assert!(headers.operation_id.is_none());
        assert!(headers.sequence_id.is_none());
    }
}


--- File: crates/protocol-winrm/tests/test_parse_receive_response.rs ---
use protocol_winrm::soap::SoapEnvelope;
use std::fs;
use xml::parser::XmlDeserialize;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[tracing_test::traced_test]
    fn test_parse_receive_response_xml_to_soap_envelope() {
        let xml_content = fs::read_to_string("tests/resources/receive_response.xml")
            .expect("Failed to read receive_response.xml file");

        let document = xml::parser::parse(&xml_content).expect("Failed to parse XML content");
        let envelope_node = document.root_element();

        // ONLY TEST SoapEnvelope::from_node - this is what we want to validate
        let soap_envelope = SoapEnvelope::from_node(envelope_node)
            .expect("Failed to deserialize XML into SoapEnvelope");

        // ===== VALIDATE HEADER =====
        assert!(
            soap_envelope.header.is_some(),
            "SoapEnvelope should have a header"
        );

        let header = soap_envelope.header.as_ref().unwrap();

        // Validate all header fields that should be present in receive_response.xml
        assert!(header.value.action.is_some(), "Header should have Action");
        assert!(
            header.value.message_id.is_some(),
            "Header should have MessageID"
        );
        assert!(header.value.to.is_some(), "Header should have To");
        assert!(
            header.value.relates_to.is_some(),
            "Header should have RelatesTo"
        );
        assert!(
            header.value.operation_id.is_some(),
            "Header should have OperationID"
        );
        assert!(
            header.value.sequence_id.is_some(),
            "Header should have SequenceId"
        );

        // Validate action is for ReceiveResponse
        if let Some(action) = &header.value.action {
            let action_text: &str = action.value.as_ref();
            assert!(
                action_text.contains("ReceiveResponse"),
                "Action should contain 'ReceiveResponse', got: {}",
                action_text
            );
        }

        // Validate specific UUIDs from the wire capture
        if let Some(message_id) = &header.value.message_id {
            let uuid_str = format!("{}", message_id.value.0);
            assert!(
                uuid_str.contains("6c334787-ef2c-40e4-992f-de4599ed2505")
                    || uuid_str.contains("6C334787-EF2C-40E4-992F-DE4599ED2505"),
                "MessageID should match the wire capture, got: {}",
                uuid_str
            );
        }

        if let Some(relates_to) = &header.value.relates_to {
            let relates_to_text: &str = relates_to.value.as_ref();
            assert!(
                relates_to_text.contains("87d0a667-c08e-4311-8d2d-069367f452d8"),
                "RelatesTo should contain the expected UUID, got: {}",
                relates_to_text
            );
        }

        if let Some(operation_id) = &header.value.operation_id {
            let uuid_str = format!("{}", operation_id.value.0);
            assert!(
                uuid_str.contains("672d68a1-9782-4f78-bebc-8b5db2355fda")
                    || uuid_str.contains("672D68A1-9782-4F78-BEBC-8B5DB2355FDA"),
                "OperationID should match the wire capture, got: {}",
                uuid_str
            );
        }

        if let Some(sequence_id) = &header.value.sequence_id {
            let sequence_text: &str = sequence_id.value.as_ref();
            assert_eq!(
                sequence_text.trim(),
                "1",
                "SequenceId should be '1', got: '{}'",
                sequence_text
            );
        }

        // ===== VALIDATE BODY =====
        let body = soap_envelope.body.as_ref();
        assert!(
            body.receive_response.is_some(),
            "Body should have ReceiveResponse"
        );

        let receive_response = body.receive_response.as_ref().unwrap();

        // Validate that the ReceiveResponse contains streams
        assert!(
            !receive_response.value.streams.is_empty(),
            "ReceiveResponse should contain at least one stream"
        );

        // Validate the first stream
        let first_stream = &receive_response.value.streams[0];

        // The stream should have a Name attribute set to "stdout"
        let name_attr = first_stream
            .attributes
            .iter()
            .find(|attr| matches!(attr, protocol_winrm::cores::Attribute::Name(_)));
        assert!(name_attr.is_some(), "Stream should have a Name attribute");

        if let Some(protocol_winrm::cores::Attribute::Name(name)) = name_attr {
            assert_eq!(name, "stdout", "Stream name should be 'stdout'");
        }

        // The stream should contain the base64 encoded data
        let stream_content: &str = first_stream.value.as_ref();
        assert!(!stream_content.is_empty(), "Stream should contain data");

        // Verify it contains the base64 data from the XML
        let expected_base64 = "AAAAAAAAAAMAAAAAAAAAAAMAAABnAQAAAAUQAgBsDPVb/zVH8pB752JScmEJAAAAAAAAAAAAAAAAAAAAAO+7vzxPYmogUmVmSWQ9IjAiPjxNUz48STMyIE49IlJ1bnNwYWNlU3RhdGUiPjI8L0kzMj48L01TPjwvT2JqPg==";
        assert_eq!(
            stream_content.trim(),
            expected_base64,
            "Stream content should match the expected base64 data"
        );

        // Validate that other body fields are None (since they're not in this response)
        assert!(
            body.resource_created.is_none(),
            "Body should not have ResourceCreated"
        );
        assert!(body.shell.is_none(), "Body should not have Shell");
        assert!(body.command.is_none(), "Body should not have Command");
        assert!(body.receive.is_none(), "Body should not have Receive");
        assert!(
            body.command_response.is_none(),
            "Body should not have CommandResponse"
        );

        // Pretty print the complete parsed SOAP envelope structure
        println!("\n=== PARSED SOAP ENVELOPE STRUCTURE ===");
        println!("{:#?}", soap_envelope);
        println!("=== END SOAP ENVELOPE STRUCTURE ===\n");
    }
}


--- File: crates/protocol-winrm/tests/test_parse_resource_created.rs ---
use protocol_winrm::soap::SoapEnvelope;
use std::fs;
use xml::parser::XmlDeserialize;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_resource_created_xml_to_soap_envelope() {
        let xml_content = fs::read_to_string("tests/resources/resource_created.xml")
            .expect("Failed to read resource_created.xml file");

        let document = xml::parser::parse(&xml_content).expect("Failed to parse XML content");
        let envelope_node = document.root_element();

        // ONLY TEST SoapEnvelope::from_node - this is what we want to validate
        let soap_envelope = SoapEnvelope::from_node(envelope_node)
            .expect("Failed to deserialize XML into SoapEnvelope");

        // Validate the deserialization worked correctly
        assert!(
            soap_envelope.header.is_some(),
            "SoapEnvelope should have a header"
        );

        // Validate header fields were parsed correctly
        let header = soap_envelope.header.as_ref().unwrap();
        assert!(header.value.action.is_some(), "Header should have Action");
        assert!(
            header.value.message_id.is_some(),
            "Header should have MessageID"
        );
        assert!(header.value.to.is_some(), "Header should have To");
        assert!(
            header.value.relates_to.is_some(),
            "Header should have RelatesTo"
        );
        assert!(
            header.value.operation_id.is_some(),
            "Header should have OperationID"
        );
        assert!(
            header.value.sequence_id.is_some(),
            "Header should have SequenceId"
        );

        // Validate body was parsed
        // The body should contain the parsed content
        // Note: We can't easily inspect the body content without knowing its exact structure,
        // but we can verify the body exists and was parsed

        let body = soap_envelope.body.as_ref();
        assert!(
            body.resource_created.is_some(),
            "Body should have ResourceCreated"
        );
        let resource_created = body.resource_created.as_ref().unwrap().as_ref();

        // ResourceCreated now has required fields (Tag<..> not Option<Tag<..>>)
        // So we can access them directly without checking is_some()
        let _address = &resource_created.address; // This is a Tag<'a, Text<'a>, Address>
        let _reference_parameters = &resource_created.reference_parameters; // This is a Tag<'a, ReferenceParametersValue<'a>, ReferenceParameters>

        // Validate ReferenceParameters content
        // ReferenceParametersValue also has required fields now
        let ref_params = &resource_created.reference_parameters.value;
        let _resource_uri = &ref_params.resource_uri; // This is a Tag<'a, Text<'a>, ResourceURI>
        let _selector_set = &ref_params.selector_set; // This is a Tag<'a, SelectorSetValue, SelectorSet>

        // Validate that Shell element is also present (it should be ignored by ResourceCreated parser)
        assert!(body.shell.is_some(), "Body should also have Shell element");
    }
}


--- File: crates/pwsh-core/Cargo.toml ---
[package]
name = "pwsh-core"
version = "0.1.0"
edition = "2024"

[dependencies]
hyper = "1.6.0"
thiserror = "2.0.12"
uuid = { version = "1.17.0", features = ["v4"] }
protocol-winrm = {path = "../protocol-winrm"}
protocol-powershell-remoting = {path = "../protocol-powershell-remoting"}
xml = { path = "../xml" }
typed-builder = "0.21.0"
base64 = "0.22.1"
tracing = "0.1.41"


[dev-dependencies]
ureq = "2"
tracing-subscriber = {version = "0.3.19", features = ["env-filter"]}
tokio = { version = "1", features = ["full"] }
anyhow = "1"
regex = "1"

--- File: crates/pwsh-core/examples/README.md ---
# WinRM PowerShell Client Example

## Usage

The `connect.rs` example demonstrates a basic WinRM PowerShell client that connects to a remote Windows server.

### Configuration

Edit the following lines in `connect.rs` to match your test server:

```rust
let server = ServerAddress::Domain("your-server-ip".to_string()); // Change to your server
let port = 5985; // or 5986 for HTTPS
let scheme = Scheme::Http; // or Scheme::Https
let auth = Authentication::Basic {
    username: "your-username".to_string(),
    password: "your-password".to_string(),
};
```

### Running

```bash
cargo run -p pwsh-core --example connect
```

### Current Status

- ✅ Generates proper PowerShell negotiation messages (SessionCapability, InitRunspacePool)
- ✅ Fragments messages according to PowerShell remoting protocol
- ✅ Builds WS-Management SOAP envelopes
- ✅ Makes initial shell creation request
- ✅ Makes receive request
- ⚠️ ConnectReceiveCycle state hits `todo!()` (needs implementation)

### Expected Flow

1. **Idle → Connecting**: Sends shell creation request with PowerShell negotiation
2. **Connecting → ConnectReceiveCycle**: Processes shell creation response, sends receive request
3. **ConnectReceiveCycle**: Currently hits `todo!()` - needs to parse receive response and complete handshake

The client is ready for testing against real PowerShell servers and will help debug the protocol implementation step by step.

--- File: crates/pwsh-core/examples/connect/config.rs ---
use std::net::Ipv4Addr;

use pwsh_core::connector::{Authentication, ConnectorConfig, Scheme, http::ServerAddress};
use tracing_subscriber::EnvFilter;

/// Initialize logging with file output
pub fn init_logging() -> anyhow::Result<()> {
    let log_file = std::fs::File::create("winrm_client.log")?;
    tracing_subscriber::fmt::SubscriberBuilder::default()
        // Hide HTTP-related logs by setting them to ERROR level
        // Focus on our PowerShell remoting logic
        .with_env_filter(EnvFilter::new(
            "pwsh_core=debug,protocol_powershell_remoting=debug,protocol_winrm=info,ureq=error",
        ))
        .with_max_level(tracing::Level::DEBUG)
        .with_target(false)
        .with_line_number(true)
        .with_file(true)
        .with_writer(log_file)
        .init();
    Ok(())
}

/// Create the default connector configuration
pub fn create_connector_config() -> ConnectorConfig {
    // Configuration - modify these for your test server
    let server = ServerAddress::Ip(std::net::IpAddr::V4(Ipv4Addr::new(10, 10, 0, 3))); // Change to your server
    let port = 5985;
    let scheme = Scheme::Http;
    let auth = Authentication::Basic {
        username: "Administrator".to_string(),
        password: "DevoLabs123!".to_string(),
    };

    ConnectorConfig {
        server: (server, port),
        scheme,
        authentication: auth,
        host_info: protocol_powershell_remoting::HostInfo::builder()
            .is_host_null(false)
            .is_host_ui_null(true)
            .is_host_raw_ui_null(true)
            .build(),
    }
}


--- File: crates/pwsh-core/examples/connect/connection.rs ---
use anyhow::Context;
use pwsh_core::connector::active_session::ActiveSession;
use pwsh_core::connector::{Connector, ConnectorConfig, ConnectorStepResult};
use tracing::{info, info_span, warn};

use crate::http_client::make_http_request;

/// Establish connection to the PowerShell remote server
pub async fn establish_connection(
    config: ConnectorConfig,
) -> anyhow::Result<(
    ActiveSession,
    pwsh_core::connector::http::HttpRequest<String>,
)> {
    let mut connector = Connector::new(config);
    info!("Created connector, starting connection...");

    let mut response = None;
    let _span = info_span!("ConnectionLoop").entered();

    let (active_session, next_request) = loop {
        let step_result = connector
            .step(response.take())
            .context("Failed to step through connector")?;

        info!(step_result = ?step_result.name(), "Processing step result");

        match step_result {
            ConnectorStepResult::SendBack(http_request) => {
                // Make the HTTP request (using ureq for simplicity in example)
                response = Some(make_http_request(&http_request).await?);
            }
            ConnectorStepResult::SendBackError(e) => {
                warn!("Connection step failed: {}", e);
                anyhow::bail!("Connection failed: {}", e);
            }
            ConnectorStepResult::Connected {
                active_session,
                next_receive_request,
            } => {
                break (active_session, next_receive_request);
            }
        }
    };

    drop(_span);
    Ok((active_session, next_request))
}


--- File: crates/pwsh-core/examples/connect/http_client.rs ---
use tracing::{debug, info};

/// Make an HTTP request using ureq
pub async fn make_http_request(
    request: &pwsh_core::connector::http::HttpRequest<String>,
) -> Result<pwsh_core::connector::http::HttpResponse<String>, anyhow::Error> {
    info!("Making HTTP request to: {}", request.url);
    debug!("Request headers: {:?}", request.headers);
    debug!(
        "Request body length: {:?}",
        request.body.as_ref().map(|b| b.len())
    );

    // Build the HTTP client request
    let mut ureq_request = match request.method {
        pwsh_core::connector::http::Method::Post => ureq::post(&request.url),
        pwsh_core::connector::http::Method::Get => ureq::get(&request.url),
        pwsh_core::connector::http::Method::Put => ureq::put(&request.url),
        pwsh_core::connector::http::Method::Delete => ureq::delete(&request.url),
    };

    // Add headers
    for (name, value) in &request.headers {
        ureq_request = ureq_request.set(name, value);
    }

    // Add cookie if present
    if let Some(cookie) = &request.cookie {
        ureq_request = ureq_request.set("Cookie", cookie);
    }

    // Make the request
    let response = if let Some(body) = &request.body {
        ureq_request.send_string(body)?
    } else {
        ureq_request.call()?
    };

    // Read response
    let response_body = response.into_string()?;
    debug!("Response body length: {}", response_body.len());

    // Return as HttpResponse with proper response format
    Ok(pwsh_core::connector::http::HttpResponse {
        status_code: 200,
        headers: vec![],
        body: Some(response_body),
    })
}


--- File: crates/pwsh-core/examples/connect/main.rs ---
mod config;
mod connection;
mod http_client;
mod network;
mod types;
mod user_input;

use anyhow::Context;
use protocol_powershell_remoting::{PipelineOutput, PsPrimitiveValue, PsValue};
use pwsh_core::connector::ActiveSessionOutput;
use pwsh_core::connector::active_session::UserEvent;
use regex::Regex;
use tokio::sync::{mpsc, oneshot};
use tracing::{error, info, instrument, warn};

use config::{create_connector_config, init_logging};
use connection::establish_connection;
use network::spawn_network_handler;
use types::NextStep;
use user_input::spawn_user_input_handler;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    init_logging()?;
    let _span = tracing::span!(tracing::Level::INFO, "main").entered();
    info!("Starting WinRM PowerShell client");

    // Create configuration and establish connection
    let config = create_connector_config();
    let (active_session, next_request) = establish_connection(config).await?;
    info!("Runspace pool is now open and ready for operations!");

    // Set up communication channels
    let (network_request_tx, network_request_rx) = mpsc::channel(2);
    let (network_response_tx, network_response_rx) = mpsc::channel(2);
    let (user_request_tx, user_request_rx) = mpsc::channel(2);

    // Spawn network handler
    let handle = spawn_network_handler(network_request_rx, network_response_tx);

    // Set up pipeline creation
    let (pipeline_tx, pipeline_rx) = oneshot::channel();
    let handle2 = spawn_user_input_handler(user_request_tx.clone(), pipeline_rx);

    // Send initial network request
    network_request_tx
        .send(next_request)
        .await
        .context("Failed to send initial request")?;

    // Run the main event loop
    run_event_loop(
        active_session,
        network_response_rx,
        user_request_rx,
        network_request_tx,
        Some(pipeline_tx),
    )
    .await
    .inspect_err(|e| error!("Error in main event loop: {}", e))?;

    info!("Exiting main function");
    handle.abort();
    handle2.abort();
    drop(_span);
    Ok(())
}

/// Main event loop that processes network responses and user requests
#[instrument(skip_all)]
async fn run_event_loop(
    mut active_session: pwsh_core::connector::active_session::ActiveSession,
    mut network_response_rx: mpsc::Receiver<pwsh_core::connector::http::HttpResponse<String>>,
    mut user_request_rx: mpsc::Receiver<pwsh_core::connector::UserOperation>,
    network_request_tx: mpsc::Sender<pwsh_core::connector::http::HttpRequest<String>>,
    mut pipeline_tx: Option<oneshot::Sender<pwsh_core::powershell::PipelineHandle>>,
) -> anyhow::Result<()> {
    loop {
        let next_step = tokio::select! {
            network_response = network_response_rx.recv() => {
                if let Some(response) = network_response {
                    NextStep::NetworkResponse(response)
                } else {
                    error!("No response received from server");
                    return Err(anyhow::anyhow!("No response received from server"));
                }
            },
            user_request = user_request_rx.recv() => {
                if let Some(user_request) = user_request {
                    NextStep::UserRequest(Box::new(user_request))
                } else {
                    error!("No user request received");
                    return Err(anyhow::anyhow!("No user request received"));
                }
            },
        };

        info!("Processing next step: {next_step}");

        let step_results = match next_step {
            NextStep::NetworkResponse(http_response) => {
                info!(
                    "Processing network response with body length: {}",
                    http_response.body.as_ref().map(|b| b.len()).unwrap_or(0)
                );

                active_session
                    .accept_server_response(http_response)
                    .map_err(|e| {
                        error!("Failed to accept server response: {:#}", e);
                        e
                    })
                    .context("Failed to accept server response")?
            }
            NextStep::UserRequest(user_operation) => {
                info!("Processing user operation: {:?}", user_operation);

                vec![
                    active_session
                        .accept_client_operation(*user_operation)
                        .map_err(|e| {
                            error!("Failed to accept user operation: {:#}", e);
                            e
                        })
                        .context("Failed to accept user operation")?,
                ]
            }
        };

        info!(?step_results, "Received server response, processing...");

        for step_result in step_results {
            info!(?step_result, "Processing step result");
            match step_result {
                ActiveSessionOutput::SendBack(http_requests) => {
                    for http_request in http_requests {
                        network_request_tx
                            .send(http_request)
                            .await
                            .context("Failed to send HTTP request")?;
                    }
                }
                ActiveSessionOutput::SendBackError(e) => {
                    error!("Error in session step: {}", e);
                    return Err(anyhow::anyhow!("Session step failed: {}", e));
                }
                ActiveSessionOutput::UserEvent(event) => match event {
                    UserEvent::PipelineCreated { powershell } => {
                        info!("Pipeline created: {:?}", powershell);
                        let sent = pipeline_tx.take().map(|tx| tx.send(powershell));
                        if let Some(Err(_)) = sent {
                            error!("Failed to send pipeline through channel");
                            return Err(anyhow::anyhow!("Failed to send pipeline through channel"));
                        }
                    }
                },
                ActiveSessionOutput::HostCall(host_call) => {
                    info!(
                        "Received host call: method_name='{}', call_id={}",
                        host_call.method_name, host_call.call_id
                    );

                    let method = host_call.get_param().map_err(|e| {
                        error!("Failed to parse host call parameters: {:#}", e);
                        e
                    })?;

                    info!("Processing host call method: {:?}", method);

                    // Handle the host call and create a response
                    use pwsh_core::host::{HostCallMethodReturn, RawUIMethodReturn};

                    let response = match method {
                        // For GetBufferSize, return a default console buffer size
                        pwsh_core::host::HostCallMethodWithParams::RawUIMethod(
                            pwsh_core::host::RawUIMethodParams::GetBufferSize,
                        ) => {
                            info!("Handling GetBufferSize - returning default console size");
                            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferSize(
                                120, 30,
                            ))
                        }

                        // For WriteProgress, just acknowledge (void return)
                        pwsh_core::host::HostCallMethodWithParams::UIMethod(
                            pwsh_core::host::UIMethodParams::WriteProgress(source_id, record),
                        ) => {
                            info!(
                                "Handling WriteProgress - source_id={}, record={}",
                                source_id, record
                            );
                            HostCallMethodReturn::UIMethod(
                                pwsh_core::host::UIMethodReturn::WriteProgress,
                            )
                        }

                        // For other methods, return not implemented error for now
                        other => {
                            warn!("Host call method not implemented: {:?}", other);
                            HostCallMethodReturn::Error(pwsh_core::host::HostError::NotImplemented)
                        }
                    };

                    // Submit the response
                    let host_response = host_call.submit_result(response);
                    info!(
                        "Created host call response for call_id={}",
                        host_response.call_id
                    );

                    // For now, we're not sending the response back yet - that requires more infrastructure
                    // TODO: Implement sending host call responses back to the server
                }
                ActiveSessionOutput::OperationSuccess => {
                    info!("Operation completed successfully");
                }
            }
        }
    }
}

fn format_pipeline_output(output: &PipelineOutput) -> Result<String, anyhow::Error> {
    let Some(output_str) = output.data.as_string() else {
        return Err(anyhow::anyhow!("Pipeline output is not a string"));
    };

    decode_escaped_ps_string(&output_str)
}

/// Decode PowerShell Remoting Protocol escape sequences, like _x000A_
/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/301404a9-232f-439c-8644-1a213675bfac
fn decode_escaped_ps_string(input: &str) -> Result<String, anyhow::Error> {
    if input.is_empty() {
        return Ok(String::new());
    }

    // Split with capturing parentheses to include the separator in the resulting array
    let regex =
        Regex::new(r"(_x[0-9A-F]{4}_)").map_err(|e| anyhow::anyhow!("Regex error: {}", e))?;
    let parts: Vec<&str> = regex.split(input).collect();

    if parts.len() <= 1 {
        return Ok(input.to_string());
    }

    let mut result = String::new();
    let mut high_surrogate: Option<u16> = None;

    // We need to manually handle the split parts and captures
    let mut current_pos = 0;
    for captures in regex.find_iter(input) {
        // Add the text before the match
        if captures.start() > current_pos {
            result.push_str(&input[current_pos..captures.start()]);
            high_surrogate = None;
        }

        // Process the escaped sequence
        let escaped = captures.as_str();
        if let Some(hex_str) = escaped.strip_prefix("_x").and_then(|s| s.strip_suffix("_")) {
            match u16::from_str_radix(hex_str, 16) {
                Ok(code_unit) => {
                    if let Some(high) = high_surrogate {
                        // We have a high surrogate from before, try to form a surrogate pair
                        if (0xDC00..=0xDFFF).contains(&code_unit) {
                            // This is a low surrogate, form the pair
                            let code_point = 0x10000
                                + ((high as u32 - 0xD800) << 10)
                                + (code_unit as u32 - 0xDC00);
                            if let Some(ch) = char::from_u32(code_point) {
                                result.push(ch);
                            } else {
                                // Invalid code point, add the escaped sequence as-is
                                result.push_str(escaped);
                            }
                            high_surrogate = None;
                        } else {
                            // Not a low surrogate, add the previous high surrogate as-is and process this one
                            result.push_str("_x");
                            result.push_str(&format!("{:04X}", high));
                            result.push('_');

                            if (0xD800..=0xDBFF).contains(&code_unit) {
                                high_surrogate = Some(code_unit);
                            } else {
                                if let Some(ch) = char::from_u32(code_unit as u32) {
                                    result.push(ch);
                                } else {
                                    result.push_str(escaped);
                                }
                                high_surrogate = None;
                            }
                        }
                    } else if (0xD800..=0xDBFF).contains(&code_unit) {
                        // High surrogate, save it for the next iteration
                        high_surrogate = Some(code_unit);
                    } else {
                        // Regular character or low surrogate without high surrogate
                        if let Some(ch) = char::from_u32(code_unit as u32) {
                            result.push(ch);
                        } else {
                            // Invalid character, add the escaped sequence as-is
                            result.push_str(escaped);
                        }
                        high_surrogate = None;
                    }
                }
                Err(_) => {
                    // Invalid hex, add the escaped sequence as-is
                    result.push_str(escaped);
                    high_surrogate = None;
                }
            }
        } else {
            // Not a valid escape sequence, add as-is
            result.push_str(escaped);
            high_surrogate = None;
        }

        current_pos = captures.end();
    }

    // Add any remaining text after the last match
    if current_pos < input.len() {
        result.push_str(&input[current_pos..]);
    }

    // If we have an unmatched high surrogate at the end, add it as-is
    if let Some(high) = high_surrogate {
        result.push_str("_x");
        result.push_str(&format!("{:04X}", high));
        result.push('_');
    }

    Ok(result)
}


--- File: crates/pwsh-core/examples/connect/mod.rs ---
pub mod config;
pub mod connection;
pub mod http_client;
pub mod main;
pub mod network;
pub mod types;
pub mod user_input;

--- File: crates/pwsh-core/examples/connect/network.rs ---
use tokio::sync::mpsc;
use tracing::{Instrument, error, info_span};

use crate::http_client::make_http_request;

/// Spawn network request handler task
pub fn spawn_network_handler(
    mut network_request_rx: mpsc::Receiver<pwsh_core::connector::http::HttpRequest<String>>,
    network_response_tx: mpsc::Sender<pwsh_core::connector::http::HttpResponse<String>>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(
        async move {
            while let Some(request) = network_request_rx.recv().await {
                let network_response_tx = network_response_tx.clone();
                tokio::spawn(async move {
                    match make_http_request(&request).await {
                        Ok(response) => {
                            if let Err(e) = network_response_tx.send(response).await {
                                error!("Failed to send network response: {}", e);
                            }
                        }
                        Err(e) => {
                            error!("HTTP request failed: {}", e);
                        }
                    }
                });
            }
        }
        .instrument(info_span!("NetworkRequestHandler")),
    )
}


--- File: crates/pwsh-core/examples/connect/types.rs ---
use std::fmt;

use pwsh_core::connector::UserOperation;

/// Represents the next step in the event loop
#[derive(Debug)]
pub enum NextStep {
    NetworkResponse(pwsh_core::connector::http::HttpResponse<String>),
    UserRequest(Box<UserOperation>),
}

impl fmt::Display for NextStep {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            NextStep::NetworkResponse(_) => write!(f, "NetworkResponse"),
            NextStep::UserRequest(_) => write!(f, "UserRequest"),
        }
    }
}


--- File: crates/pwsh-core/examples/connect/user_input.rs ---
use pwsh_core::connector::active_session::PowershellOperations;
use pwsh_core::pipeline::PipelineCommand;
use pwsh_core::powershell::PipelineHandle;
use pwsh_core::{connector::UserOperation, powershell::PipelineOutputType};
use tokio::io::AsyncBufReadExt;
use tokio::sync::mpsc;
use tracing::{Instrument, error, info, info_span};

/// Handle user input for PowerShell commands
pub async fn handle_user_input(
    user_request_tx: mpsc::Sender<UserOperation>,
    pipeline: PipelineHandle,
) {
    info!("Pipeline ready! Enter PowerShell commands (type 'exit' to quit):");

    let stdin = tokio::io::stdin();
    let mut reader = tokio::io::BufReader::new(stdin);
    let mut line = String::new();

    loop {
        print!("> ");
        std::io::Write::flush(&mut std::io::stdout()).unwrap();

        line.clear();
        match reader.read_line(&mut line).await {
            Ok(0) => break, // EOF
            Ok(_) => {
                let command = line.trim().to_string();
                if command.to_lowercase() == "exit" {
                    info!("Exiting...");
                    break;
                }
                if !command.is_empty() {
                    // Add the script to the pipeline
                    if let Err(e) = user_request_tx
                        .send(UserOperation::OperatePipeline {
                            powershell: pipeline,
                            operation: PowershellOperations::AddCommand {
                                command: PipelineCommand::new_script(command),
                            },
                        })
                        .await
                    {
                        error!("Failed to send operation: {}", e);
                        break;
                    }

                    // Invoke the pipeline
                    if let Err(e) = user_request_tx
                        .send(UserOperation::InvokePipeline {
                            powershell: pipeline,
                            output_type: PipelineOutputType::Streamed,
                        })
                        .await
                    {
                        error!("Failed to send invoke: {}", e);
                        break;
                    }
                }
            }
            Err(e) => {
                error!("Failed to read input: {}", e);
                break;
            }
        }
    }
}

/// Spawn user input handler task
pub fn spawn_user_input_handler(
    user_request_tx: mpsc::Sender<UserOperation>,
    pipeline_rx: tokio::sync::oneshot::Receiver<PipelineHandle>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(
        async move {
            info!("Creating initial pipeline...");
            if let Err(e) = user_request_tx.send(UserOperation::CreatePipeline).await {
                error!("Failed to send create pipeline request: {}", e);
                return;
            }

            // Wait for pipeline to be created
            match pipeline_rx.await {
                Ok(pipeline) => {
                    handle_user_input(user_request_tx, pipeline).await;
                }
                Err(e) => {
                    error!("Failed to receive pipeline: {}", e);
                }
            }
        }
        .instrument(info_span!("UserInputHandler")),
    )
}


--- File: crates/pwsh-core/src/connector/active_session.rs ---
use crate::{
    connector::http::{HttpBuilder, HttpRequest, HttpResponse},
    host::{HostCallRequest, HostCallResponse, HostCallScope},
    pipeline::PipelineCommand,
    powershell::{PipelineHandle, PipelineOutputType},
    runspace_pool::{RunspacePool, pool::AcceptResponsResult},
};
use protocol_powershell_remoting::{PipelineOutput, PsValue};
use tracing::{debug, error, instrument};

#[derive(Debug, PartialEq, Eq)]
pub enum UserEvent {
    PipelineCreated {
        powershell: PipelineHandle,
    },
    PipelineFinished {
        powershell: PipelineHandle,
    },
    PipelineOutput {
        powershell: PipelineHandle,
        output: PipelineOutput,
    },
}

impl UserEvent {
    pub fn pipeline_id(&self) -> uuid::Uuid {
        match self {
            UserEvent::PipelineCreated { powershell }
            | UserEvent::PipelineFinished { powershell }
            | UserEvent::PipelineOutput { powershell, .. } => powershell.id(),
        }
    }
}

#[derive(Debug)]
pub enum ActiveSessionOutput {
    SendBack(Vec<HttpRequest<String>>),
    SendBackError(crate::PwshCoreError),
    UserEvent(UserEvent),
    HostCall(HostCallRequest),
    OperationSuccess,
}

impl PartialEq for ActiveSessionOutput {
    fn eq(&self, other: &Self) -> bool {
        self.priority() == other.priority()
    }
}

impl Eq for ActiveSessionOutput {}

impl PartialOrd for ActiveSessionOutput {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for ActiveSessionOutput {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.priority().cmp(&other.priority())
    }
}

impl ActiveSessionOutput {
    pub fn priority(&self) -> u8 {
        match self {
            ActiveSessionOutput::HostCall { .. } => 1,
            ActiveSessionOutput::SendBack(_) => 2,
            ActiveSessionOutput::SendBackError(_) => 3,
            ActiveSessionOutput::UserEvent(_) => 4,
            ActiveSessionOutput::OperationSuccess => 5,
        }
    }
}

#[derive(Debug)]
pub enum PowershellOperations {
    AddCommand { command: PipelineCommand },
    AddArgument(String),
}

#[derive(Debug)]
pub enum UserOperation {
    CreatePipeline {
        uuid: uuid::Uuid,
    },
    OperatePipeline {
        powershell: PipelineHandle,
        operation: PowershellOperations,
    },
    InvokePipeline {
        powershell: PipelineHandle,
        output_type: PipelineOutputType,
    },
    /// Reply to a server-initiated host call (PipelineHostCall or RunspacePoolHostCall)
    SubmitHostResponse {
        // scope: HostCallScope,
        // call_id: i64,
        // method_id: i32,
        // method_name: String,
        // result: Option<PsValue>,
        // error: Option<PsValue>,
        response: HostCallResponse,
    },
    /// Allow UI to abort a pending prompt cleanly (timeout, user cancelled)
    CancelHostCall {
        scope: HostCallScope,
        call_id: i64,
        reason: Option<String>,
    },
}

/// ActiveSession manages post-connection operations
#[derive(Debug)]
pub struct ActiveSession {
    runspace_pool: RunspacePool,
    http_builder: HttpBuilder,
    /// Tracks pending host calls by (scope, call_id) to validate responses
    pending_host_calls: std::collections::HashMap<(HostCallScope, i64), ()>,
}

impl ActiveSession {
    pub fn new(runspace_pool: RunspacePool, http_builder: HttpBuilder) -> Self {
        Self {
            runspace_pool,
            http_builder,
            pending_host_calls: std::collections::HashMap::new(),
        }
    }

    /// Handle a client-initiated operation
    pub fn accept_client_operation(
        &mut self,
        operation: UserOperation,
    ) -> Result<ActiveSessionOutput, crate::PwshCoreError> {
        match operation {
            UserOperation::CreatePipeline { uuid } => {
                Ok(ActiveSessionOutput::UserEvent(UserEvent::PipelineCreated {
                    powershell: self.runspace_pool.init_pipeline(uuid)?,
                }))
            }
            UserOperation::OperatePipeline {
                powershell,
                operation,
            } => {
                match operation {
                    PowershellOperations::AddCommand { command } => {
                        self.runspace_pool.add_command(powershell, command)?;
                    }
                    PowershellOperations::AddArgument(arg) => {
                        self.runspace_pool.add_switch_parameter(powershell, arg)?;
                    }
                }
                Ok(ActiveSessionOutput::OperationSuccess)
            }
            UserOperation::InvokePipeline {
                powershell,
                output_type,
            } => {
                let command_request = self
                    .runspace_pool
                    .invoke_pipeline_request(powershell, output_type);
                match command_request {
                    Ok(request) => {
                        let response = self.http_builder.post("/wsman", request);
                        Ok(ActiveSessionOutput::SendBack(vec![response]))
                    }
                    Err(e) => Ok(ActiveSessionOutput::SendBackError(e)),
                }
            }
            UserOperation::SubmitHostResponse {
                response:
                    HostCallResponse {
                        call_scope,
                        call_id,
                        method_id,
                        method_name,
                        method_result: result,
                        method_exception: error,
                    },
            } => {
                // Validate that this host call is actually pending
                let key = (call_scope.clone(), call_id);
                if !self.pending_host_calls.contains_key(&key) {
                    return Err(crate::PwshCoreError::InvalidState(
                        "Host call not found or already completed",
                    ));
                }

                // Remove from pending calls
                self.pending_host_calls.remove(&key);

                // Create the appropriate host response message based on scope
                match call_scope {
                    HostCallScope::Pipeline { command_id } => self.send_pipeline_host_response(
                        command_id,
                        call_id,
                        method_id,
                        method_name,
                        result,
                        error,
                    ),
                    HostCallScope::RunspacePool => self.send_runspace_pool_host_response(
                        call_id,
                        method_id,
                        method_name,
                        result,
                        error,
                    ),
                }
            }
            UserOperation::CancelHostCall {
                scope,
                call_id,
                reason: _reason,
            } => {
                // Remove from pending calls if it exists
                let key = (scope.clone(), call_id);
                self.pending_host_calls.remove(&key);

                // For cancellation, send an error response
                let error_msg = format!("Host call {call_id} was cancelled");
                let error = Some(PsValue::Primitive(
                    protocol_powershell_remoting::PsPrimitiveValue::Str(error_msg),
                ));

                match scope {
                    HostCallScope::Pipeline { command_id } => self.send_pipeline_host_response(
                        command_id,
                        call_id,
                        0,
                        "Cancelled".to_string(),
                        None,
                        error,
                    ),
                    HostCallScope::RunspacePool => self.send_runspace_pool_host_response(
                        call_id,
                        0,
                        "Cancelled".to_string(),
                        None,
                        error,
                    ),
                }
            }
        }
    }

    /// Handle a server response
    #[instrument(skip(self, response))]
    pub fn accept_server_response(
        &mut self,
        response: HttpResponse<String>,
    ) -> Result<Vec<ActiveSessionOutput>, crate::PwshCoreError> {
        let body = response.body.ok_or(crate::PwshCoreError::InvalidState(
            "Expected a body in server response",
        ))?;

        debug!("Response body length: {}", body.len());

        let results = self.runspace_pool.accept_response(body).map_err(|e| {
            error!("RunspacePool.accept_response failed: {:#}", e);
            e
        })?;

        let mut step_output = Vec::new();
        debug!(?results, "RunspacePool accept_response results");

        for (index, result) in results.into_iter().enumerate() {
            debug!("Processing result {}: {:?}", index, result);

            match result {
                AcceptResponsResult::ReceiveResponse { desired_streams } => {
                    debug!(
                        "Creating receive request for streams: {:?}",
                        desired_streams
                    );
                    let receive_request = self
                        .runspace_pool
                        .fire_receive(desired_streams)
                        .map_err(|e| {
                            error!("Failed to create receive request: {:#}", e);
                            e
                        })?;
                    let response = self.http_builder.post("/wsman", receive_request);
                    step_output.push(ActiveSessionOutput::SendBack(vec![response]));
                }
                AcceptResponsResult::PipelineCreated(pipeline) => {
                    debug!(?pipeline, "Pipeline created");
                    step_output.push(ActiveSessionOutput::UserEvent(UserEvent::PipelineCreated {
                        powershell: pipeline,
                    }));
                }
                AcceptResponsResult::PipelineFinished(pipeline) => {
                    debug!(?pipeline, "Pipeline finished");
                    step_output.push(ActiveSessionOutput::UserEvent(
                        UserEvent::PipelineFinished {
                            powershell: pipeline,
                        },
                    ));
                }
                AcceptResponsResult::HostCall(host_call) => {
                    debug!(host_call = ?host_call, "Received host call request");
                    // Track this host call as pending
                    let scope: HostCallScope = host_call.call_type.clone();
                    let key = (scope, host_call.call_id);
                    self.pending_host_calls.insert(key, ());

                    step_output.push(ActiveSessionOutput::HostCall(host_call));
                }
                AcceptResponsResult::PipelineOutput { output, handle } => {
                    debug!("Pipeline output: {:?}", output);
                    step_output.push(ActiveSessionOutput::UserEvent(UserEvent::PipelineOutput {
                        output,
                        powershell: handle,
                    }));
                }
            }
        }

        step_output.sort();
        debug!("Returning {} step outputs", step_output.len());
        Ok(step_output)
    }

    /// Send a pipeline host response back to the server
    fn send_pipeline_host_response(
        &mut self,
        command_id: uuid::Uuid,
        call_id: i64,
        method_id: i32,
        method_name: String,
        result: Option<PsValue>,
        error: Option<PsValue>,
    ) -> Result<ActiveSessionOutput, crate::PwshCoreError> {
        // Only send a response if we have a result or error to report
        // Void methods (like Write, WriteLine, WriteProgress) don't need responses
        if result.is_none() && error.is_none() {
            return Ok(ActiveSessionOutput::OperationSuccess);
        }

        use protocol_powershell_remoting::PipelineHostResponse;

        let host_response = PipelineHostResponse::builder()
            .call_id(call_id)
            .method_id(method_id)
            .method_name(method_name)
            .method_result_opt(result)
            .method_exception_opt(error)
            .build();

        // Fragment and send via RunspacePool
        let request = self
            .runspace_pool
            .send_pipeline_host_response(command_id, host_response)?;
        let http_response = self.http_builder.post("/wsman", request);

        // Queue a receive after sending the response
        let receive_request = self.runspace_pool.fire_receive(
            crate::runspace_pool::DesiredStream::pipeline_streams(command_id),
        )?;
        let receive_http_response = self.http_builder.post("/wsman", receive_request);

        Ok(ActiveSessionOutput::SendBack(vec![
            http_response,
            receive_http_response,
        ]))
    }

    /// Send a runspace pool host response back to the server
    fn send_runspace_pool_host_response(
        &mut self,
        call_id: i64,
        method_id: i32,
        method_name: String,
        result: Option<PsValue>,
        error: Option<PsValue>,
    ) -> Result<ActiveSessionOutput, crate::PwshCoreError> {
        // Only send a response if we have a result or error to report
        // Void methods (like Write, WriteLine, WriteProgress) don't need responses
        if result.is_none() && error.is_none() {
            return Ok(ActiveSessionOutput::OperationSuccess);
        }

        use protocol_powershell_remoting::RunspacePoolHostResponse;

        let host_response = RunspacePoolHostResponse::builder()
            .call_id(call_id)
            .method_id(method_id)
            .method_name(method_name)
            .method_result_opt(result)
            .method_exception_opt(error)
            .build();

        // Fragment and send via RunspacePool
        let request = self
            .runspace_pool
            .send_runspace_pool_host_response(host_response)?;
        let http_response = self.http_builder.post("/wsman", request);

        // Queue a receive after sending the response
        let receive_request = self
            .runspace_pool
            .fire_receive(crate::runspace_pool::DesiredStream::runspace_pool_streams())?;
        let receive_http_response = self.http_builder.post("/wsman", receive_request);

        Ok(ActiveSessionOutput::SendBack(vec![
            http_response,
            receive_http_response,
        ]))
    }
}


--- File: crates/pwsh-core/src/connector/http.rs ---
use base64::Engine;
use std::{fmt::Display, net::IpAddr};

#[derive(Debug, Clone)]
pub enum ServerAddress {
    Ip(IpAddr),
    Domain(String),
}

impl Display for ServerAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ServerAddress::Ip(ip) => write!(f, "{ip}"),
            ServerAddress::Domain(domain) => write!(f, "{domain}"),
        }
    }
}

#[derive(Debug, Clone)]
pub enum Method {
    Get,
    Post,
    Put,
    Delete,
}

#[derive(Debug, Clone)]
pub struct HttpRequest<T> {
    pub method: Method,
    pub url: String,
    pub headers: Vec<(String, String)>,
    pub body: Option<T>,
    pub cookie: Option<String>,
}

impl<T> HttpRequest<T> {
    pub fn with_headers(mut self, headers: Vec<(String, String)>) -> Self {
        self.headers.extend(headers);
        self
    }
}

#[derive(Debug, Clone)]
pub struct HttpResponse<T> {
    pub status_code: u16,
    pub headers: Vec<(String, String)>,
    pub body: Option<T>,
}

#[derive(Debug)]
pub struct HttpBuilder {
    pub(crate) server: ServerAddress,
    pub(crate) port: u16,
    pub(crate) scheme: crate::connector::Scheme,
    pub(crate) authentication: crate::connector::Authentication,
    pub(crate) cookie: Option<String>,
}

impl HttpBuilder {
    pub fn new(
        server: ServerAddress,
        port: u16,
        scheme: crate::connector::Scheme,
        authentication: crate::connector::Authentication,
    ) -> Self {
        Self {
            server,
            port,
            scheme,
            authentication,
            cookie: None,
        }
    }

    pub fn with_cookie(mut self, cookie: String) -> Self {
        self.cookie = Some(cookie);
        self
    }

    fn build_url(&self, path: &str) -> String {
        let scheme_str = match self.scheme {
            crate::connector::Scheme::Http => "http",
            crate::connector::Scheme::Https => "https",
        };

        let server_str = match &self.server {
            ServerAddress::Ip(ip) => ip.to_string(),
            ServerAddress::Domain(domain) => domain.clone(),
        };

        format!("{}://{}:{}{}", scheme_str, server_str, self.port, path)
    }

    fn build_auth_header(&self) -> String {
        match &self.authentication {
            crate::connector::Authentication::Basic { username, password } => {
                let credentials = format!("{username}:{password}");
                let encoded = base64::engine::general_purpose::STANDARD.encode(credentials);
                format!("Basic {encoded}")
            }
        }
    }

    fn build_host_header(&self) -> String {
        match &self.server {
            ServerAddress::Ip(ip) => format!("{}:{}", ip, self.port),
            ServerAddress::Domain(domain) => format!("{}:{}", domain, self.port),
        }
    }

    fn build_headers(&self, body: Option<&str>) -> Vec<(String, String)> {
        let mut headers = vec![
            ("Host".to_string(), self.build_host_header()),
            (
                "Content-Type".to_string(),
                "application/soap+xml; charset=utf-8".to_string(),
            ),
            ("Authorization".to_string(), self.build_auth_header()),
        ];

        if let Some(body_content) = body {
            headers.push(("Content-Length".to_string(), body_content.len().to_string()));
        } else {
            headers.push(("Content-Length".to_string(), "0".to_string()));
        }

        if let Some(cookie) = &self.cookie {
            headers.push(("Cookie".to_string(), cookie.clone()));
        }

        headers
    }

    pub fn post(&self, path: &str, body: String) -> HttpRequest<String> {
        HttpRequest {
            method: Method::Post,
            url: self.build_url(path),
            headers: self.build_headers(Some(&body)),
            body: Some(body),
            cookie: self.cookie.clone(),
        }
    }

    pub fn get(&self, path: &str) -> HttpRequest<String> {
        HttpRequest {
            method: Method::Get,
            url: self.build_url(path),
            headers: self.build_headers(None),
            body: None,
            cookie: self.cookie.clone(),
        }
    }

    pub fn put(&self, path: &str, body: String) -> HttpRequest<String> {
        HttpRequest {
            method: Method::Put,
            url: self.build_url(path),
            headers: self.build_headers(Some(&body)),
            body: Some(body),
            cookie: self.cookie.clone(),
        }
    }

    pub fn delete(&self, path: &str) -> HttpRequest<String> {
        HttpRequest {
            method: Method::Delete,
            url: self.build_url(path),
            headers: self.build_headers(None),
            body: None,
            cookie: self.cookie.clone(),
        }
    }
}


--- File: crates/pwsh-core/src/connector/mod.rs ---
use std::sync::Arc;

use protocol_powershell_remoting::HostInfo;
use protocol_winrm::ws_management::WsMan;
use tracing::{info, instrument, warn};

use crate::{
    connector::http::{HttpBuilder, HttpRequest, HttpResponse, ServerAddress},
    runspace_pool::{
        DesiredStream, ExpectShellCreated, RunspacePool, RunspacePoolCreator, RunspacePoolState,
        pool::AcceptResponsResult,
    },
};

pub use active_session::{ActiveSession, ActiveSessionOutput, UserOperation};
pub mod active_session;
pub mod http;

#[derive(Debug, Clone)]
pub enum Authentication {
    Basic { username: String, password: String },
    // TODO: Add SSPI
}

#[derive(Debug, Clone)]
pub enum Scheme {
    Http,
    Https,
}

#[derive(Debug, Clone)]
pub struct ConnectorConfig {
    pub server: (ServerAddress, u16),
    pub scheme: Scheme,
    pub authentication: Authentication,
    pub host_info: HostInfo,
}

impl ConnectorConfig {
    pub fn wsman_to(&self, query: Option<&str>) -> String {
        let query = query
            .map(|q| format!("?{}", q.trim_start_matches('?')))
            .unwrap_or_default();

        match &self.scheme {
            Scheme::Http => format!("http://{}:{}/wsman{}", self.server.0, self.server.1, query),
            Scheme::Https => format!("https://{}:{}/wsman{}", self.server.0, self.server.1, query),
        }
    }
}

#[derive(Debug)]
pub enum ConnectorStepResult {
    SendBack(HttpRequest<String>),
    SendBackError(crate::PwshCoreError),
    Connected {
        active_session: ActiveSession,
        next_receive_request: HttpRequest<String>,
    },
}

impl ConnectorStepResult {
    pub fn name(&self) -> &'static str {
        match self {
            ConnectorStepResult::SendBack(_) => "SendBack",
            ConnectorStepResult::SendBackError(_) => "SendBackError",
            ConnectorStepResult::Connected { .. } => "Connected",
        }
    }
}

impl ConnectorStepResult {
    pub fn priority(&self) -> u8 {
        match self {
            ConnectorStepResult::SendBack(_) => 0,
            ConnectorStepResult::SendBackError(_) => 1,
            ConnectorStepResult::Connected { .. } => 2,
        }
    }
}

#[derive(Default, Debug)]
pub enum ConnectorState {
    Idle,
    #[default]
    Taken,
    Connecting {
        expect_shell_created: ExpectShellCreated,
        http_builder: HttpBuilder,
    },
    ConnectReceiveCycle {
        runspace_pool: RunspacePool,
        http_builder: HttpBuilder,
    },
    Connected,
    Failed,
}

impl ConnectorState {
    fn state_name(&self) -> &'static str {
        match self {
            ConnectorState::Idle => "Idle",
            ConnectorState::Taken => "Taken",
            ConnectorState::Connecting { .. } => "Connecting",
            ConnectorState::ConnectReceiveCycle { .. } => "ConnectReceiveCycle",
            ConnectorState::Connected => "Connected",
            ConnectorState::Failed => "Failed",
        }
    }
}

pub struct Connector {
    state: ConnectorState,
    config: ConnectorConfig,
}

impl Connector {
    pub fn new(config: ConnectorConfig) -> Self {
        Self {
            state: ConnectorState::Idle,
            config,
        }
    }

    pub fn set_state(&mut self, state: ConnectorState) {
        info!(state = state.state_name(), "Setting connector state");
        self.state = state;
    }

    #[instrument(skip(self, server_response), name = "Connector::step")]
    pub fn step(
        &mut self,
        server_response: Option<HttpResponse<String>>,
    ) -> Result<ConnectorStepResult, crate::PwshCoreError> {
        let state = std::mem::take(&mut self.state);

        let (new_state, response) = match state {
            ConnectorState::Taken => {
                return Err(crate::PwshCoreError::UnlikelyToHappen(
                    "Connector should not be in Taken state when stepping",
                ));
            }
            ConnectorState::Failed => {
                warn!("Connector is in Failed state, cannot proceed");
                return Err(crate::PwshCoreError::InvalidState(
                    "Connector is in Failed state",
                ));
            }
            ConnectorState::Connected => {
                warn!("Connector is already connected, cannot step further");
                return Err(crate::PwshCoreError::InvalidState(
                    "Connector is already connected",
                ));
            }
            ConnectorState::Idle => {
                debug_assert!(
                    server_response.is_none(),
                    "Request should be None in Idle state"
                );
                let connection = Arc::new(WsMan::builder().to(self.config.wsman_to(None)).build());
                let runspace_pool = RunspacePoolCreator::builder()
                    .host_info(self.config.host_info.clone())
                    .build()
                    .into_runspace_pool(connection);

                let http_builder = HttpBuilder::new(
                    self.config.server.0.clone(),
                    self.config.server.1,
                    self.config.scheme.clone(),
                    self.config.authentication.clone(),
                );

                let (xml_body, expect_shell_created) = runspace_pool.open()?;

                let response = http_builder.post("/wsman", xml_body);

                let new_state = ConnectorState::Connecting {
                    expect_shell_created,
                    http_builder,
                };

                (new_state, ConnectorStepResult::SendBack(response))
            }
            ConnectorState::Connecting {
                expect_shell_created,
                http_builder,
            } => {
                info!("Processing Connecting state");
                let response = server_response.ok_or({
                    crate::PwshCoreError::InvalidState("Expected a response in Connecting state")
                })?;

                let body = response.body.ok_or({
                    crate::PwshCoreError::InvalidState("Expected a body in Connecting state")
                })?;

                let mut runspace_pool = expect_shell_created.accept(body)?;

                let receive_request =
                    runspace_pool.fire_receive(DesiredStream::runspace_pool_streams())?;

                let response = http_builder.post("/wsman", receive_request);

                let new_state = ConnectorState::ConnectReceiveCycle {
                    runspace_pool,
                    http_builder,
                };

                (new_state, ConnectorStepResult::SendBack(response))
            }
            ConnectorState::ConnectReceiveCycle {
                mut runspace_pool,
                http_builder,
            } => {
                let response = server_response.ok_or({
                    crate::PwshCoreError::InvalidState(
                        "Expected a response in ConnectReceiveCycle state",
                    )
                })?;

                let body = response.body.ok_or({
                    crate::PwshCoreError::InvalidState(
                        "Expected a body in ConnectReceiveCycle state",
                    )
                })?;

                let accept_response_results = runspace_pool.accept_response(body)?;
                let Some(AcceptResponsResult::ReceiveResponse { desired_streams }) =
                    accept_response_results
                        .into_iter()
                        .find(|r| matches!(r, AcceptResponsResult::ReceiveResponse { .. }))
                else {
                    return Err(crate::PwshCoreError::InvalidState(
                        "Expected ReceiveResponse in ConnectReceiveCycle state",
                    ));
                };

                if let RunspacePoolState::NegotiationSent = runspace_pool.state {
                    let receive_request = runspace_pool.fire_receive(desired_streams)?;
                    let response = http_builder.post("/wsman", receive_request);
                    let new_state = ConnectorState::ConnectReceiveCycle {
                        runspace_pool,
                        http_builder,
                    };
                    (new_state, ConnectorStepResult::SendBack(response))
                } else if let RunspacePoolState::Opened = runspace_pool.state {
                    info!("Connection established successfully - returning ActiveSession");
                    let next_receive_request = runspace_pool.fire_receive(desired_streams)?;
                    let next_http_request = http_builder.post("/wsman", next_receive_request);
                    let active_session = ActiveSession::new(runspace_pool, http_builder);
                    (
                        ConnectorState::Connected,
                        ConnectorStepResult::Connected {
                            active_session,
                            next_receive_request: next_http_request,
                        },
                    )
                } else {
                    warn!("Unexpected RunspacePool state: {:?}", runspace_pool.state);
                    (
                        ConnectorState::Failed,
                        ConnectorStepResult::SendBackError(crate::PwshCoreError::InvalidState(
                            "Unexpected RunspacePool state",
                        )),
                    )
                }
            }
        };

        self.set_state(new_state);
        Ok(response)
    }
}


--- File: crates/pwsh-core/src/host/conversions.rs ---
use super::{
    error::HostError,
    methods::{HostCallMethodWithParams, HostMethodParams, RawUIMethodParams, UIMethodParams},
};

/// Convert HostCallRequest to HostCallMethodWithParams based on method_id and parameters
impl TryFrom<&super::HostCallRequest> for HostCallMethodWithParams {
    type Error = HostError;

    fn try_from(call: &super::HostCallRequest) -> Result<Self, Self::Error> {
        // PowerShell method IDs based on the protocol specification
        // Host methods: 1-10, UI methods: 11-30, RawUI methods: 31-60
        match call.method_id {
            // Host methods (1-10)
            1 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetName,
            )),
            2 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetVersion,
            )),
            3 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetInstanceId,
            )),
            4 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetCurrentCulture,
            )),
            5 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetCurrentUICulture,
            )),
            6 => {
                let exit_code = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::HostMethod(
                    HostMethodParams::SetShouldExit(exit_code),
                ))
            }
            7 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::EnterNestedPrompt,
            )),
            8 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::ExitNestedPrompt,
            )),
            9 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::NotifyBeginApplication,
            )),
            10 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::NotifyEndApplication,
            )),

            // UI methods (11-30)
            11 => Ok(HostCallMethodWithParams::UIMethod(UIMethodParams::ReadLine)),
            12 => Ok(HostCallMethodWithParams::UIMethod(
                UIMethodParams::ReadLineAsSecureString,
            )),
            13 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(UIMethodParams::Write(
                    value,
                )))
            }
            14 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteLine(value),
                ))
            }
            15 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteErrorLine(value),
                ))
            }
            16 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteDebugLine(value),
                ))
            }
            17 => {
                let source_id = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i64())
                    .ok_or(HostError::InvalidParameters)?;
                let record = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteProgress(source_id, record),
                ))
            }
            18 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteVerboseLine(value),
                ))
            }
            19 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteWarningLine(value),
                ))
            }
            20 => {
                let caption = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let descriptions = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string_array())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(UIMethodParams::Prompt(
                    caption,
                    descriptions,
                )))
            }
            21 => {
                let caption = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let message = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let choices = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_string_array())
                    .ok_or(HostError::InvalidParameters)?;
                let default_choice = call
                    .parameters
                    .get(3)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::PromptForChoice(caption, message, choices, default_choice),
                ))
            }
            22 => {
                let caption = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let message = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let user_name = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let target_name = call
                    .parameters
                    .get(3)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::PromptForCredential(caption, message, user_name, target_name),
                ))
            }

            // RawUI methods (31-60)
            31 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetForegroundColor,
            )),
            32 => {
                let color = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetForegroundColor(color),
                ))
            }
            33 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetBackgroundColor,
            )),
            34 => {
                let color = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetBackgroundColor(color),
                ))
            }
            35 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetCursorPosition,
            )),
            36 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetCursorPosition(x, y),
                ))
            }
            37 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetWindowPosition,
            )),
            38 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetWindowPosition(x, y),
                ))
            }
            39 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetCursorSize,
            )),
            40 => {
                let percentage = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetCursorSize(percentage),
                ))
            }
            41 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetBufferSize,
            )),
            42 => {
                let width = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let height = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetBufferSize(width, height),
                ))
            }
            43 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetWindowSize,
            )),
            44 => {
                let width = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let height = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetWindowSize(width, height),
                ))
            }
            45 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetMaxWindowSize,
            )),
            46 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetMaxPhysicalWindowSize,
            )),
            47 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetKeyAvailable,
            )),
            48 => {
                let options = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::ReadKey(options),
                ))
            }
            49 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::FlushInputBuffer,
            )),
            50 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let contents = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetBufferContents(x, y, contents),
                ))
            }
            51 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let width = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let height = call
                    .parameters
                    .get(3)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::GetBufferContents(x, y, width, height),
                ))
            }
            52 => {
                // ScrollBufferContents has complex parameters - simplified for now
                let params: Vec<i32> = call
                    .parameters
                    .iter()
                    .take(6)
                    .filter_map(|p| p.as_i32())
                    .collect();
                let fill = call
                    .parameters
                    .get(6)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;

                if params.len() == 6 {
                    Ok(HostCallMethodWithParams::RawUIMethod(
                        RawUIMethodParams::ScrollBufferContents(
                            params[0], params[1], params[2], params[3], params[4], params[5], fill,
                        ),
                    ))
                } else {
                    Err(HostError::InvalidParameters)
                }
            }

            _ => Err(HostError::NotImplemented),
        }
    }
}


--- File: crates/pwsh-core/src/host/error.rs ---
/// Error type for host operations
#[derive(Debug, Clone, PartialEq)]
pub enum HostError {
    NotImplemented,
    InvalidParameters,
    RequestReturnMismatch,
    Cancelled,
    Other(String),
}

impl std::fmt::Display for HostError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HostError::NotImplemented => write!(f, "Operation not implemented"),
            HostError::InvalidParameters => write!(f, "Invalid parameters"),
            HostError::RequestReturnMismatch => write!(f, "Request and return types do not match"),
            HostError::Cancelled => write!(f, "Operation cancelled"),
            HostError::Other(msg) => write!(f, "{msg}"),
        }
    }
}

impl std::error::Error for HostError {}

/// Result type for host operations
pub type HostResult<T> = Result<T, HostError>;


--- File: crates/pwsh-core/src/host/methods.rs ---
use uuid::Uuid;

/// PowerShell Host method calls (requests with parameters)
#[derive(Debug, Clone, PartialEq)]
pub enum HostMethodParams {
    GetName,
    GetVersion,
    GetInstanceId,
    GetCurrentCulture,
    GetCurrentUICulture,
    SetShouldExit(i32), // exit_code
    EnterNestedPrompt,
    ExitNestedPrompt,
    NotifyBeginApplication,
    NotifyEndApplication,
}

/// PowerShell Host UI method calls (requests with parameters)
#[derive(Debug, Clone, PartialEq)]
pub enum UIMethodParams {
    ReadLine,
    ReadLineAsSecureString,
    Write(String),                                       // value
    WriteLine(String),                                   // value
    WriteErrorLine(String),                              // value
    WriteDebugLine(String),                              // value
    WriteProgress(i64, String),                          // source_id, record
    WriteVerboseLine(String),                            // value
    WriteWarningLine(String),                            // value
    Prompt(String, Vec<String>),                         // caption, descriptions
    PromptForChoice(String, String, Vec<String>, i32), // caption, message, choices, default_choice
    PromptForCredential(String, String, String, String), // caption, message, user_name, target_name
}

/// PowerShell Host Raw UI method calls (requests with parameters)
#[derive(Debug, Clone, PartialEq)]
pub enum RawUIMethodParams {
    GetForegroundColor,
    SetForegroundColor(i32), // color
    GetBackgroundColor,
    SetBackgroundColor(i32), // color
    GetCursorPosition,
    SetCursorPosition(i32, i32), // x, y
    GetWindowPosition,
    SetWindowPosition(i32, i32), // x, y
    GetCursorSize,
    SetCursorSize(i32), // percentage
    GetBufferSize,
    SetBufferSize(i32, i32), // width, height
    GetWindowSize,
    SetWindowSize(i32, i32), // width, height
    GetMaxWindowSize,
    GetMaxPhysicalWindowSize,
    GetKeyAvailable,
    ReadKey(i32), // options
    FlushInputBuffer,
    SetBufferContents(i32, i32, String),   // x, y, contents
    GetBufferContents(i32, i32, i32, i32), // x, y, width, height
    ScrollBufferContents(i32, i32, i32, i32, i32, i32, String), // source rectangle, destination, clip, fill
}

/// Host call request containing the method and metadata
#[derive(Debug, Clone, PartialEq)]
pub enum HostCallMethodWithParams {
    HostMethod(HostMethodParams),
    UIMethod(UIMethodParams),
    RawUIMethod(RawUIMethodParams),
}

impl HostCallMethodWithParams {
    /// Submit the result and validate that the request and return types match
    /// Returns (method_result, method_exception)
    pub fn submit(
        self,
        result: HostCallMethodReturn,
    ) -> Result<
        (
            Option<protocol_powershell_remoting::PsValue>,
            Option<protocol_powershell_remoting::PsValue>,
        ),
        super::error::HostError,
    > {
        use protocol_powershell_remoting::{PsPrimitiveValue, PsValue};

        // Validate that the request and return types match
        if !matches(&self, &result) {
            return Err(super::error::HostError::RequestReturnMismatch);
        }

        let (method_result, method_exception) = match result {
            HostCallMethodReturn::Error(error) => {
                // Convert error to PsValue exception
                let error_message = error.to_string();
                (
                    None,
                    Some(PsValue::Primitive(PsPrimitiveValue::Str(error_message))),
                )
            }
            HostCallMethodReturn::HostMethod(method_return) => {
                let result = match method_return {
                    HostMethodReturn::GetName(name) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(name)))
                    }
                    HostMethodReturn::GetVersion(version) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(version)))
                    }
                    HostMethodReturn::GetInstanceId(id) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(id.to_string())))
                    }
                    HostMethodReturn::GetCurrentCulture(culture) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(culture)))
                    }
                    HostMethodReturn::GetCurrentUICulture(culture) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(culture)))
                    }
                    HostMethodReturn::SetShouldExit
                    | HostMethodReturn::EnterNestedPrompt
                    | HostMethodReturn::ExitNestedPrompt
                    | HostMethodReturn::NotifyBeginApplication
                    | HostMethodReturn::NotifyEndApplication => None, // void returns
                };
                (result, None)
            }
            HostCallMethodReturn::UIMethod(ui_return) => {
                let result = match ui_return {
                    UIMethodReturn::ReadLine(text) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(text)))
                    }
                    UIMethodReturn::ReadLineAsSecureString(secure_data) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Bytes(secure_data)))
                    }
                    UIMethodReturn::Prompt(values) => Some(PsValue::from_string_array(values)),
                    UIMethodReturn::PromptForChoice(choice) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(choice)))
                    }
                    UIMethodReturn::PromptForCredential(username, password) => {
                        // Create a credential-like object
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "UserName".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "UserName".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::Str(username)),
                            },
                        );
                        properties.insert(
                            "Password".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Password".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::Bytes(password)),
                            },
                        );
                        Some(PsValue::Object(
                            protocol_powershell_remoting::ComplexObject {
                                type_def: None,
                                to_string: None,
                                content:
                                    protocol_powershell_remoting::ComplexObjectContent::Standard,
                                adapted_properties: std::collections::BTreeMap::new(),
                                extended_properties: properties,
                            },
                        ))
                    }
                    UIMethodReturn::Write
                    | UIMethodReturn::WriteLine
                    | UIMethodReturn::WriteErrorLine
                    | UIMethodReturn::WriteDebugLine
                    | UIMethodReturn::WriteProgress
                    | UIMethodReturn::WriteVerboseLine
                    | UIMethodReturn::WriteWarningLine => None, // void returns
                };
                (result, None)
            }
            HostCallMethodReturn::RawUIMethod(raw_ui_return) => {
                let result = match raw_ui_return {
                    RawUIMethodReturn::GetForegroundColor(color) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(color)))
                    }
                    RawUIMethodReturn::GetBackgroundColor(color) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(color)))
                    }
                    RawUIMethodReturn::GetCursorPosition(x, y)
                    | RawUIMethodReturn::GetWindowPosition(x, y) => {
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "X".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "X".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(x)),
                            },
                        );
                        properties.insert(
                            "Y".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Y".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(y)),
                            },
                        );
                        Some(PsValue::Object(
                            protocol_powershell_remoting::ComplexObject {
                                type_def: None,
                                to_string: None,
                                content:
                                    protocol_powershell_remoting::ComplexObjectContent::Standard,
                                adapted_properties: std::collections::BTreeMap::new(),
                                extended_properties: properties,
                            },
                        ))
                    }
                    RawUIMethodReturn::GetCursorSize(size) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(size)))
                    }
                    RawUIMethodReturn::GetBufferSize(width, height)
                    | RawUIMethodReturn::GetWindowSize(width, height)
                    | RawUIMethodReturn::GetMaxWindowSize(width, height)
                    | RawUIMethodReturn::GetMaxPhysicalWindowSize(width, height) => {
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "Width".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Width".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(width)),
                            },
                        );
                        properties.insert(
                            "Height".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Height".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(height)),
                            },
                        );
                        Some(PsValue::Object(
                            protocol_powershell_remoting::ComplexObject {
                                type_def: None,
                                to_string: None,
                                content:
                                    protocol_powershell_remoting::ComplexObjectContent::Standard,
                                adapted_properties: std::collections::BTreeMap::new(),
                                extended_properties: properties,
                            },
                        ))
                    }
                    RawUIMethodReturn::GetKeyAvailable(available) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Bool(available)))
                    }
                    RawUIMethodReturn::ReadKey(virtual_key, character, control_state, key_down) => {
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "VirtualKeyCode".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "VirtualKeyCode".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(virtual_key)),
                            },
                        );
                        properties.insert(
                            "Character".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "Character".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::Str(
                                    character.to_string(),
                                )),
                            },
                        );
                        properties.insert(
                            "ControlKeyState".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "ControlKeyState".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(control_state)),
                            },
                        );
                        properties.insert(
                            "KeyDown".to_string(),
                            protocol_powershell_remoting::PsProperty {
                                name: "KeyDown".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(key_down)),
                            },
                        );
                        Some(PsValue::Object(
                            protocol_powershell_remoting::ComplexObject {
                                type_def: None,
                                to_string: None,
                                content:
                                    protocol_powershell_remoting::ComplexObjectContent::Standard,
                                adapted_properties: std::collections::BTreeMap::new(),
                                extended_properties: properties,
                            },
                        ))
                    }
                    RawUIMethodReturn::GetBufferContents(contents) => {
                        Some(PsValue::from_string_array(contents))
                    }
                    RawUIMethodReturn::SetForegroundColor
                    | RawUIMethodReturn::SetBackgroundColor
                    | RawUIMethodReturn::SetCursorPosition
                    | RawUIMethodReturn::SetWindowPosition
                    | RawUIMethodReturn::SetCursorSize
                    | RawUIMethodReturn::SetBufferSize
                    | RawUIMethodReturn::SetWindowSize
                    | RawUIMethodReturn::FlushInputBuffer
                    | RawUIMethodReturn::SetBufferContents
                    | RawUIMethodReturn::ScrollBufferContents => None, // void returns
                };
                (result, None)
            }
        };

        Ok((method_result, method_exception))
    }
}

/// PowerShell Host method responses (return values)
#[derive(Debug, Clone, PartialEq)]
pub enum HostMethodReturn {
    GetName(String),
    GetVersion(String), // Version string
    GetInstanceId(Uuid),
    GetCurrentCulture(String),   // CultureInfo
    GetCurrentUICulture(String), // CultureInfo
    SetShouldExit,               // void return
    EnterNestedPrompt,
    ExitNestedPrompt,
    NotifyBeginApplication,
    NotifyEndApplication,
}

/// PowerShell Host UI method responses (return values)
#[derive(Debug, Clone, PartialEq)]
pub enum UIMethodReturn {
    ReadLine(String),
    ReadLineAsSecureString(Vec<u8>), // SecureString representation
    Write,                           // void return
    WriteLine,                       // void return
    WriteErrorLine,                  // void return
    WriteDebugLine,                  // void return
    WriteProgress,                   // void return
    WriteVerboseLine,                // void return
    WriteWarningLine,                // void return
    Prompt(Vec<String>),             // field values
    PromptForChoice(i32),            // selected choice index
    PromptForCredential(String, Vec<u8>), // username, password (SecureString)
}

/// PowerShell Host Raw UI method responses (return values)
#[derive(Debug, Clone, PartialEq)]
pub enum RawUIMethodReturn {
    GetForegroundColor(i32),
    SetForegroundColor, // void return
    GetBackgroundColor(i32),
    SetBackgroundColor,          // void return
    GetCursorPosition(i32, i32), // x, y
    SetCursorPosition,           // void return
    GetWindowPosition(i32, i32), // x, y
    SetWindowPosition,           // void return
    GetCursorSize(i32),
    SetCursorSize,                      // void return
    GetBufferSize(i32, i32),            // width, height
    SetBufferSize,                      // void return
    GetWindowSize(i32, i32),            // width, height
    SetWindowSize,                      // void return
    GetMaxWindowSize(i32, i32),         // width, height
    GetMaxPhysicalWindowSize(i32, i32), // width, height
    GetKeyAvailable(bool),
    ReadKey(i32, char, i32, i32), // virtual_key_code, character, control_key_state, key_down
    FlushInputBuffer,             // void return
    SetBufferContents,            // void return
    GetBufferContents(Vec<String>), // cell contents
    ScrollBufferContents,         // void return
}

/// Complete host call response
#[derive(Debug, Clone, PartialEq)]
pub enum HostCallMethodReturn {
    HostMethod(HostMethodReturn),
    UIMethod(UIMethodReturn),
    RawUIMethod(RawUIMethodReturn),
    Error(super::error::HostError),
}

fn matches(params: &HostCallMethodWithParams, returns: &HostCallMethodReturn) -> bool {
    match (params, returns) {
        // Host method matches
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetName),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetName(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetVersion),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetVersion(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetInstanceId),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetInstanceId(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetCurrentCulture),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetCurrentCulture(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetCurrentUICulture),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetCurrentUICulture(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::SetShouldExit(_)),
            HostCallMethodReturn::HostMethod(HostMethodReturn::SetShouldExit),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::EnterNestedPrompt),
            HostCallMethodReturn::HostMethod(HostMethodReturn::EnterNestedPrompt),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::ExitNestedPrompt),
            HostCallMethodReturn::HostMethod(HostMethodReturn::ExitNestedPrompt),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::NotifyBeginApplication),
            HostCallMethodReturn::HostMethod(HostMethodReturn::NotifyBeginApplication),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::NotifyEndApplication),
            HostCallMethodReturn::HostMethod(HostMethodReturn::NotifyEndApplication),
        ) => true,

        // UI method matches
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::ReadLine),
            HostCallMethodReturn::UIMethod(UIMethodReturn::ReadLine(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::ReadLineAsSecureString),
            HostCallMethodReturn::UIMethod(UIMethodReturn::ReadLineAsSecureString(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::Write(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::Write),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteErrorLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteErrorLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteDebugLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteDebugLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteProgress(_, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteProgress),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteVerboseLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteVerboseLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteWarningLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteWarningLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::Prompt(_, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::Prompt(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::PromptForChoice(_, _, _, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::PromptForChoice(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::PromptForCredential(_, _, _, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::PromptForCredential(_, _)),
        ) => true,

        // RawUI method matches
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetForegroundColor),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetForegroundColor(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetForegroundColor(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetForegroundColor),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetBackgroundColor),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBackgroundColor(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetBackgroundColor(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetBackgroundColor),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetCursorPosition),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetCursorPosition(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetCursorPosition(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetCursorPosition),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetWindowPosition),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetWindowPosition(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetWindowPosition(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetWindowPosition),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetCursorSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetCursorSize(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetCursorSize(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetCursorSize),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetBufferSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetBufferSize(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetBufferSize),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetWindowSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetWindowSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetWindowSize(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetWindowSize),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetMaxWindowSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetMaxWindowSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetMaxPhysicalWindowSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetMaxPhysicalWindowSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetKeyAvailable),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetKeyAvailable(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::ReadKey(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::ReadKey(_, _, _, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::FlushInputBuffer),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::FlushInputBuffer),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetBufferContents(_, _, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetBufferContents),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetBufferContents(_, _, _, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferContents(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::ScrollBufferContents(
                _,
                _,
                _,
                _,
                _,
                _,
                _,
            )),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::ScrollBufferContents),
        ) => true,

        // Error can match with any request
        (_, HostCallMethodReturn::Error(_)) => true,

        // No match
        _ => false,
    }
}


--- File: crates/pwsh-core/src/host/mod.rs ---
mod conversions;
mod error;
mod methods;
mod types;

pub use error::*;
pub use methods::*;
pub use types::*;

use protocol_powershell_remoting::{PipelineHostCall, PsValue};

#[derive(Debug, Clone)]
pub struct HostCallRequest {
    /// Type of the host call
    pub call_type: HostCallScope,
    /// Unique identifier for this host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Parameters for the method call as a list of values
    pub parameters: Vec<PsValue>,
}

impl HostCallRequest {
    pub fn new(
        call_type: HostCallScope,
        call_id: i64,
        method_id: i32,
        method_name: String,
        parameters: Vec<PsValue>,
    ) -> Self {
        Self {
            call_type,
            call_id,
            method_id,
            method_name,
            parameters,
        }
    }

    /// Extract the method call with typed parameters
    pub fn get_param(&self) -> Result<HostCallMethodWithParams, HostError> {
        HostCallMethodWithParams::try_from(self)
    }

    /// Submit the result and create a response
    pub fn submit_result(self, result: HostCallMethodReturn) -> HostCallResponse {
        // Extract method and delegate to the new submit method
        let method = match self.get_param() {
            Ok(method) => method,
            Err(error) => {
                // If we can't extract the method, create an error response
                return HostCallResponse {
                    call_scope: self.call_type,
                    call_id: self.call_id,
                    method_id: self.method_id,
                    method_name: self.method_name,
                    method_result: None,
                    method_exception: Some(PsValue::Primitive(
                        protocol_powershell_remoting::PsPrimitiveValue::Str(error.to_string()),
                    )),
                };
            }
        };

        let (method_result, method_exception) = match method.submit(result) {
            Ok((result, exception)) => (result, exception),
            Err(error) => {
                // If submit fails, create an error response
                (
                    None,
                    Some(PsValue::Primitive(
                        protocol_powershell_remoting::PsPrimitiveValue::Str(error.to_string()),
                    )),
                )
            }
        };

        HostCallResponse {
            call_scope: self.call_type,
            call_id: self.call_id,
            method_id: self.method_id,
            method_name: self.method_name,
            method_result,
            method_exception,
        }
    }

    /// Convenience method to extract method and get a closure for submitting results
    /// Usage: let (method_result, method_exception) = self.get_method()?.submit(result)?;
    pub fn extract_method_and_submit(
        self,
        result: HostCallMethodReturn,
    ) -> Result<(Option<PsValue>, Option<PsValue>), HostError> {
        self.get_param()?.submit(result)
    }
}

#[derive(Debug, Clone)]
pub struct HostCallResponse {
    /// Type of the host call
    pub call_scope: HostCallScope,
    /// Unique identifier for this host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Optional return value from the method
    pub method_result: Option<PsValue>,
    /// Optional exception thrown by the method invocation
    pub method_exception: Option<PsValue>,
}

impl From<(&PipelineHostCall, HostCallScope)> for HostCallRequest {
    fn from((call, call_type): (&PipelineHostCall, HostCallScope)) -> Self {
        let PipelineHostCall {
            call_id,
            method_id,
            method_name,
            parameters,
        } = call;

        Self {
            call_type,
            call_id: *call_id,
            method_id: *method_id,
            method_name: method_name.to_string(),
            parameters: parameters.to_vec(),
        }
    }
}

impl From<HostCallRequest> for PipelineHostCall {
    fn from(val: HostCallRequest) -> Self {
        PipelineHostCall {
            call_id: val.call_id,
            method_id: val.method_id,
            method_name: val.method_name,
            parameters: val.parameters,
        }
    }
}


--- File: crates/pwsh-core/src/host/types.rs ---
use uuid::Uuid;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum HostCallScope {
    Pipeline { command_id: Uuid },
    RunspacePool,
}


--- File: crates/pwsh-core/src/lib.rs ---
use std::borrow::Cow;

pub mod connector;
pub mod host;
pub mod pipeline;
pub mod powershell;
pub mod runspace;
pub mod runspace_pool;

#[derive(Debug, thiserror::Error)]
pub enum PwshCoreError {
    #[error("Connector error: {0}")]
    ConnectorError(String),

    #[error("Runspace error: {0}")]
    RunspaceError(String),

    #[error("Hyper error: {0}")]
    IOError(std::io::Error),

    #[error("Hyper error: {0}")]
    HyperError(#[from] hyper::http::Error),

    #[error("Invalid state: {0}")]
    InvalidState(&'static str),

    #[error("Something unlikely happened: {0}")]
    UnlikelyToHappen(&'static str),

    #[error("Protocol error: {0}")]
    PowerShellRemotingError(#[from] protocol_powershell_remoting::PowerShellRemotingError),

    #[error("XML parsing error: {0}")]
    XmlParsingError(#[from] xml::XmlError),

    #[error("Invalid response: {0}")]
    InvalidResponse(Cow<'static, str>),

    #[error("Host error: {0}")]
    HostError(#[from] crate::host::HostError),
}


--- File: crates/pwsh-core/src/pipeline.rs ---
use crate::runspace_pool::PsInvocationState;

/// Represents a parameter value in business logic terms
#[derive(Debug, Clone, PartialEq)]
pub enum ParameterValue {
    String(String),
    Integer(i64),
    Boolean(bool),
    Array(Vec<ParameterValue>),
    Null,
}

/// Represents a single parameter for a command
#[derive(Debug, Clone, PartialEq)]
pub struct Parameter {
    pub name: String,
    pub value: Option<ParameterValue>,
}

/// Represents a single PowerShell command in business logic terms
#[derive(Debug, Clone, PartialEq)]
pub struct PipelineCommand {
    pub command_text: String,
    pub is_script: bool,
    pub parameters: Vec<Parameter>,
}

impl PipelineCommand {
    pub fn new_script(script: String) -> Self {
        Self {
            command_text: script,
            is_script: true,
            parameters: Vec::new(),
        }
    }

    pub fn new_command(command: String) -> Self {
        Self {
            command_text: command,
            is_script: false,
            parameters: Vec::new(),
        }
    }

    pub fn add_parameter(&mut self, name: String, value: ParameterValue) {
        self.parameters.push(Parameter {
            name,
            value: Some(value),
        });
    }

    pub fn add_switch_parameter(&mut self, name: String) {
        self.parameters.push(Parameter { name, value: None });
    }

    pub(crate) fn new_output_stream() -> PipelineCommand {
        PipelineCommand::new_command("Out-String".to_string())
    }
}

/// Represents execution results in business terms
#[derive(Debug, Clone, Default)]
pub struct ExecutionResult {
    pub error_messages: Vec<String>,
    pub warning_messages: Vec<String>,
    pub debug_messages: Vec<String>,
    pub information_messages: Vec<String>,
    pub progress_records: Vec<protocol_powershell_remoting::ProgressRecord>,
    pub information_records: Vec<protocol_powershell_remoting::InformationRecord>,
}

/// Internal representation of a PowerShell pipeline's state and configuration.
/// This is owned and managed by the `RunspacePool`.
#[derive(Debug, Clone)]
pub struct Pipeline {
    pub(crate) state: PsInvocationState,
    pub(crate) commands: Vec<PipelineCommand>,
    pub(crate) results: ExecutionResult,
}

impl Pipeline {
    pub(crate) fn new() -> Self {
        Self {
            state: PsInvocationState::NotStarted,
            commands: Vec::new(),
            results: ExecutionResult::default(),
        }
    }

    pub(crate) fn add_information_record(
        &mut self,
        record: protocol_powershell_remoting::InformationRecord,
    ) {
        self.results.information_records.push(record);
    }

    pub(crate) fn add_progress_record(
        &mut self,
        record: protocol_powershell_remoting::ProgressRecord,
    ) {
        self.results.progress_records.push(record);
    }

    pub(crate) fn add_switch_parameter(&mut self, name: String) {
        if let Some(last_cmd) = self.commands.last_mut() {
            last_cmd.add_switch_parameter(name);
        } else {
            tracing::warn!("Attempted to add a switch parameter with no prior command.");
        }
    }

    pub(crate) fn add_command(&mut self, command: PipelineCommand) {
        self.commands.push(command);
    }
}

// Conversion methods to protocol types
impl From<ParameterValue> for protocol_powershell_remoting::PsValue {
    fn from(value: ParameterValue) -> Self {
        use protocol_powershell_remoting::{PsPrimitiveValue, PsValue};
        match value {
            ParameterValue::String(s) => PsValue::Primitive(PsPrimitiveValue::Str(s)),
            ParameterValue::Integer(i) => PsValue::Primitive(PsPrimitiveValue::I64(i)),
            ParameterValue::Boolean(b) => PsValue::Primitive(PsPrimitiveValue::Bool(b)),
            ParameterValue::Array(_arr) => {
                todo!("Convert array to PsValue")
            }
            ParameterValue::Null => PsValue::Primitive(PsPrimitiveValue::Nil),
        }
    }
}

impl From<&PipelineCommand> for protocol_powershell_remoting::Command {
    fn from(cmd: &PipelineCommand) -> Self {
        use protocol_powershell_remoting::{CommandParameter, PsPrimitiveValue, PsValue};

        // Convert parameters to CommandParameter
        let mut args = Vec::new();
        for param in &cmd.parameters {
            let param_value = match &param.value {
                Some(value) => value.clone().into(),
                None => {
                    // Switch parameter (no value) - use boolean true
                    PsValue::Primitive(PsPrimitiveValue::Bool(true))
                }
            };

            args.push(
                CommandParameter::builder()
                    .name(param.name.clone())
                    .value(param_value)
                    .build(),
            );
        }

        protocol_powershell_remoting::Command::builder()
            .cmd(&cmd.command_text)
            .is_script(cmd.is_script)
            .args(args)
            .build()
    }
}

impl Pipeline {
    /// Convert the business-level pipeline to a protocol-level PowerShellPipeline
    pub(crate) fn to_protocol_pipeline(
        &self,
    ) -> Result<
        protocol_powershell_remoting::messages::create_pipeline::PowerShellPipeline,
        crate::PwshCoreError,
    > {
        use protocol_powershell_remoting::{Command, Commands};

        // Convert all commands to protocol commands
        let protocol_commands: Vec<Command> = self.commands.iter().map(|cmd| cmd.into()).collect();

        // Use TryFrom to create Commands (handles empty check)
        let commands = Commands::try_from(protocol_commands)
            .map_err(crate::PwshCoreError::PowerShellRemotingError)?;

        Ok(
            protocol_powershell_remoting::messages::create_pipeline::PowerShellPipeline::builder()
                .is_nested(false)
                .redirect_shell_error_output_pipe(true)
                .cmds(commands)
                .build(),
        )
    }
}


--- File: crates/pwsh-core/src/powershell.rs ---
use uuid::Uuid;

/// A handle to a PowerShell pipeline managed by a `RunspacePool`.
///
/// This struct is a lightweight, copyable identifier for a specific pipeline.
/// All operations on the pipeline are performed via methods on the `RunspacePool`
/// that take this handle as an argument.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct PipelineHandle {
    pub(crate) id: uuid::Uuid,
}

impl PipelineHandle {
    /// Returns the unique identifier for this PowerShell handle.
    pub fn id(&self) -> uuid::Uuid {
        self.id
    }

    pub fn new(id: Uuid) -> Self {
        Self { id }
    }
}

/// Defines how the output of a pipeline should be handled
/// This concept is not part of the PWSH protocol, it is used internally
/// to determine how the output should be processed when invoking a pipeline.
#[derive(Debug)]
pub enum PipelineOutputType {
    Raw,
    /// Invoke pipeline with a extra command `Out-String -Stream`
    Streamed,
}


--- File: crates/pwsh-core/src/runspace/mod.rs ---
pub mod win_rs;


--- File: crates/pwsh-core/src/runspace/win_rs.rs ---
use base64::Engine;
use protocol_winrm::{
    cores::{Attribute, DesiredStream, Receive, Shell, Tag, Text, Time, tag_name},
    rsp::{
        commandline::CommandLineValue,
        receive::{CommandStateValue, ReceiveValue},
        rsp::ShellValue,
    },
    soap::{SoapEnvelope, body::SoapBody},
    ws_management::{self, OptionSetValue, SelectorSetValue, WsMan},
};
use tracing::{debug, instrument};
use uuid::Uuid;
use xml::builder::Element;

#[derive(Debug, Clone, typed_builder::TypedBuilder)]
pub struct WinRunspace {
    #[builder(default = "stdin pr".to_string())]
    input_streams: String,
    #[builder(default = "stdout".to_string())]
    output_streams: String,
    #[builder(default, setter(strip_option))]
    #[allow(dead_code)]
    environment: Option<std::collections::HashMap<String, String>>,
    #[builder(default, setter(strip_option))]
    idle_time_out: Option<f64>,
    #[builder(default, setter(strip_option))]
    name: Option<String>,

    #[builder(default = "http://schemas.microsoft.com/powershell/Microsoft.PowerShell".to_string())]
    resource_uri: String,

    #[builder(default = uuid::Uuid::new_v4())]
    id: uuid::Uuid,

    #[builder(default)]
    no_profile: Option<bool>,

    #[builder(default)]
    codepage: Option<u32>,

    #[builder(default)]
    shell_id: Option<String>,
    #[builder(default)]
    owner: Option<String>,
    #[builder(default)]
    client_ip: Option<String>,
    #[builder(default)]
    shell_run_time: Option<String>,
    #[builder(default)]
    shell_inactivity: Option<String>,

    #[builder(default)]
    selector_set: SelectorSetValue,

    #[builder(default)]
    opened: bool,
}

impl WinRunspace {
    pub fn open<'a>(
        &'a self,
        ws_man: &'a WsMan,
        option_set: Option<OptionSetValue>,
        open_content: &'a str,
    ) -> impl Into<Element<'a>> {
        let shell = Tag::from_name(Shell)
            .with_attribute(protocol_winrm::cores::Attribute::ShellId(
                self.id.to_string().into(),
            ))
            .with_attribute(protocol_winrm::cores::Attribute::Name(
                self.name.as_deref().unwrap_or("Runspace1").into(),
            ))
            .with_declaration(protocol_winrm::cores::Namespace::WsmanShell);

        let shell_value = ShellValue::builder()
            .input_streams(self.input_streams.as_ref())
            .output_streams(self.output_streams.as_ref())
            .idle_time_out_opt(self.idle_time_out.map(Time).map(Tag::new))
            .creation_xml(
                Tag::new(open_content)
                    .with_declaration(protocol_winrm::cores::Namespace::PowerShellRemoting),
            )
            .build();

        let shell = shell.with_value(shell_value);

        let mut option_set = option_set.unwrap_or_default();

        if let Some(profile) = self.no_profile {
            option_set = option_set.add_option("WINRS_NOPROFILE", profile.to_string());
        }

        if let Some(codepage) = self.codepage {
            option_set = option_set.add_option("WINRS_CODEPAGE", codepage.to_string());
        }

        ws_man.invoke(
            ws_management::WsAction::Create,
            None,
            SoapBody::builder().shell(shell).build(),
            Some(option_set),
            None,
        )
    }

    pub fn fire_receive<'a>(
        &'a self,
        ws_man: &'a WsMan,
        desired_streams: Vec<crate::runspace_pool::DesiredStream>,
    ) -> impl Into<Element<'a>> {
        let desired_streams = desired_streams
            .into_iter()
            .map(|stream| {
                let mut tag =
                    Tag::from_name(DesiredStream).with_value(Text::from(stream.name().to_owned()));

                if let Some(command_id) = stream.command_id() {
                    tag = tag.with_attribute(Attribute::CommandId(*command_id));
                }

                tag
            })
            .collect();

        let receive = ReceiveValue::builder()
            .desired_streams(desired_streams)
            .build();

        let receive_tag = Tag::from_name(Receive)
            .with_value(receive)
            .with_declaration(protocol_winrm::cores::Namespace::WsmanShell);

        let option_set = OptionSetValue::default()
            .add_option("WSMAN_CMDSHELL_OPTION_KEEPALIVE", true.to_string());

        let selector_set = self
            .shell_id
            .as_ref()
            .map(|shell_id| SelectorSetValue::new().add_selector("ShellId", shell_id));

        ws_man.invoke(
            ws_management::WsAction::ShellReceive,
            Some(&self.resource_uri),
            SoapBody::builder().receive(receive_tag).build(),
            Some(option_set),
            selector_set,
        )
    }

    #[instrument(skip_all)]
    pub(crate) fn accept_receive_response<'a>(
        &mut self,
        soap_envelope: &SoapEnvelope<'a>,
    ) -> Result<(Vec<Stream>, Option<CommandState>), crate::PwshCoreError> {
        let receive_response = &soap_envelope
            .body
            .as_ref()
            .receive_response
            .as_ref()
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "No ReceiveResponse found in response".into(),
            ))?;

        let streams = receive_response
            .value
            .streams
            .iter()
            .map(Stream::try_from)
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| {
                crate::PwshCoreError::InvalidResponse("Failed to decode streams".into())
            })?;

        let command_state = receive_response
            .value
            .command_state
            .as_ref()
            .map(CommandState::try_from)
            .transpose()?;

        debug!(receive_response = ?receive_response,?command_state, "Received streams and command state");

        Ok((streams, command_state))
    }

    pub fn accept_create_response<'a>(
        &mut self,
        soap_envelop: &SoapEnvelope<'a>,
    ) -> Result<(), crate::PwshCoreError> {
        let shell = &soap_envelop.body.as_ref().shell.as_ref().ok_or(
            crate::PwshCoreError::InvalidResponse("No shell found in response".into()),
        )?;
        let shell_id = shell.as_ref().shell_id.as_ref().map(|id| id.clone_value());
        let resource_uri = &shell.as_ref().resource_uri;
        let owner = &shell.as_ref().owner;
        let client_ip = &shell.as_ref().client_ip;
        let idle_time_out = &shell.as_ref().idle_time_out;
        let output_stream = &shell.as_ref().output_streams;
        let shell_run_time = &shell.as_ref().shell_run_time;
        let shell_inactivity = &shell.as_ref().shell_inactivity;

        self.shell_id = shell_id.map(|s| s.as_ref().to_string());
        self.owner = owner.as_ref().map(|o| o.value.as_ref().to_string());
        self.client_ip = client_ip.as_ref().map(|c| c.value.as_ref().to_string());
        self.idle_time_out = idle_time_out.as_ref().map(|t| t.value.0);
        self.output_streams = output_stream
            .as_ref()
            .map(|o| o.value.as_ref().to_string())
            .unwrap_or_else(|| "stdout".to_string());

        self.resource_uri = resource_uri
            .as_ref()
            .map(|r| r.value.as_ref().to_string())
            .unwrap_or_else(|| self.resource_uri.clone());

        self.shell_run_time = shell_run_time
            .as_ref()
            .map(|t| t.value.as_ref().to_string());

        self.shell_inactivity = shell_inactivity
            .as_ref()
            .map(|t| t.value.as_ref().to_string());

        let resource_created = soap_envelop.body.as_ref().resource_created.as_ref().ok_or(
            crate::PwshCoreError::InvalidResponse("No ResourceCreated found in response".into()),
        )?;

        let reference_parameters = resource_created.as_ref().reference_parameters.as_ref();

        let selector_set = &reference_parameters.selector_set;

        self.selector_set = selector_set.value.clone();

        self.opened = true;

        Ok(())
    }

    pub(crate) fn create_pipeline_request<'a>(
        &'a self,
        connection: &'a WsMan,
        command_id: uuid::Uuid,
        arguments: Vec<String>,
        executable: Option<String>,
        no_shell: Option<bool>,
    ) -> Result<impl Into<Element<'a>>, crate::PwshCoreError> {
        let command_line = CommandLineValue {
            command: executable,
            arguments,
        };

        let request = connection.invoke(
            ws_management::WsAction::Command,
            Some(self.resource_uri.as_ref()),
            SoapBody::builder()
                .command_line(
                    Tag::new(command_line).with_attribute(Attribute::CommandId(command_id)),
                )
                .build(),
            Some(OptionSetValue::default().add_option(
                "WINRS_SKIP_CMD_SHELL",
                no_shell.unwrap_or_default().to_string(),
            )),
            self.selector_set.clone().into(),
        );

        Ok(request)
    }

    /// Send data to the shell stdin (for host responses)
    /// TODO: We should handle fragmentation properly
    pub fn send_data_request<'a>(
        &'a self,
        connection: &'a WsMan,
        command_id: Option<uuid::Uuid>,
        data: Vec<String>,
    ) -> Result<impl Into<Element<'a>>, crate::PwshCoreError> {
        use protocol_winrm::{
            cores::{Tag, tag_name::Send},
            soap::body::SoapBody,
        };

        // Add send tag with data
        let send_tag = if let Some(cmd_id) = command_id {
            // For pipeline-scoped sends, include CommandId
            Tag::from_name(Send)
                .with_value(Text::from(data.join("")))
                .with_attribute(Attribute::CommandId(cmd_id))
        } else {
            // For runspace-scoped sends, no CommandId
            Tag::from_name(Send).with_value(Text::from(data.join("")))
        };

        let request = connection.invoke(
            ws_management::WsAction::Send,
            Some(self.resource_uri.as_ref()),
            SoapBody::builder().send(send_tag).build(),
            Some(
                OptionSetValue::default()
                    .add_option("WSMAN_CMDSHELL_OPTION_KEEPALIVE", true.to_string()),
            ),
            self.selector_set.clone().into(),
        );

        Ok(request)
    }

    pub fn accept_commannd_response<'a>(
        &mut self,
        soap_envelope: &SoapEnvelope<'a>,
    ) -> Result<Uuid, crate::PwshCoreError> {
        let command_id = soap_envelope
            .body
            .as_ref()
            .command_response
            .as_ref()
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "No CommandResponse found in response".into(),
            ))?
            .as_ref()
            .as_ref();

        Ok(command_id.0)
    }
}

#[derive(Debug, Clone)]
pub(crate) struct Stream {
    name: String,
    command_id: Option<Uuid>,
    value: Vec<u8>,
}

impl Stream {
    pub(crate) fn name(&self) -> &str {
        &self.name
    }

    pub(crate) fn command_id(&self) -> Option<&Uuid> {
        self.command_id.as_ref()
    }

    pub(crate) fn value(&self) -> &[u8] {
        &self.value
    }
}

impl<'a> TryFrom<&Tag<'a, Text<'a>, tag_name::Stream>> for Stream {
    type Error = crate::PwshCoreError;

    fn try_from(value: &Tag<'a, Text<'a>, tag_name::Stream>) -> Result<Self, Self::Error> {
        let attributes = &value.attributes;
        let name = attributes
            .iter()
            .find_map(|attr| match attr {
                Attribute::Name(name) => Some(name.to_string()),
                _ => None,
            })
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "Stream tag missing name attribute".into(),
            ))?;

        let command_id = attributes.iter().find_map(|attr| match attr {
            Attribute::CommandId(id) => Some(id.to_owned()),
            _ => None,
        });

        // let value = value.value.as_ref();
        let value = base64::engine::general_purpose::STANDARD
            .decode(value.value.as_ref())
            .map_err(|_| {
                crate::PwshCoreError::InvalidResponse("Failed to decode stream value".into())
            })?;

        Ok(Stream {
            name,
            command_id,
            value,
        })
    }
}

#[derive(Debug)]
pub struct CommandState {
    pub command_id: Uuid,
    pub state: String,
    pub exit_code: Option<i32>,
}

impl<'a> TryFrom<&Tag<'a, CommandStateValue<'a>, tag_name::CommandState>> for CommandState {
    type Error = crate::PwshCoreError;

    fn try_from(
        value: &Tag<'a, CommandStateValue<'a>, tag_name::CommandState>,
    ) -> Result<Self, Self::Error> {
        let command_id = value
            .attributes
            .iter()
            .find_map(|attr| match attr {
                Attribute::CommandId(id) => Some(id),
                _ => None,
            })
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "CommandState tag missing command_id attribute".into(),
            ))?;

        let state = value
            .attributes
            .iter()
            .find_map(|attr| match attr {
                Attribute::State(state) => Some(state.to_string()),
                _ => None,
            })
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "CommandState tag missing state attribute".into(),
            ))?;

        let exit_code = value
            .value
            .exit_code
            .as_ref()
            .map(|exit_code| exit_code.value.0);

        Ok(CommandState {
            command_id: *command_id,
            state: state.to_string(),
            exit_code,
        })
    }
}

impl CommandState {
    pub fn is_done(&self) -> bool {
        self.state == "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/CommandState/Done"
    }
}


--- File: crates/pwsh-core/src/runspace_pool/creator.rs ---
use std::{collections::HashMap, sync::Arc};

use protocol_powershell_remoting::{
    ApartmentState, ApplicationPrivateData, Defragmenter, Fragmenter, HostInfo, PSThreadOptions,
    PsValue, SessionCapability,
};
use protocol_winrm::ws_management::WsMan;

use crate::{pipeline::Pipeline, runspace::win_rs::WinRunspace};

use super::{enums::RunspacePoolState, pool::RunspacePool};

#[derive(Debug, typed_builder::TypedBuilder)]
pub struct RunspacePoolCreator {
    #[builder(default = uuid::Uuid::new_v4())]
    id: uuid::Uuid,
    #[builder(default = RunspacePoolState::BeforeOpen)]
    pub(crate) state: RunspacePoolState,

    #[builder(default = 1)]
    min_runspaces: usize,
    #[builder(default = 1)]
    max_runspaces: usize,

    #[builder(default = PSThreadOptions::Default)]
    thread_options: PSThreadOptions,

    #[builder(default = ApartmentState::Unknown)]
    apartment_state: ApartmentState,

    host_info: HostInfo,

    #[builder(default = std::collections::BTreeMap::new())]
    application_arguments: std::collections::BTreeMap<PsValue, PsValue>,

    #[builder(default = Defragmenter::new())]
    defragmenter: Defragmenter,

    #[builder(default)]
    application_private_data: Option<ApplicationPrivateData>,

    #[builder(default)]
    session_capability: Option<SessionCapability>,

    #[builder(default)]
    pipelines: HashMap<uuid::Uuid, Pipeline>,
}

impl RunspacePoolCreator {
    pub fn into_runspace_pool(self, connection: Arc<WsMan>) -> RunspacePool {
        let shell = WinRunspace::builder().id(self.id).build();

        RunspacePool {
            id: self.id,
            state: self.state,
            min_runspaces: self.min_runspaces,
            max_runspaces: self.max_runspaces,
            thread_options: self.thread_options,
            apartment_state: self.apartment_state,
            host_info: self.host_info,
            application_arguments: self.application_arguments,
            fragmenter: Fragmenter::new(connection.max_envelope_size() as usize),
            connection,
            shell,
            defragmenter: self.defragmenter,
            application_private_data: self.application_private_data,
            session_capability: self.session_capability,
            pipelines: self.pipelines,
            runspace_pool_desired_stream_is_pooling: false,
        }
    }
}


--- File: crates/pwsh-core/src/runspace_pool/enums.rs ---
use protocol_powershell_remoting::RunspacePoolStateValue;

#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub enum PowerShellState {
    CreatePipelineSent,
    Ready,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PsInvocationState {
    NotStarted = 0,
    Running = 1,
    Stopping = 2,
    Stopped = 3,
    Completed = 4,
    Failed = 5,
    Disconnected = 6,
}

impl From<protocol_powershell_remoting::PSInvocationState> for PsInvocationState {
    fn from(value: protocol_powershell_remoting::PSInvocationState) -> Self {
        match value {
            protocol_powershell_remoting::PSInvocationState::NotStarted => {
                PsInvocationState::NotStarted
            }
            protocol_powershell_remoting::PSInvocationState::Running => PsInvocationState::Running,
            protocol_powershell_remoting::PSInvocationState::Stopping => {
                PsInvocationState::Stopping
            }
            protocol_powershell_remoting::PSInvocationState::Stopped => PsInvocationState::Stopped,
            protocol_powershell_remoting::PSInvocationState::Completed => {
                PsInvocationState::Completed
            }
            protocol_powershell_remoting::PSInvocationState::Failed => PsInvocationState::Failed,
            protocol_powershell_remoting::PSInvocationState::Disconnected => {
                PsInvocationState::Disconnected
            }
        }
    }
}

/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/b05495bc-a9b2-4794-9f43-4bf1f3633900
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum RunspacePoolState {
    BeforeOpen = 0,
    Opening = 1,
    Opened = 2,
    Closed = 3,
    Closing = 4,
    Broken = 5,
    NegotiationSent = 6,
    NegotiationSucceeded = 7,
    Connecting = 8,
    Disconnected = 9,
}

impl From<&RunspacePoolStateValue> for RunspacePoolState {
    fn from(value: &RunspacePoolStateValue) -> Self {
        match value {
            RunspacePoolStateValue::BeforeOpen => RunspacePoolState::BeforeOpen,
            RunspacePoolStateValue::Opening => RunspacePoolState::Opening,
            RunspacePoolStateValue::Opened => RunspacePoolState::Opened,
            RunspacePoolStateValue::Closed => RunspacePoolState::Closed,
            RunspacePoolStateValue::Closing => RunspacePoolState::Closing,
            RunspacePoolStateValue::Broken => RunspacePoolState::Broken,
            RunspacePoolStateValue::NegotiationSent => RunspacePoolState::NegotiationSent,
            RunspacePoolStateValue::NegotiationSucceeded => RunspacePoolState::NegotiationSucceeded,
            RunspacePoolStateValue::Connecting => RunspacePoolState::Connecting,
            RunspacePoolStateValue::Disconnected => RunspacePoolState::Disconnected,
        }
    }
}


--- File: crates/pwsh-core/src/runspace_pool/expect_shell_created.rs ---
use protocol_winrm::soap::SoapEnvelope;
use xml::parser::XmlDeserialize;

use super::pool::RunspacePool;

#[derive(Debug)]
pub struct ExpectShellCreated {
    pub(super) runspace_pool: RunspacePool,
}

impl ExpectShellCreated {
    pub fn accept(self, response: String) -> Result<RunspacePool, crate::PwshCoreError> {
        let ExpectShellCreated { mut runspace_pool } = self;

        let parsed = xml::parser::parse(response.as_str())?;

        let soap_response = SoapEnvelope::from_node(parsed.root_element())
            .map_err(crate::PwshCoreError::XmlParsingError)?;

        runspace_pool.shell.accept_create_response(&soap_response)?;

        Ok(runspace_pool)
    }
}


--- File: crates/pwsh-core/src/runspace_pool/mod.rs ---
pub mod creator;
pub mod enums;
pub mod expect_shell_created;
pub mod pool;
pub mod types;

// Re-export public types
pub use creator::RunspacePoolCreator;
pub use enums::{PowerShellState, PsInvocationState, RunspacePoolState};
pub use expect_shell_created::ExpectShellCreated;
pub use pool::{DesiredStream, RunspacePool};
pub use types::{PipelineRepresentation, Runspace};


--- File: crates/pwsh-core/src/runspace_pool/pool.rs ---
use std::{
    collections::{HashMap, HashSet},
    sync::Arc,
};

use base64::Engine;
use protocol_powershell_remoting::{
    ApartmentState, ApplicationPrivateData, CreatePipeline, Defragmenter, HostInfo,
    InitRunspacePool, PSThreadOptions, PipelineOutput, PsValue, RunspacePoolStateMessage,
    SessionCapability, fragmentation,
};
use protocol_winrm::{
    soap::SoapEnvelope,
    ws_management::{OptionSetValue, WsMan},
};
use tracing::{debug, error, info, instrument, trace, warn};
use uuid::Uuid;
use xml::parser::XmlDeserialize;

use crate::{
    PwshCoreError,
    host::{HostCallRequest, HostCallScope},
    pipeline::{Pipeline, PipelineCommand},
    powershell::{PipelineHandle, PipelineOutputType},
    runspace::win_rs::WinRunspace,
    runspace_pool::PsInvocationState,
};

use super::enums::RunspacePoolState;

const PROTOCOL_VERSION: &str = "2.3";
const PS_VERSION: &str = "2.0";
const SERIALIZATION_VERSION: &str = "1.1.0.1";

#[derive(Debug, Clone)]
pub struct DesiredStream {
    name: String,
    command_id: Option<Uuid>,
}
impl DesiredStream {
    pub(crate) fn new(name: impl Into<String>, command_id: Option<Uuid>) -> Self {
        Self {
            name: name.into(),
            command_id,
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn command_id(&self) -> Option<&Uuid> {
        self.command_id.as_ref()
    }

    pub(crate) fn runspace_pool_streams() -> Vec<Self> {
        vec![DesiredStream {
            name: "stdout".to_string(),
            command_id: None,
        }]
    }

    pub(crate) fn pipeline_streams(command_id: Uuid) -> Vec<Self> {
        vec![
            DesiredStream {
                name: "stdout".to_string(),
                command_id: Some(command_id),
            },
            DesiredStream {
                name: "stderr".to_string(),
                command_id: Some(command_id),
            },
        ]
    }

    pub(crate) fn stdout_for_command(command_id: Uuid) -> Self {
        DesiredStream {
            name: "stdout".to_string(),
            command_id: Some(command_id),
        }
    }
}

#[derive(Debug)]
pub enum AcceptResponsResult {
    ReceiveResponse {
        desired_streams: Vec<DesiredStream>,
    },
    PipelineCreated(PipelineHandle),
    PipelineFinished(PipelineHandle),
    HostCall(HostCallRequest),
    PipelineOutput {
        output: PipelineOutput,
        handle: PipelineHandle,
    },
}

#[derive(Debug)]
pub enum PwshMessageResponse {
    HostCall(HostCallRequest),
    PipelineOutput {
        output: PipelineOutput,
        handle: PipelineHandle,
    },
}

impl PwshMessageResponse {
    pub fn name(&self) -> &str {
        match self {
            PwshMessageResponse::HostCall(_) => "HostCall",
            PwshMessageResponse::PipelineOutput { .. } => "PipelineOutput",
        }
    }
}

impl From<PwshMessageResponse> for AcceptResponsResult {
    fn from(response: PwshMessageResponse) -> Self {
        match response {
            PwshMessageResponse::HostCall(host_call) => AcceptResponsResult::HostCall(host_call),
            PwshMessageResponse::PipelineOutput { output, handle } => {
                AcceptResponsResult::PipelineOutput { output, handle }
            }
        }
    }
}

#[derive(Debug)]
pub struct RunspacePool {
    pub(super) id: uuid::Uuid,
    pub(crate) state: RunspacePoolState,
    pub(super) min_runspaces: usize,
    pub(super) max_runspaces: usize,
    pub(super) thread_options: PSThreadOptions,
    pub(super) apartment_state: ApartmentState,
    pub(super) host_info: HostInfo,
    pub(super) application_arguments: std::collections::BTreeMap<PsValue, PsValue>,
    pub(super) shell: WinRunspace,
    pub(super) connection: Arc<WsMan>,
    pub(super) defragmenter: Defragmenter,
    pub(super) application_private_data: Option<ApplicationPrivateData>,
    pub(super) session_capability: Option<SessionCapability>,
    pub(super) pipelines: HashMap<uuid::Uuid, Pipeline>,
    pub(super) fragmenter: fragmentation::Fragmenter,
    pub(super) runspace_pool_desired_stream_is_pooling: bool,
}

impl RunspacePool {
    #[instrument(skip(self), name = "RunspacePool::open")]
    pub fn open(
        mut self,
    ) -> Result<(String, super::expect_shell_created::ExpectShellCreated), crate::PwshCoreError>
    {
        if self.state != RunspacePoolState::BeforeOpen {
            return Err(crate::PwshCoreError::InvalidState(
                "RunspacePool must be in BeforeOpen state to open",
            ));
        }

        let session_capability = SessionCapability {
            protocol_version: PROTOCOL_VERSION.to_string(),
            ps_version: PS_VERSION.to_string(),
            serialization_version: SERIALIZATION_VERSION.to_string(),
            time_zone: None,
        };

        let init_runspace_pool = InitRunspacePool {
            min_runspaces: self.min_runspaces as i32,
            max_runspaces: self.max_runspaces as i32,
            thread_options: self.thread_options,
            apartment_state: self.apartment_state,
            host_info: self.host_info.clone(),
            application_arguments: self.application_arguments.clone(),
        };

        debug!(
            session_capability = ?session_capability,
            min_runspaces = self.min_runspaces,
            max_runspaces = self.max_runspaces,
            "starting runspace pool open"
        );
        debug!(init_runspace_pool = ?init_runspace_pool);

        let request_groups = self.fragmenter.fragment_multiple(
            &[&session_capability, &init_runspace_pool],
            self.id,
            None,
        )?;

        trace!(
            target: "fragmentation",
            request_groups = ?request_groups,
            group_count = request_groups.len(),
            "fragmented negotiation requests"
        );

        self.state = RunspacePoolState::NegotiationSent;

        debug_assert!(
            request_groups.len() == 1,
            "We should have only one request group for the opening negotiation"
        );

        let request = request_groups
            .into_iter()
            .next()
            .ok_or(crate::PwshCoreError::UnlikelyToHappen(
                "No request group generated for negotiation",
            ))
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))?;

        let option_set = OptionSetValue::new().add_option("protocolversion", PROTOCOL_VERSION);

        let result = self
            .shell
            .open(&self.connection, Some(option_set), &request);

        Ok((
            result.into().to_xml_string()?,
            super::expect_shell_created::ExpectShellCreated {
                runspace_pool: self,
            },
        ))
    }

    // We should accept the pipeline id here, but for now let's ignore it
    pub(crate) fn fire_receive<'a>(
        &mut self,
        desired_streams: Vec<DesiredStream>,
    ) -> Result<String, crate::PwshCoreError> {
        debug_assert!(!desired_streams.is_empty(), "At least one desired stream");
        Ok(self
            .shell
            .fire_receive(&self.connection, desired_streams)
            .into()
            .to_xml_string()?)
    }

    #[instrument(skip(self, soap_envelope), fields(envelope_length = soap_envelope.len()))]
    pub(crate) fn accept_response(
        &mut self,
        soap_envelope: String,
    ) -> Result<Vec<AcceptResponsResult>, crate::PwshCoreError> {
        debug!(target: "soap", "parsing SOAP envelope");

        let parsed = xml::parser::parse(soap_envelope.as_str()).map_err(|e| {
            error!(target: "xml", error = %e, "failed to parse XML");
            e
        })?;

        let soap_envelope = SoapEnvelope::from_node(parsed.root_element()).map_err(|e| {
            error!(target: "soap", error = %e, "failed to parse SOAP envelope");
            crate::PwshCoreError::XmlParsingError(e)
        })?;

        let mut result = Vec::new();

        if soap_envelope.body.as_ref().receive_response.is_some() {
            debug!(target: "receive", "processing receive response");

            let (streams, command_state) = self
                .shell
                .accept_receive_response(&soap_envelope)
                .map_err(|e| {
                    error!(target: "receive", error = %e, "failed to accept receive response");
                    e
                })?;

            let streams_ids = streams
                .iter()
                .filter_map(|stream| stream.command_id().cloned())
                .collect::<Vec<_>>();

            let is_there_a_stream_has_no_command_id =
                streams.iter().any(|stream| stream.command_id().is_none());
            if is_there_a_stream_has_no_command_id {
                debug!(
                    target: "receive",
                    "stream without command_id found, should be runspace pool stream"
                );
                self.runspace_pool_desired_stream_is_pooling = false
            }

            debug!(
                target: "receive",
                stream_count = streams.len(),
                stream_command_ids = ?streams_ids,
                "processing streams"
            );

            let handle_pwsh_response = self.handle_pwsh_responses(streams).map_err(|e| {
                error!(target: "pwsh", error = %e, "failed to handle PowerShell responses");
                e
            })?;

            debug!(
                target: "pwsh",
                response_names = ?handle_pwsh_response.iter().map(|r| r.name()).collect::<Vec<_>>(),
                response_count = handle_pwsh_response.len(),
                "handled PowerShell responses"
            );

            result.extend(handle_pwsh_response.into_iter().map(|resp| resp.into()));

            if let Some(command_state) = command_state
                && command_state.is_done()
            {
                debug!(
                    target: "pipeline",
                    pipeline_id = ?command_state.command_id,
                    "command state done received, removing pipeline"
                );
                // If command state is done, we can remove the pipeline from the pool
                let pipeline = self.pipelines.remove(&command_state.command_id);
                if pipeline.is_some() {
                    result.push(AcceptResponsResult::PipelineFinished(PipelineHandle {
                        id: command_state.command_id,
                    }));
                }
            }

            let desired_streams = if !streams_ids.is_empty() {
                // find the intersetction of streams.id and self.pipelines.keys()
                let next_desired_streams = streams_ids.into_iter().filter(|stream| {
                    self.pipelines
                        .keys()
                        .any(|pipeline_id| pipeline_id == stream)
                });

                // keep unique stream with the same id
                let mut stream_set = HashSet::new();

                for stream in next_desired_streams {
                    stream_set.insert(stream);
                }

                stream_set
                    .into_iter()
                    .map(|stream| DesiredStream::new("stdout", stream.to_owned().into()))
                    .collect::<Vec<_>>()
            } else if !self.runspace_pool_desired_stream_is_pooling {
                self.runspace_pool_desired_stream_is_pooling = true;
                DesiredStream::runspace_pool_streams()
            } else {
                vec![]
            };

            if !desired_streams.is_empty() {
                result.push(AcceptResponsResult::ReceiveResponse { desired_streams });
            }
        }

        if soap_envelope.body.as_ref().command_response.is_some() {
            let pipeline_id = self.shell.accept_commannd_response(&soap_envelope)?;

            // We have received the pipeline creation response
            // 1. update the state of the pipeline
            // 2. fire receive request for the new pipeline
            self.pipelines
                .get_mut(&pipeline_id)
                .ok_or(crate::PwshCoreError::InvalidResponse(
                    "Pipeline not found for command response".into(),
                ))?
                .state = PsInvocationState::Running;

            result.push(AcceptResponsResult::ReceiveResponse {
                desired_streams: vec![DesiredStream::stdout_for_command(pipeline_id)],
            });
        }

        debug!(
            target: "accept_response",
            result_count = result.len(),
            result_types = ?result.iter().map(std::mem::discriminant).collect::<Vec<_>>(),
            "accept response results"
        );

        Ok(result)
    }

    pub(crate) fn init_pipeline(
        &mut self,
        uuid: Uuid,
    ) -> Result<PipelineHandle, crate::PwshCoreError> {
        if self.pipelines.get(&uuid).is_some() {
            return Err(crate::PwshCoreError::InvalidState(
                "Pipeline with this UUID already exists",
            ));
        }

        self.pipelines.insert(uuid, Pipeline::new());
        Ok(PipelineHandle { id: uuid })
    }

    /// Fire create pipeline for a specific pipeline handle (used by service API)
    #[instrument(
        skip(self, responses),
        fields(
            response_count = responses.len(),
            processed_messages = 0u32
        )
    )]
    fn handle_pwsh_responses(
        &mut self,
        responses: Vec<crate::runspace::win_rs::Stream>,
    ) -> Result<Vec<PwshMessageResponse>, crate::PwshCoreError> {
        let mut result = Vec::new();
        let span = tracing::Span::current();
        let mut message_count = 0u32;

        for (stream_index, stream) in responses.into_iter().enumerate() {
            debug!(
                target: "stream",
                stream_index,
                stream_name = ?stream.name(),
                pipeline_id = ?stream.command_id(),
                "processing stream"
            );

            let messages = match self.defragmenter.defragment(stream.value()).map_err(|e| {
                error!(target: "defragment", stream_index, error = %e, "failed to defragment stream");
                e
            })? {
                fragmentation::DefragmentResult::Incomplete => {
                    debug!(target: "defragment", stream_index, "stream incomplete, continuing");
                    continue;
                }
                fragmentation::DefragmentResult::Complete(power_shell_remoting_messages) => {
                    debug!(
                        target: "defragment",
                        stream_index,
                        message_count = power_shell_remoting_messages.len(),
                        "stream complete"
                    );
                    power_shell_remoting_messages
                }
            };

            for (msg_index, message) in messages.into_iter().enumerate() {
                message_count += 1;
                span.record("processed_messages", message_count);

                let ps_value = message.parse_ps_message().map_err(|e| {
                    error!(
                        target: "ps_message",
                        stream_index,
                        msg_index,
                        error = %e,
                        "failed to parse PS message"
                    );
                    e
                })?;

                info!(
                    target: "ps_message",
                    message_type = ?message.message_type,
                    stream_index,
                    msg_index,
                    "parsed PS message"
                );

                match message.message_type {
                    protocol_powershell_remoting::MessageType::SessionCapability => {
                        debug!(target: "session", "handling SessionCapability message");
                        self.handle_session_capability(ps_value).map_err(|e| {
                            error!(target: "session", error = %e, "failed to handle SessionCapability");
                            e
                        })?;
                    }
                    protocol_powershell_remoting::MessageType::ApplicationPrivateData => {
                        debug!(target: "session", "handling ApplicationPrivateData message");
                        self.handle_application_private_data(ps_value)
                            .map_err(|e| {
                                error!(target: "session", error = %e, "failed to handle ApplicationPrivateData");
                                e
                            })?;
                    }
                    protocol_powershell_remoting::MessageType::RunspacepoolState => {
                        debug!(target: "runspace", "handling RunspacepoolState message");
                        self.handle_runspacepool_state(ps_value).map_err(|e| {
                            error!(target: "runspace", error = %e, "failed to handle RunspacepoolState");
                            e
                        })?;
                    }
                    protocol_powershell_remoting::MessageType::ProgressRecord => {
                        debug!(
                            target: "progress",
                            stream_name = ?stream.name(),
                            command_id = ?stream.command_id(),
                            "handling ProgressRecord message"
                        );
                        self.handle_progress_record(ps_value, stream.name(), stream.command_id())
                            .map_err(|e| {
                                error!(target: "progress", error = %e, "failed to handle ProgressRecord");
                                e
                            })?;
                    }
                    protocol_powershell_remoting::MessageType::InformationRecord => {
                        debug!(
                            target: "information",
                            stream_name = ?stream.name(),
                            command_id = ?stream.command_id(),
                            "handling InformationRecord message"
                        );
                        self.handle_information_record(
                            ps_value,
                            stream.name(),
                            stream.command_id(),
                        )
                        .map_err(|e| {
                            error!(target: "information", error = %e, "failed to handle InformationRecord");
                            e
                        })?;
                    }
                    protocol_powershell_remoting::MessageType::PipelineState => {
                        debug!(
                            target: "pipeline",
                            stream_name = ?stream.name(),
                            command_id = ?stream.command_id(),
                            "handling PipelineState message"
                        );
                        self.handle_pipeline_state(ps_value, stream.name(), stream.command_id())
                            .map_err(|e| {
                                error!(target: "pipeline", error = %e, "failed to handle PipelineState");
                                e
                            })?;
                    }
                    protocol_powershell_remoting::MessageType::PipelineHostCall => {
                        debug!(
                            target: "host_call",
                            stream_name = ?stream.name(),
                            pipeline_id = ?stream.command_id(),
                            "handling PipelineHostCall message"
                        );

                        let host_call = self
                            .handle_pipeline_host_call(ps_value, stream.name(), stream.command_id())
                            .map_err(|e| {
                                error!(target: "host_call", error = %e, "failed to handle PipelineHostCall");
                                e
                            })?;
                        debug!(target: "host_call", host_call = ?host_call, "successfully created host call");
                        result.push(PwshMessageResponse::HostCall(host_call));
                        debug!(target: "host_call", result_len = result.len(), "pushed HostCall response");
                    }
                    protocol_powershell_remoting::MessageType::PipelineOutput => {
                        debug!(
                            target: "pipeline_output",
                            stream_name = ?stream.name(),
                            command_id = ?stream.command_id(),
                            "handling PipelineOutput message"
                        );

                        let output = self.handle_pipeline_output(ps_value)?;

                        debug!(target: "pipeline_output", output = ?output, "successfully handled PipelineOutput");
                        result.push(PwshMessageResponse::PipelineOutput {
                            output,
                            handle: PipelineHandle {
                                id: *stream.command_id().ok_or(
                                    crate::PwshCoreError::InvalidResponse(
                                        "PipelineOutput message must have a command_id".into(),
                                    ),
                                )?,
                            },
                        });
                    }
                    _ => {
                        error!(
                            target: "ps_message",
                            message_type = ?message.message_type,
                            "received message type but no handler implemented"
                        );
                        todo!("Handle other message types as needed");
                    }
                }
            }
        }

        info!(
            target: "pwsh_responses",
            result_count = result.len(),
            total_messages_processed = message_count,
            "processed PowerShell responses"
        );
        Ok(result)
    }

    #[instrument(skip(self, session_capability), fields(protocol_version = tracing::field::Empty, ps_version = tracing::field::Empty))]
    fn handle_session_capability(
        &mut self,
        session_capability: PsValue,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(session_capability) = session_capability else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected SessionCapability as PsValue::Object".into(),
            ));
        };

        let session_capability = SessionCapability::try_from(session_capability)?;

        // Record the protocol and PS versions in the span
        let span = tracing::Span::current();
        span.record("protocol_version", &session_capability.protocol_version);
        span.record("ps_version", &session_capability.ps_version);

        debug!(
            target: "session",
            capability = ?session_capability,
            "received SessionCapability"
        );
        self.session_capability = Some(session_capability);
        Ok(())
    }

    #[instrument(skip(self, app_data))]
    fn handle_application_private_data(
        &mut self,
        app_data: PsValue,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(app_data) = app_data else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected ApplicationPrivateData as PsValue::Object".into(),
            ));
        };

        let app_data = ApplicationPrivateData::try_from(app_data)?;
        trace!(target: "session", app_data = ?app_data, "received ApplicationPrivateData");
        self.application_private_data = Some(app_data);
        Ok(())
    }

    #[instrument(skip(self, ps_value), fields(runspace_state = tracing::field::Empty))]
    fn handle_runspacepool_state(&mut self, ps_value: PsValue) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(runspacepool_state) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected RunspacepoolState as PsValue::Object".into(),
            ));
        };

        let runspacepool_state = RunspacePoolStateMessage::try_from(runspacepool_state)?;

        // Record the state in the span
        let span = tracing::Span::current();
        span.record(
            "runspace_state",
            format!("{:?}", runspacepool_state.runspace_state),
        );

        trace!(target: "runspace", state = ?runspacepool_state, "received RunspacePoolState");

        self.state = RunspacePoolState::from(&runspacepool_state.runspace_state);

        Ok(())
    }

    #[instrument(skip(self, ps_value), fields(stream_name, command_id = ?command_id))]
    fn handle_progress_record(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(progress_record) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected ProgressRecord as PsValue::Object".into(),
            ));
        };

        let progress_record =
            protocol_powershell_remoting::ProgressRecord::try_from(progress_record)?;

        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        trace!(
            target: "progress",
            progress_record = ?progress_record,
            stream_name = stream_name,
            command_id = ?command_id,
            "received ProgressRecord"
        );

        // Find the pipeline by command_id
        let pipeline = self
            .pipelines
            .get_mut(command_id)
            .ok_or(PwshCoreError::InvalidResponse(
                "Pipeline not found for command_id".into(),
            ))?;

        pipeline.add_progress_record(progress_record);

        Ok(())
    }

    #[instrument(skip(self, ps_value, stream_name, command_id))]
    fn handle_information_record(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(info_record) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected InformationRecord as PsValue::Object".into(),
            ));
        };

        let info_record = protocol_powershell_remoting::InformationRecord::try_from(info_record)?;
        trace!(
            ?info_record,
            stream_name = stream_name,
            command_id = ?command_id,
            "Received InformationRecord"
        );

        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        // Find the pipeline by command_id
        let pipeline = self
            .pipelines
            .get_mut(command_id)
            .ok_or(PwshCoreError::InvalidResponse(
                "Pipeline not found for command_id".into(),
            ))?;

        pipeline.add_information_record(info_record);

        Ok(())
    }

    #[instrument(skip(self, ps_value, stream_name, command_id))]
    fn handle_pipeline_state(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(pipeline_state) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected PipelineState as PsValue::Object".into(),
            ));
        };

        let pipeline_state =
            protocol_powershell_remoting::PipelineStateMessage::try_from(pipeline_state)?;
        trace!(
            ?pipeline_state,
            stream_name = stream_name,
            command_id = ?command_id,
            "Received PipelineState"
        );
        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        // Find the pipeline by command_id
        let pipeline = self
            .pipelines
            .get_mut(command_id)
            .ok_or(PwshCoreError::InvalidResponse(
                "Pipeline not found for command_id".into(),
            ))?;
        // Update the pipeline state
        pipeline.state = PsInvocationState::from(pipeline_state.pipeline_state);

        Ok(())
    }

    // --- PowerShell Pipeline Management API ---
    // Note: PowerShell handles are created by the server via fire_create_pipeline/accept_response flow
    // Users should get handles from the ActiveSession after calling CreatePipeline operation

    /// Adds a switch parameter (no value) to the last command in the specified pipeline.
    pub fn add_switch_parameter(
        &mut self,
        handle: PipelineHandle,
        name: String,
    ) -> Result<(), PwshCoreError> {
        let pipeline = self
            .pipelines
            .get_mut(&handle.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;

        if pipeline.state != PsInvocationState::NotStarted {
            return Err(PwshCoreError::InvalidState(
                "Cannot add to a pipeline that has already been started",
            ));
        }

        pipeline.add_switch_parameter(name);
        Ok(())
    }

    /// Invokes the specified pipeline and waits for its completion.
    ///
    /// This method will handle the entire PSRP message exchange:
    /// 1. Send the `CreatePipeline` message.
    /// 2. Send `Command`, `Send`, and `EndOfInput` messages.
    /// 3. Enter a loop to `Receive` and process responses.
    /// 4. Defragment and deserialize messages, updating the pipeline's state, output, and error streams.
    /// 5. Return the final output upon completion.
    pub fn invoke_pipeline_request(
        &mut self,
        handle: PipelineHandle,
        output_type: PipelineOutputType,
    ) -> Result<String, PwshCoreError> {
        let pipeline = self
            .pipelines
            .get_mut(&handle.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;

        if let PipelineOutputType::Streamed = output_type {
            pipeline.add_command(PipelineCommand::new_output_stream());
        }

        // Set pipeline state to Running
        pipeline.state = PsInvocationState::Running;
        info!(pipeline_id = %handle.id(), "Invoking pipeline");

        // Convert business pipeline to protocol pipeline and build CreatePipeline message
        let protocol_pipeline = pipeline.to_protocol_pipeline()?;
        let create_pipeline = CreatePipeline::builder()
            .power_shell(protocol_pipeline)
            .host_info(self.host_info.clone())
            .apartment_state(self.apartment_state)
            .build();

        debug!(?create_pipeline);

        let fragmented =
            self.fragmenter
                .fragment(&create_pipeline, self.id, Some(handle.id()), None)?;

        let arguments = fragmented
            .into_iter()
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))
            .collect::<Vec<_>>();

        let request = self.shell.create_pipeline_request(
            &self.connection,
            handle.id(),
            arguments,
            None,
            None,
        )?;

        Ok(request.into().to_xml_string()?)
    }

    #[instrument(skip_all)]
    pub fn handle_pipeline_host_call(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<HostCallRequest, crate::PwshCoreError> {
        let PsValue::Object(pipeline_host_call) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected PipelineHostCall as PsValue::Object".into(),
            ));
        };

        let pipeline_host_call =
            protocol_powershell_remoting::PipelineHostCall::try_from(pipeline_host_call)?;

        debug!(
            ?pipeline_host_call,
            stream_name = stream_name,
            command_id = ?command_id,
            method_id = pipeline_host_call.method_id,
            method_name = pipeline_host_call.method_name,
            parameter_count = pipeline_host_call.parameters.len(),
            "Received PipelineHostCall"
        );

        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        Ok(HostCallRequest::from((
            &pipeline_host_call,
            HostCallScope::Pipeline {
                command_id: command_id.to_owned(),
            },
        )))
    }

    /// Send a pipeline host response to the server
    pub fn send_pipeline_host_response(
        &mut self,
        command_id: uuid::Uuid,
        host_response: protocol_powershell_remoting::PipelineHostResponse,
    ) -> Result<String, PwshCoreError> {
        // Fragment the host response message
        let fragmented =
            self.fragmenter
                .fragment(&host_response, self.id, Some(command_id), None)?;

        // Encode fragments as base64
        let arguments = fragmented
            .into_iter()
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))
            .collect::<Vec<_>>();

        // Create WS-Man Send request (send data to stdin)
        let request =
            self.shell
                .send_data_request(&self.connection, Some(command_id), arguments)?;

        Ok(request.into().to_xml_string()?)
    }

    /// Send a runspace pool host response to the server
    pub fn send_runspace_pool_host_response(
        &mut self,
        host_response: protocol_powershell_remoting::RunspacePoolHostResponse,
    ) -> Result<String, PwshCoreError> {
        // Fragment the host response message
        let fragmented = self.fragmenter.fragment(
            &host_response,
            self.id,
            None, // No command ID for runspace pool messages
            None,
        )?;

        // Encode fragments as base64
        let arguments = fragmented
            .into_iter()
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))
            .collect::<Vec<_>>();

        // Create WS-Man Send request (send data to stdin)
        let request = self.shell.send_data_request(
            &self.connection,
            None, // No command ID for runspace pool
            arguments,
        )?;

        Ok(request.into().to_xml_string()?)
    }

    pub fn handle_pipeline_output(
        &mut self,
        ps_value: PsValue,
    ) -> Result<PipelineOutput, PwshCoreError> {
        let pipeline_output = PipelineOutput::from(ps_value);

        Ok(pipeline_output)
    }

    pub(crate) fn add_command(
        &mut self,
        powershell: PipelineHandle,
        command: PipelineCommand,
    ) -> Result<(), PwshCoreError> {
        let pipeline = self
            .pipelines
            .get_mut(&powershell.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;

        if pipeline.state != PsInvocationState::NotStarted {
            return Err(PwshCoreError::InvalidState(
                "Cannot add to a pipeline that has already been started",
            ));
        }

        pipeline.add_command(command);
        Ok(())
    }
}


--- File: crates/pwsh-core/src/runspace_pool/types.rs ---
use std::hash::Hash;

use crate::runspace_pool::PsInvocationState;

#[derive(Debug, Clone)]
pub struct PipelineRepresentation {
    pub id: uuid::Uuid,
    pub state: PsInvocationState,
}

impl PipelineRepresentation {
    pub fn new(id: uuid::Uuid) -> Self {
        PipelineRepresentation {
            id,
            state: PsInvocationState::NotStarted,
        }
    }

    pub fn id(&self) -> uuid::Uuid {
        self.id
    }
}

impl Hash for PipelineRepresentation {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}

impl PartialEq for PipelineRepresentation {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl Eq for PipelineRepresentation {}

pub struct Runspace {
    pub id: uuid::Uuid,
    pub state: super::enums::RunspacePoolState,
}


--- File: crates/xml/.gitattributes ---
# Auto detect text files and perform LF normalization
* text=auto


--- File: crates/xml/.gitignore ---
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb


# Added by cargo

/target


--- File: crates/xml/Cargo.toml ---
[package]
name = "xml"
version = "0.1.0"
edition = "2021"
authors = ["Aarav Shah <aaravaditya51@gmail.com>","Irving Ou <jou@devolutions.com>"]
description = "A lightweight and intuitive library for generating XML documents in Rust"
readme = "README.md"
license = "MIT OR Apache-2.0"
keywords = ["xml", "xml-builder", "xml-generation"]

[dependencies]
roxmltree = "0.20.0"
thiserror = "2.0.12"
tracing = "0.1.41"



--- File: crates/xml/README.md ---
# A fork from einfach-xml-builder-rs, original src https://github.com/Deaths-Door/xml-builder-rs



--- File: crates/xml/examples/build.rs ---
use xml::builder::{Attribute, Builder, Declaration, Element};

const NS1: &str = "http://example.com/ns1";
const NS2: &str = "http://example.com/ns2";
const NS1_ALIAS: &str = "ns1";
const NS2_ALIAS: &str = "ns2";

fn main() {
    // Create an XML declaration
    let declaration = Declaration::new("1.0", "UTF-8").with_standalone(true);

    // Create an XML element
    let element = Element::new("root")
        .add_attribute(Attribute::new("attr1", "value1"))
        .add_attribute(Attribute::new("attr2", "value2"))
        .add_child(
            Element::new("child1").set_namespace(NS1).add_child(
                Element::new("grandchild")
                    .add_attribute(Attribute::new("attr", "value"))
                    .set_namespace(NS2),
            ),
        )
        .add_child(
            Element::new("child2")
                .set_namespace(NS2)
                .add_namespace_declaration(NS2, Some(NS2_ALIAS))
                .set_text("Text content for child2")
                .add_attribute(Attribute::new("attr2", "value2").set_namespace(NS1)),
        )
        .add_child(Element::new("child3"));

    // Create a builder with the declaration and element
    let builder = Builder::new(
        Some(declaration),
        element.add_namespace_declaration(NS1, Some(NS1_ALIAS)),
    );

    // Print the XML document
    println!("{}", builder.to_xml_string().unwrap());
}


--- File: crates/xml/examples/parse.rs ---
const SOAP: &str = r#"
<s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope"
            xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing"
            xmlns:wsman="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd">
  <s:Header>
    <wsa:To s:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</wsa:To>
    <wsa:ReplyTo>
      <wsa:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</wsa:Address>
    </wsa:ReplyTo>
    <wsa:Action>http://schemas.xmlsoap.org/ws/2004/09/transfer/Get</wsa:Action>
    <wsa:MessageID>uuid:12345678-1234-1234-1234-1234567890ab</wsa:MessageID>
    <wsman:ResourceURI>http://schemas.microsoft.com/wbem/wsman/1/wmi/root/cimv2/Win32_OperatingSystem</wsman:ResourceURI>
    <wsman:OperationTimeout>PT60.000S</wsman:OperationTimeout>
    <wsman:Locale xml:lang="en-US" />
    <wsman:OptionSet>
      <wsman:Option Name="OptimizeEnumeration">true</wsman:Option>
    </wsman:OptionSet>
    <wsman:MaxEnvelopeSize s:mustUnderstand="true">153600</wsman:MaxEnvelopeSize>
  </s:Header>
  <s:Body />
</s:Envelope>
"#;

pub fn main() {
    let mut parsed = xml::parser::parse(SOAP).expect("Failed to parse XML");
    let root = parsed.root();
    for child in root.children() {
        // println!("{:#?}", child);
        for grandchild in child.children() {
            // println!("|  {:#?}", grandchild);
            for great_grandchild in grandchild.children() {
                if great_grandchild.attributes().len() > 0 {
                    println!("Found tag with attributes: ");
                    println!("Tag Name: {}", great_grandchild.tag_name().name());
                    for attr in great_grandchild.attributes() {
                        println!("  Attribute: {} = {}", attr.name(), attr.value());
                    }

                    println!("|  Children of this tag:");
                    for great_great_grandchild in great_grandchild.children() {
                        println!(
                            "|  Child Tag Name: {}",
                            great_great_grandchild.tag_name().name()
                        );
                        println!(
                            "|  Child Tag Type: {:?}",
                            great_great_grandchild.node_type()
                        )
                    }
                    println!("==========================");
                }
            }
        }
    }
}


--- File: crates/xml/src/builder/attribute.rs ---
use std::{borrow::Cow, collections::HashMap, io::Write as _};

/// Represents an XML attribute with a name and value.
#[derive(Debug, Clone)]
pub struct Attribute<'a> {
    /// The name of the attribute.
    name: &'a str,
    /// The value of the attribute.
    value: Cow<'a, str>,

    namespace: Option<crate::builder::Namespace<'a>>,
}

impl<'a> Attribute<'a> {
    /// Creates a new instance of `Attribute`.
    ///
    /// # Arguments
    ///
    /// * `name` - The name of the attribute.
    /// * `value` - The value of the attribute.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::Attribute;
    /// let attribute = Attribute::new("name", "value");
    /// ```
    pub fn new(name: &'a str, value: impl Into<Cow<'a, str>>) -> Self {
        Attribute {
            name,
            value: value.into(),
            namespace: None,
        }
    }

    pub fn new_with_namespace(
        name: &'a str,
        value: impl Into<Cow<'a, str>>,
        namespace: Option<impl Into<crate::builder::Namespace<'a>>>,
    ) -> Self {
        Attribute {
            name,
            value: value.into(),
            namespace: namespace.map(|ns| ns.into()),
        }
    }

    pub fn set_namespace(mut self, namespace: impl Into<crate::builder::Namespace<'a>>) -> Self {
        self.namespace = Some(namespace.into());
        self
    }

    pub fn get_namespaces(
        &self,
        namespaces_set: &mut std::collections::HashSet<crate::builder::Namespace<'a>>,
    ) {
        if let Some(namespace) = &self.namespace {
            namespaces_set.insert(namespace.clone());
        }
    }
}

impl<'a> crate::builder::NamespaceWrite<'a> for Attribute<'a> {
    fn ns_write<W: std::io::Write>(
        &self,
        w: &mut W,
        alias_map: Option<&crate::builder::AliasMap<'a>>,
    ) -> Result<(), crate::builder::XmlBuilderError> {
        let ns_alias = if let Some(map) = alias_map {
            self.namespace.as_ref().and_then(|ns| map.get(ns)).copied()
        } else if let Some(ns) = &self.namespace {
            return Err(
                crate::builder::XmlBuilderError::MissingAliasMapForAttribute {
                    attr: self.name.to_string(),
                    ns: ns.url.to_string(),
                },
            );
        } else {
            None
        };

        let name = if let Some(Some(alias)) = ns_alias {
            format!("{alias}:{}", self.name)
        } else {
            self.name.to_string()
        };

        w.write_fmt(format_args!(" {}=\"{}\"", name, self.value))?;
        Ok(())
    }
}

impl crate::builder::NamespaceFmt for Attribute<'_> {
    /// Formats the attribute as a string in the format `name="value"`.
    fn ns_fmt(
        &self,
        f: &mut std::fmt::Formatter<'_>,
        alias_map: Option<&HashMap<super::namespace::Namespace<'_>, Option<&str>>>,
    ) -> std::fmt::Result {
        let namespace_alias = if let Some(alias_map) = alias_map {
            self.namespace
                .as_ref()
                .and_then(|ns| alias_map.get(ns))
                .copied()
        } else if let Some(ns) = &self.namespace {
            eprintln!("No namespace alias map provided for attribute: {ns}");
            return Err(std::fmt::Error);
        } else {
            None
        };

        let name = if let Some(Some(alias)) = namespace_alias {
            format!("{}:{}", alias, self.name)
        } else {
            self.name.to_string()
        };

        write!(f, " {}=\"{}\"", name, self.value)?;
        Ok(())
    }
}


--- File: crates/xml/src/builder/builder.rs ---
use crate::builder::{Declaration, Element, NamespaceWrite, XmlBuilderError};

/// Represents a builder for constructing an XML document.
pub struct Builder<'a> {
    /// The XML declaration.
    declaration: Option<Declaration<'a>>,
    /// The root element of the XML document.
    element: Element<'a>,
}

impl<'a> Builder<'a> {
    /// Creates a new instance of `Builder` with the given declaration and root element.
    ///
    /// # Arguments
    ///
    /// * `declaration` - The XML declaration.
    /// * `element` - The root element of the XML document.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::{Builder, Declaration, Element};
    /// let declaration = Declaration::new("1.0", "UTF-8").with_standalone(true);
    /// let element = Element::new("root");
    /// let builder = Builder::new(Some(declaration), element);
    /// ```
    pub fn new(declaration: Option<Declaration<'a>>, element: Element<'a>) -> Self {
        Builder {
            declaration,
            element,
        }
    }

    pub fn write_to<W: std::io::Write>(&self, mut w: W) -> Result<(), XmlBuilderError> {
        if let Some(decl) = &self.declaration {
            decl.write(&mut w)?; // converts to XmlError via From
            w.write_all(b" \n")?;
        }
        self.element.ns_write(&mut w, None)
    }

    pub fn to_xml_string(&self) -> Result<String, XmlBuilderError> {
        let mut buf = Vec::new();
        self.write_to(&mut buf)?;
        Ok(String::from_utf8(buf).expect("XML must be UTF-8"))
    }
}


--- File: crates/xml/src/builder/declaration.rs ---
use std::io::Write as _;

/// Represents an XML declaration.
pub struct Declaration<'a> {
    /// The XML version.
    version: &'a str,
    /// The encoding used for the XML document.
    encoding: &'a str,
    /// The standalone status of the XML document (optional).
    standalone: Option<bool>,
}

impl<'a> Declaration<'a> {
    /// Creates a new instance of `Declaration` with the given version and encoding.
    ///
    /// # Arguments
    ///
    /// * `version` - The XML version.
    /// * `encoding` - The encoding used for the XML document.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::Declaration;
    /// let declaration = Declaration::new("1.0", "UTF-8");
    /// ```
    pub fn new(version: &'a str, encoding: &'a str) -> Self {
        Declaration {
            version,
            encoding,
            standalone: None,
        }
    }

    /// Sets the standalone status of the XML document and returns a modified `Declaration`.
    ///
    /// # Arguments
    ///
    /// * `standalone` - The standalone status of the XML document.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::Declaration;
    /// let declaration = Declaration::new("1.0", "UTF-8")
    ///     .with_standalone(true);
    /// ```
    pub fn with_standalone(mut self, standalone: bool) -> Self {
        self.standalone = Some(standalone);
        self
    }

    pub fn write<W: std::io::Write>(&self, w: &mut W) -> std::io::Result<()> {
        w.write_fmt(format_args!(
            "<?xml version=\"{}\" encoding=\"{}\"",
            self.version, self.encoding
        ))?;
        if let Some(standalone) = self.standalone {
            let s = if standalone { "yes" } else { "no" };
            w.write_fmt(format_args!(" standalone=\"{s}\""))?;
        }
        w.write_all(b"?>")?;
        Ok(())
    }
}

impl<'a> std::fmt::Display for Declaration<'a> {
    /// Formats the declaration as an XML declaration string.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            r#"<?xml version="{}" encoding="{}""#,
            self.version, self.encoding
        )?;

        if let Some(standalone) = self.standalone {
            let standalone_as_string = if standalone { "yes" } else { "no" };

            write!(f, r#" standalone="{standalone_as_string}""#)?;
        }

        write!(f, "?>")?;
        Ok(())
    }
}


--- File: crates/xml/src/builder/element.rs ---
use std::{borrow::Cow, collections::HashMap};

use tracing::error;

use crate::builder::{
    AliasMap, Attribute, Namespace, NamespaceFmt, NamespaceWrite, XmlBuilderError,
};

use std::io::Write as _;

#[derive(Debug, Clone)]
pub enum Content<'a> {
    /// Represents a text content within an XML element.
    Text(Cow<'a, str>),
    /// Represents a child element within an XML element.
    Elements(Vec<Element<'a>>),

    None,
}

/// Represents an XML element.
#[derive(Debug, Clone)]
pub struct Element<'a> {
    /// The name of the element.
    name: &'a str,
    /// The namespaces associated with the element.
    namespace: Option<Namespace<'a>>,
    /// The attributes of the element.
    attributes: Vec<Attribute<'a>>,
    /// The child elements of the element.
    content: Content<'a>,
    /// The namespaces declaretions for this and child elements.
    namespaces_declaration: Option<HashMap<Namespace<'a>, Option<&'a str>>>,
}

impl<'a> Element<'a> {
    /// Creates a new instance of `Element` with the given name.
    ///
    /// # Arguments
    ///
    /// * `name` - The name of the element.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::Element;
    /// let element = Element::new("root");
    /// ```
    pub fn new(name: &'a str) -> Self {
        Element {
            name,
            namespace: None,
            attributes: Vec::new(),
            content: Content::None,
            namespaces_declaration: None,
        }
    }

    /// Adds a namespace to the element and returns a modified `Element`.
    ///
    /// # Arguments
    ///
    /// * `namespace` - The namespace to be added.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::{Element, Namespace};
    /// let element = Element::new("root")
    ///     .set_namespace(Namespace::new("http://example.com"));
    /// ```
    pub fn set_namespace(mut self, ns: impl Into<Namespace<'a>>) -> Self {
        self.namespace = Some(ns.into());
        self
    }

    pub fn set_namespace_optional(mut self, ns: Option<impl Into<Namespace<'a>>>) -> Self {
        if let Some(ns) = ns {
            self.namespace = Some(ns.into());
        } else {
            self.namespace = None;
        }
        self
    }

    /// Namespace alias map is used to resolve namespace prefixes.
    /// for example, if the element has a namespace with a prefix "ns",
    /// the alias map will contain an entry for "ns" pointing to the namespace URI.
    ///  <SomeElement xmlns:ns="http://example.com/ns">
    ///     <ns:SomeChildElement/>
    ///  </SomeElement>
    ///
    pub fn add_namespace_declaration(mut self, namespace: &'a str, alias: Option<&'a str>) -> Self {
        if self.namespaces_declaration.is_none() {
            self.namespaces_declaration = Some(HashMap::new());
        }

        let namespace = Namespace::new(namespace);

        self.namespaces_declaration
            .as_mut()
            .expect("Namespaces should be initialized")
            .insert(namespace.clone(), alias);

        self
    }

    /// Adds an attribute to the element and returns a modified `Element`.
    ///
    /// # Arguments
    ///
    /// * `attribute` - The attribute to be added.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::{Element, Attribute};
    /// let element = Element::new("root")
    ///     .add_attribute(Attribute::new("attr1", "value1"));
    /// ```
    pub fn add_attribute(mut self, attribute: Attribute<'a>) -> Self {
        self.attributes.push(attribute);
        self
    }

    /// Adds a child element to the element and returns a modified `Element`.
    ///
    /// # Arguments
    ///
    /// * `child` - The child element to be added.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::Element;
    /// let child = Element::new("child");
    /// let element = Element::new("root")
    ///     .add_child(child);
    /// ```
    pub fn add_child(mut self, child: Element<'a>) -> Self {
        match self.content {
            Content::None | Content::Text(_) => {
                self.content = Content::Elements(vec![child]);
            }
            Content::Elements(ref mut children) => {
                children.push(child);
            }
        }
        self
    }

    pub fn add_children(mut self, children: Vec<Element<'a>>) -> Self {
        for child in children {
            self = self.add_child(child);
        }
        self
    }

    /// Sets the text content of the element and returns a modified `Element`.
    ///
    /// # Arguments
    ///
    /// * `text` - The text content to be set.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::Element;   
    /// let element = Element::new("root")
    ///    .set_text("This is some text content.");
    ///     
    /// ```
    pub fn set_text(mut self, text: impl Into<Cow<'a, str>>) -> Self {
        self.content = Content::Text(text.into());
        self
    }

    pub fn set_text_owned(mut self, text: String) -> Self {
        self.content = Content::Text(std::borrow::Cow::Owned(text));
        self
    }

    pub fn with_text(&mut self, text: &'a str) -> &mut Self {
        self.content = Content::Text(std::borrow::Cow::Borrowed(text));
        self
    }

    pub fn with_text_owned(&mut self, text: String) -> &mut Self {
        self.content = Content::Text(std::borrow::Cow::Owned(text));
        self
    }

    pub fn to_xml_string(&self) -> Result<String, crate::XmlError> {
        let mut buf = Vec::new();
        self.ns_write(&mut buf, None)?;
        Ok(String::from_utf8(buf).map_err(XmlBuilderError::from)?)
    }
}

#[derive(Debug, Clone)]
pub enum AliasStatus {
    ElementHasNoNamespace,
    NamespaceFoundWithAlias(String),
    NamespaceFoundWithoutAlias,
    NamespaceNotFoundInDeclaration,
    NamespaceDeclarationMapMissing,
}

impl<'a> crate::builder::NamespaceWrite<'a> for Element<'a> {
    fn ns_write<W: std::io::Write>(
        &self,
        w: &mut W,
        parent_decl_map: Option<&AliasMap<'a>>,
    ) -> Result<(), XmlBuilderError> {
        // Merge alias maps (child overrides parent) – same logic as before:
        let decl_map = match (parent_decl_map, &self.namespaces_declaration) {
            (None, None) => None,
            (None, Some(m)) => Some(std::borrow::Cow::Borrowed(m)),
            (Some(p), None) => Some(std::borrow::Cow::Borrowed(p)),
            (Some(p), Some(m)) => {
                let mut merged = std::collections::HashMap::new();
                merged.extend(p.iter().map(|(ns, a)| (ns.clone(), *a)));
                merged.extend(m.iter().map(|(ns, a)| (ns.clone(), *a)));
                Some(std::borrow::Cow::Owned(merged))
            }
        };

        // Resolve the element name with namespace/alias
        let name = match (&self.namespace, &decl_map) {
            (None, _) => self.name.to_string(),
            (Some(ns), None) => {
                return Err(XmlBuilderError::MissingAliasMapForElement {
                    tag: self.name.to_string(),
                    ns: ns.url.to_string(),
                });
            }
            (Some(ns), Some(map)) => match map.get(ns) {
                Some(Some(alias)) => format!("{alias}:{}", self.name),
                Some(None) => {
                    return Err(XmlBuilderError::NamespaceHasNoAlias {
                        tag: self.name.to_string(),
                        ns: ns.url.to_string(),
                    })
                }
                None => {
                    return Err(XmlBuilderError::NamespaceNotDeclared {
                        tag: self.name.to_string(),
                        ns: ns.url.to_string(),
                    })
                }
            },
        };

        // Write start tag + namespace declarations (unchanged behavior)
        w.write_fmt(format_args!("<{name}"))?;
        if let Some(this_ns) = &self.namespaces_declaration {
            for (url, alias) in this_ns {
                if let Some(alias) = alias {
                    w.write_fmt(format_args!(" xmlns:{alias}=\"{url}\""))?;
                } else {
                    w.write_fmt(format_args!(" xmlns=\"{url}\""))?;
                }
            }
        }

        // Attributes
        for a in &self.attributes {
            a.ns_write(w, decl_map.as_deref())?;
        }

        // Content
        match &self.content {
            Content::None => {
                w.write_all(b"/>")?;
            }
            Content::Text(t) => {
                w.write_fmt(format_args!(">{t}</{name}>"))?;
            }
            Content::Elements(children) => {
                w.write_all(b">")?;
                for c in children {
                    c.ns_write(w, decl_map.as_deref())?;
                }
                w.write_fmt(format_args!("</{name}>"))?;
            }
        }
        Ok(())
    }
}

impl crate::builder::NamespaceFmt for Element<'_> {
    /// Formats the element and its content as an XML string.
    fn ns_fmt(
        &self,
        f: &mut std::fmt::Formatter<'_>,
        parent_declaration_map: Option<&HashMap<Namespace<'_>, Option<&str>>>,
    ) -> std::fmt::Result {
        let namespace_declaration_map = match (parent_declaration_map, &self.namespaces_declaration)
        {
            // The case where no declarations are present, and the current element has no namespace declarations.
            (None, None) => None,
            // The case where no declarations are present in parent, this should only happen at the root element.
            (None, Some(my_map)) => Some(Cow::Borrowed(my_map)),
            // The case where parent declarations are present, and the current element has no namespace declarations.
            (Some(parent_map), None) => Some(Cow::Borrowed(parent_map)),
            // The case where both parent and current element have namespace declarations.
            // We merge the two maps, giving priority to the current element's declarations.
            (Some(parent_map), Some(my_map)) => Some({
                let mut merged_namespace = HashMap::new();

                merged_namespace.extend(parent_map.iter().map(|(ns, alias)| (ns.clone(), *alias)));
                merged_namespace.extend(my_map.iter().map(|(ns, alias)| (ns.clone(), *alias)));

                Cow::Owned(merged_namespace)
            }),
        };

        let alias = 'alias: {
            if let Some(namespace) = &self.namespace {
                let Some(ref namespaces_map) = namespace_declaration_map else {
                    break 'alias AliasStatus::NamespaceDeclarationMapMissing;
                };

                match namespaces_map.get(namespace) {
                    Some(Some(alias)) => AliasStatus::NamespaceFoundWithAlias(alias.to_string()),
                    /*
                    For cases where the namespace is found but no alias is provided. right now this is only used for
                       <creationXml
                           xmlns="http://schemas.microsoft.com/powershell/Microsoft.PowerShell">
                       > ....

                    Notice that it declares a namespace without an alias
                    */
                    Some(None) => AliasStatus::NamespaceFoundWithoutAlias,
                    None => AliasStatus::NamespaceNotFoundInDeclaration,
                }
            } else {
                AliasStatus::ElementHasNoNamespace
            }
        };

        let name = match alias {
            AliasStatus::ElementHasNoNamespace => self.name.to_string(),
            AliasStatus::NamespaceFoundWithAlias(alias) => {
                format!("{}:{}", alias, self.name)
            }
            AliasStatus::NamespaceFoundWithoutAlias => {
                error!(
                    target: "xml_namespace",
                    alias_status = ?alias,
                    tag_name = self.name,
                    "element has no alias but namespace is present"
                );
                return Err(std::fmt::Error);
            }
            AliasStatus::NamespaceNotFoundInDeclaration => {
                error!(
                    target: "xml_namespace",
                    alias_status = ?alias,
                    tag_name = self.name,
                    expected_namespace = ?self.namespace,
                    namespace_declaration_map = ?namespace_declaration_map,
                    self_namespaces_declaration = ?self.namespaces_declaration,
                    "namespace not found in declaration map for element"
                );
                return Err(std::fmt::Error);
            }
            AliasStatus::NamespaceDeclarationMapMissing => {
                error!(
                    target: "xml_namespace",
                    alias_status = ?alias,
                    tag_name = self.name,
                    missing_namespace = ?self.namespace,
                    namespace_declaration_map = ?namespace_declaration_map,
                    "namespace alias not found for element"
                );
                return Err(std::fmt::Error);
            }
        };

        write!(f, "<{name}")?;

        if let Some(this_namespaces) = &self.namespaces_declaration {
            for (url, alias) in this_namespaces {
                if let Some(alias) = alias {
                    write!(f, " xmlns:{alias}=\"{url}\"")?;
                } else {
                    write!(f, " xmlns=\"{url}\"")?;
                }
            }
        }

        for attribute in &self.attributes {
            attribute.ns_fmt(f, namespace_declaration_map.as_deref())?;
        }

        match &self.content {
            Content::None => {
                write!(f, "/>")?;
            }
            Content::Text(value) => {
                write!(f, ">{value}</{name}>")?;
            }
            Content::Elements(children) => {
                write!(f, ">")?;
                for child in children {
                    child.ns_fmt(f, namespace_declaration_map.as_deref())?;
                }
                write!(f, "</{name}>")?;
            }
        }
        Ok(())
    }
}


--- File: crates/xml/src/builder/mod.rs ---
//! # xml-builder-rs
//!  A lightweight and intuitive library for generating XML documents in Rust. With an easy-to-use API, it allows you to create well-formed XML structures programmatically. Add elements, attributes, namespaces, and CDATA sections effortlessly.
//! ```
mod attribute;
mod builder;
mod declaration;
mod element;
mod namespace;

use std::collections::HashMap;

pub use self::attribute::*;
pub use self::builder::*;
pub use self::declaration::*;
pub use self::element::*;
pub use self::namespace::*;

pub type AliasMap<'a> = HashMap<Namespace<'a>, Option<&'a str>>;

#[derive(Debug, thiserror::Error)]
pub enum XmlBuilderError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("UTF-8 error: {0}")]
    Utf8Error(#[from] std::string::FromUtf8Error),
    #[error("Missing alias map for element '{tag}' in namespace '{ns}'")]
    MissingAliasMapForElement { tag: String, ns: String },
    #[error("Missing alias map for attribute '{attr}' in namespace '{ns}'")]
    MissingAliasMapForAttribute { attr: String, ns: String },
    #[error("Namespace '{ns}' not declared for tag '{tag}'")]
    NamespaceNotDeclared { tag: String, ns: String },
    #[error("Namespace '{ns}' has no alias for tag '{tag}'")]
    NamespaceHasNoAlias { tag: String, ns: String },
}

pub trait NamespaceWrite<'a> {
    fn ns_write<W: std::io::Write>(
        &self,
        w: &mut W,
        aliases: Option<&AliasMap<'a>>,
    ) -> Result<(), XmlBuilderError>;
}

// Keep the old trait for backward compatibility during transition
pub trait NamespaceFmt {
    fn ns_fmt(
        &self,
        f: &mut std::fmt::Formatter<'_>,
        namespaces_alias_map: Option<&HashMap<Namespace<'_>, Option<&str>>>,
    ) -> std::fmt::Result;
}

#[cfg(test)]
mod tests {
    use super::*;

    macro_rules! compare_xml {
        ($left:expr, $right:expr) => {{
            let normalize = |s: &str| s.replace('\n', "");
            assert_eq!(normalize($left), normalize($right));
        }};
    }

    #[test]
    fn test_simple_xml() {
        let element = Element::new("root");

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(&xml_string, "<root/>");
    }

    #[test]
    fn test_xml_with_attributes() {
        let element = Element::new("root").add_attribute(Attribute::new("attr1", "value1"));

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(&xml_string, r#"<root attr1="value1"/>"#);
    }

    #[test]
    fn test_xml_with_child_elements() {
        let child = Element::new("child");
        let element = Element::new("root").add_child(child);

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        let expected_xml = "<root><child/></root>";
        compare_xml!(&xml_string, expected_xml);
    }

    #[test]
    fn test_xml_with_namespaces() {
        let element = Element::new("root")
            .set_namespace(Namespace::new("http://example.com/ns1"))
            .add_namespace_declaration("http://example.com/ns1", Some("ns1"));

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(
            &xml_string,
            r#"<ns1:root xmlns:ns1="http://example.com/ns1"/>"#
        );
    }

    #[test]
    fn test_full_xml_document() {
        let declaration = Declaration::new("1.0", "UTF-8").with_standalone(true);
        let child = Element::new("child")
            .set_namespace(Namespace::new("http://example.com/ns2"))
            .add_attribute(Attribute::new("attr2", "value2"));
        let element = Element::new("root")
            .set_namespace(Namespace::new("http://example.com/ns1"))
            .add_namespace_declaration("http://example.com/ns1", Some("ns1"))
            .add_namespace_declaration("http://example.com/ns2", Some("ns2"))
            .add_attribute(Attribute::new("attr1", "value1"))
            .add_child(child);

        let builder = Builder::new(Some(declaration), element);
        let xml_string = builder.to_xml_string().unwrap();
        // The declaration includes a space after "?>" and before the root element
        assert!(
            xml_string.starts_with(r#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?> "#)
        );
        assert!(xml_string.contains(r#"<ns1:root"#));
        assert!(xml_string.contains(r#"xmlns:ns1="http://example.com/ns1""#));
        assert!(xml_string.contains(r#"xmlns:ns2="http://example.com/ns2""#));
        assert!(xml_string.contains(r#"attr1="value1""#));
        assert!(xml_string.contains(r#"<ns2:child attr2="value2"/>"#));
        assert!(xml_string.ends_with(r#"</ns1:root>"#));
    }

    #[test]
    fn test_element_with_text() {
        let element = Element::new("message").set_text("Hello, world!");

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        assert_eq!(xml_string, "<message>Hello, world!</message>");
    }

    #[test]
    fn test_element_with_text_and_attributes() {
        let element = Element::new("message")
            .add_attribute(Attribute::new("lang", "en"))
            .set_text("Hello, world!");

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        assert_eq!(xml_string, r#"<message lang="en">Hello, world!</message>"#);
    }

    #[test]
    fn test_adding_child_overwrites_text() {
        let child = Element::new("item");
        let element = Element::new("container")
            .set_text("Initial text")
            .add_child(child);

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        let expected_xml = "<container><item/></container>";
        compare_xml!(&xml_string, expected_xml);
    }

    #[test]
    fn test_setting_text_overwrites_children() {
        let child = Element::new("item");
        let element = Element::new("container")
            .add_child(child)
            .set_text("New text");

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        assert_eq!(xml_string, "<container>New text</container>");
    }

    // Comprehensive Element tests
    #[test]
    fn test_element_with_multiple_attributes() {
        let element = Element::new("root")
            .add_attribute(Attribute::new("attr1", "value1"))
            .add_attribute(Attribute::new("attr2", "value2"))
            .add_attribute(Attribute::new("attr3", "value3"));

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(
            &xml_string,
            r#"<root attr1="value1" attr2="value2" attr3="value3"/>"#
        );
    }

    #[test]
    fn test_element_with_nested_children() {
        let grandchild = Element::new("grandchild").set_text("Deep content");
        let child1 = Element::new("child1").add_child(grandchild);
        let child2 = Element::new("child2").set_text("Child 2 content");
        let element = Element::new("root").add_child(child1).add_child(child2);

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        let expected_xml = "<root><child1><grandchild>Deep content</grandchild></child1><child2>Child 2 content</child2></root>";
        compare_xml!(&xml_string, expected_xml);
    }

    #[test]
    fn test_element_add_children_bulk() {
        let children = vec![
            Element::new("child1"),
            Element::new("child2"),
            Element::new("child3"),
        ];
        let element = Element::new("root").add_children(children);

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        let expected_xml = "<root><child1/><child2/><child3/></root>";
        compare_xml!(&xml_string, expected_xml);
    }

    #[test]
    fn test_element_text_methods() {
        // Test set_text_owned
        let owned_text = String::from("Owned text");
        let element1 = Element::new("test1").set_text_owned(owned_text);

        let builder1 = Builder::new(None, element1);
        let xml_string1 = builder1.to_xml_string().unwrap();
        assert_eq!(xml_string1, "<test1>Owned text</test1>");

        // Test with_text mutable reference method
        let mut element2 = Element::new("test2");
        element2.with_text("Borrowed text");

        let builder2 = Builder::new(None, element2);
        let xml_string2 = builder2.to_xml_string().unwrap();
        assert_eq!(xml_string2, "<test2>Borrowed text</test2>");

        // Test with_text_owned mutable reference method
        let mut element3 = Element::new("test3");
        element3.with_text_owned(String::from("Owned mutable text"));

        let builder3 = Builder::new(None, element3);
        let xml_string3 = builder3.to_xml_string().unwrap();
        assert_eq!(xml_string3, "<test3>Owned mutable text</test3>");
    }

    #[test]
    fn test_element_namespace_optional() {
        let ns = Namespace::new("http://example.com");
        let element_with_ns = Element::new("test")
            .set_namespace_optional(Some(ns))
            .add_namespace_declaration("http://example.com", Some("ex"));

        let builder = Builder::new(None, element_with_ns);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(&xml_string, r#"<ex:test xmlns:ex="http://example.com"/>"#);

        // Test with None namespace
        let element_without_ns = Element::new("test").set_namespace_optional(None::<Namespace>);

        let builder2 = Builder::new(None, element_without_ns);
        let xml_string2 = builder2.to_xml_string().unwrap();
        compare_xml!(&xml_string2, "<test/>");
    }

    #[test]
    fn test_element_multiple_namespace_declarations() {
        let element = Element::new("root")
            .add_namespace_declaration("http://example.com/ns1", Some("ns1"))
            .add_namespace_declaration("http://example.com/ns2", Some("ns2"))
            .add_namespace_declaration("http://example.com/default", None);

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        // Check that all namespace declarations are present (order may vary due to HashMap)
        assert!(xml_string.contains(r#"xmlns:ns1="http://example.com/ns1""#));
        assert!(xml_string.contains(r#"xmlns:ns2="http://example.com/ns2""#));
        assert!(xml_string.contains(r#"xmlns="http://example.com/default""#));
        assert!(xml_string.starts_with("<root "));
        assert!(xml_string.ends_with("/>"));
    }

    // Attribute tests
    #[test]
    fn test_attribute_with_cow_borrowed() {
        let attr = Attribute::new("name", "borrowed_value");
        let element = Element::new("test").add_attribute(attr);

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        assert_eq!(xml_string, r#"<test name="borrowed_value"/>"#);
    }

    #[test]
    fn test_attribute_with_cow_owned() {
        let owned_value = String::from("owned_value");
        let attr = Attribute::new("name", owned_value);
        let element = Element::new("test").add_attribute(attr);

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        assert_eq!(xml_string, r#"<test name="owned_value"/>"#);
    }

    #[test]
    fn test_attribute_with_namespace() {
        let ns = Namespace::new("http://example.com");
        let attr = Attribute::new_with_namespace("attr", "value", Some(ns));
        let element = Element::new("test")
            .add_attribute(attr)
            .add_namespace_declaration("http://example.com", Some("ex"));

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(
            &xml_string,
            r#"<test xmlns:ex="http://example.com" ex:attr="value"/>"#
        );
    }

    #[test]
    fn test_attribute_set_namespace_builder_pattern() {
        let ns = Namespace::new("http://example.com");
        let attr = Attribute::new("attr", "value").set_namespace(ns);
        let element = Element::new("test")
            .add_attribute(attr)
            .add_namespace_declaration("http://example.com", Some("ex"));

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(
            &xml_string,
            r#"<test xmlns:ex="http://example.com" ex:attr="value"/>"#
        );
    }

    // Namespace tests
    #[test]
    fn test_namespace_from_str() {
        let ns: Namespace = "http://example.com".into();
        assert_eq!(ns.url, "http://example.com");
    }

    #[test]
    fn test_namespace_equality() {
        let ns1 = Namespace::new("http://example.com");
        let ns2 = Namespace::new("http://example.com");
        let ns3 = Namespace::new("http://different.com");

        assert_eq!(ns1, ns2);
        assert_ne!(ns1, ns3);
    }

    #[test]
    fn test_namespace_hash() {
        use std::collections::HashMap;

        let mut map = HashMap::new();
        let ns1 = Namespace::new("http://example.com");
        let ns2 = Namespace::new("http://example.com");

        map.insert(ns1, "value1");
        assert_eq!(map.get(&ns2), Some(&"value1"));
    }

    #[test]
    fn test_namespace_display() {
        let ns = Namespace::new("http://example.com");
        assert_eq!(format!("{}", ns), "http://example.com");
    }

    // Declaration tests
    #[test]
    fn test_declaration_basic() {
        let declaration = Declaration::new("1.0", "UTF-8");
        assert_eq!(
            format!("{}", declaration),
            r#"<?xml version="1.0" encoding="UTF-8"?>"#
        );
    }

    #[test]
    fn test_declaration_with_standalone_true() {
        let declaration = Declaration::new("1.0", "UTF-8").with_standalone(true);
        assert_eq!(
            format!("{}", declaration),
            r#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?>"#
        );
    }

    #[test]
    fn test_declaration_with_standalone_false() {
        let declaration = Declaration::new("1.0", "UTF-8").with_standalone(false);
        assert_eq!(
            format!("{}", declaration),
            r#"<?xml version="1.0" encoding="UTF-8" standalone="no"?>"#
        );
    }

    #[test]
    fn test_declaration_different_versions() {
        let declaration1 = Declaration::new("1.1", "ISO-8859-1");
        assert_eq!(
            format!("{}", declaration1),
            r#"<?xml version="1.1" encoding="ISO-8859-1"?>"#
        );
    }

    // Builder tests
    #[test]
    fn test_builder_without_declaration() {
        let element = Element::new("root").set_text("content");
        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        assert_eq!(xml_string, "<root>content</root>");
    }

    #[test]
    fn test_builder_with_declaration() {
        let declaration = Declaration::new("1.0", "UTF-8");
        let element = Element::new("root").set_text("content");
        let builder = Builder::new(Some(declaration), element);
        let xml_string = builder.to_xml_string().unwrap();
        let expected = r#"<?xml version="1.0" encoding="UTF-8"?> 
<root>content</root>"#;
        compare_xml!(&xml_string, expected);
    }

    // Complex namespace scenarios
    #[test]
    fn test_inherited_namespace_declarations() {
        let grandchild =
            Element::new("grandchild").set_namespace(Namespace::new("http://example.com/ns1"));

        let child = Element::new("child")
            .set_namespace(Namespace::new("http://example.com/ns2"))
            .add_child(grandchild);

        let root = Element::new("root")
            .add_namespace_declaration("http://example.com/ns1", Some("ns1"))
            .add_namespace_declaration("http://example.com/ns2", Some("ns2"))
            .add_child(child);

        let builder = Builder::new(None, root);
        let xml_string = builder.to_xml_string().unwrap();
        // Check components due to HashMap ordering
        assert!(xml_string.starts_with("<root"));
        assert!(xml_string.contains(r#"xmlns:ns1="http://example.com/ns1""#));
        assert!(xml_string.contains(r#"xmlns:ns2="http://example.com/ns2""#));
        assert!(xml_string.contains("<ns2:child>"));
        assert!(xml_string.contains("<ns1:grandchild/>"));
        assert!(xml_string.ends_with("</ns2:child></root>"));
    }

    #[test]
    fn test_namespace_override_in_child() {
        let child = Element::new("child")
            .set_namespace(Namespace::new("http://example.com/ns2"))
            .add_namespace_declaration("http://example.com/ns1", Some("override"))
            .add_namespace_declaration("http://example.com/ns2", Some("ns2"));

        let root = Element::new("root")
            .add_namespace_declaration("http://example.com/ns1", Some("ns1"))
            .add_child(child);

        let builder = Builder::new(None, root);
        let xml_string = builder.to_xml_string().unwrap();
        // Check key components due to HashMap ordering
        assert!(xml_string.contains(r#"<root xmlns:ns1="http://example.com/ns1""#));
        assert!(xml_string.contains(r#"<ns2:child"#));
        assert!(xml_string.contains(r#"xmlns:override="http://example.com/ns1""#));
        assert!(xml_string.contains(r#"xmlns:ns2="http://example.com/ns2""#));
        assert!(xml_string.ends_with("/></root>"));
    }

    #[test]
    fn test_default_namespace() {
        let element =
            Element::new("root").add_namespace_declaration("http://example.com/default", None);

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        // Test that default namespaces work when no element namespace is set
        compare_xml!(&xml_string, r#"<root xmlns="http://example.com/default"/>"#);
    }

    // Edge cases and error scenarios
    #[test]
    fn test_empty_element_name() {
        let element = Element::new("");
        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(&xml_string, "</>");
    }

    #[test]
    fn test_empty_attribute_name() {
        let attr = Attribute::new("", "value");
        let element = Element::new("test").add_attribute(attr);
        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(&xml_string, r#"<test ="value"/>"#);
    }

    #[test]
    fn test_empty_attribute_value() {
        let attr = Attribute::new("name", "");
        let element = Element::new("test").add_attribute(attr);
        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(&xml_string, r#"<test name=""/>"#);
    }

    #[test]
    fn test_special_characters_in_text() {
        let element = Element::new("test").set_text("Text with <>&\"' characters");
        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        // Note: This test shows current behavior - proper XML should escape these
        assert_eq!(xml_string, "<test>Text with <>&\"' characters</test>");
    }

    #[test]
    fn test_special_characters_in_attributes() {
        let attr = Attribute::new("name", "value with <>&\"' characters");
        let element = Element::new("test").add_attribute(attr);
        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        // Note: This test shows current behavior - proper XML should escape these
        assert_eq!(xml_string, r#"<test name="value with <>&"' characters"/>"#);
    }

    #[test]
    fn test_unicode_content() {
        let element = Element::new("test").set_text("Hello 世界 🌍");
        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        assert_eq!(xml_string, "<test>Hello 世界 🌍</test>");
    }

    #[test]
    fn test_very_long_content() {
        let long_text = "a".repeat(10000);
        let element = Element::new("test").set_text(long_text.clone());
        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        assert_eq!(xml_string, format!("<test>{}</test>", long_text));
    }

    // Content enum specific tests
    #[test]
    fn test_content_none_display() {
        let element = Element::new("empty");
        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        compare_xml!(&xml_string, "<empty/>");
    }

    #[test]
    fn test_content_transitions() {
        // Start with None, add text
        let mut element = Element::new("test");
        element.with_text("initial text");

        // Then add child (should overwrite text)
        let element = element.add_child(Element::new("child"));

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        let expected = "<test><child/></test>";
        compare_xml!(&xml_string, expected);
    }

    #[test]
    fn test_multiple_children_with_mixed_content() {
        let child1 = Element::new("child1").set_text("Text 1");
        let child2 = Element::new("child2");
        let child3 = Element::new("child3").set_text("Text 3");

        let element = Element::new("root")
            .add_child(child1)
            .add_child(child2)
            .add_child(child3);

        let builder = Builder::new(None, element);
        let xml_string = builder.to_xml_string().unwrap();
        let expected = "<root><child1>Text 1</child1><child2/><child3>Text 3</child3></root>";
        compare_xml!(&xml_string, expected);
    }
}


--- File: crates/xml/src/builder/namespace.rs ---
use core::fmt;
use std::hash::Hash;

/// Represents a namespace in XML.
#[derive(Debug, Clone, Eq)]
pub struct Namespace<'a> {
    pub url: &'a str,
}

impl<'a> From<&'a str> for Namespace<'a> {
    fn from(url: &'a str) -> Self {
        Namespace { url }
    }
}

impl PartialEq for Namespace<'_> {
    fn eq(&self, other: &Self) -> bool {
        self.url == other.url
    }
}

impl fmt::Display for Namespace<'_> {
    /// Formats the namespace as a string in the format `xmlns:prefix="uri"`.
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.url.fmt(f)
    }
}

impl Hash for Namespace<'_> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.url.hash(state);
    }
}

impl<'a> Namespace<'a> {
    /// Creates a new instance of `Namespace` with the given URI.
    ///
    /// # Arguments
    ///
    /// * `uri` - The URI associated with the namespace.
    ///
    /// # Example
    ///
    /// ```
    /// use xml::builder::Namespace;
    /// let namespace = Namespace::new("http://example.com");
    /// ```
    pub fn new(uri: &'a str) -> Self {
        Namespace { url: uri }
    }
}


--- File: crates/xml/src/lib.rs ---
use roxmltree::NodeType;

pub mod builder;
pub mod parser;

#[derive(Debug, thiserror::Error)]
pub enum XmlError {
    #[error("Invalid XML: {0}")]
    ParserError(#[from] crate::parser::Error),

    #[error("XML Builder error: {0}")]
    BuilderError(#[from] crate::builder::XmlBuilderError),

    #[error("Invalid namespace: expected '{expected}', found '{found:?}'")]
    XmlInvalidNamespace {
        expected: String,
        found: Option<String>,
    },

    #[error("Invalid tag: expected '{expected}', found '{found:?}'")]
    XmlInvalidTag { expected: String, found: String },

    #[error("Invalid number of tags for {tag}: found {value}")]
    TagCountInvalid { tag: String, value: usize },

    #[error("Invalid XML: {0}")]
    InvalidXml(String),

    #[error("{0}")]
    GenericError(String),

    #[error("Unexpected tag: {0}")]
    UnexpectedTag(String),

    #[error("Invalid node type: expected '{expected:?}', found {found:?}")]
    InvalidNodeType { expected: NodeType, found: NodeType },

    #[error("This code path is not supposed to be called: {extra_info}")]
    NotSupposeToBeCalled { extra_info: String },
}


--- File: crates/xml/src/parser/mod.rs ---
pub use roxmltree::*;

use crate::XmlError;

impl<'a> TryFrom<crate::parser::Node<'a, 'a>> for crate::builder::Element<'a> {
    type Error = crate::XmlError;

    fn try_from(value: roxmltree::Node<'a, 'a>) -> Result<Self, Self::Error> {
        if !value.is_element() {
            return Err(crate::XmlError::InvalidNodeType {
                expected: NodeType::Element,
                found: value.node_type(),
            });
        }

        let tag_name = value.tag_name();
        let namespace = tag_name.namespace().map(crate::builder::Namespace::new);

        let name = tag_name.name();

        let mut element = crate::builder::Element::new(name);

        element = element.set_namespace_optional(namespace);

        Ok(element)
    }
}

pub fn parse<'a>(xml: &'a str) -> Result<Document<'a>, crate::XmlError> {
    roxmltree::Document::parse(xml).map_err(crate::XmlError::ParserError)
}

/// =========== 1.  The Visitor every type supplies  ===========
pub trait XmlVisitor<'a> {
    /// Rust value produced after the whole subtree was walked.
    type Value;

    /// Visit a specific node - used by Tag types that need to match by name
    /// Default implementation calls visit_children for backward compatibility
    fn visit_children(
        &mut self,
        _node: impl Iterator<Item = crate::parser::Node<'a, 'a>>,
    ) -> Result<(), crate::XmlError> {
        Err(crate::XmlError::NotSupposeToBeCalled {
            extra_info: "Default visit_children called, should be overridden or not called at all"
                .to_string(),
        })
    }

    /// Visit the children of a node - used by TagValue types that process content
    /// Default implementation does nothing
    fn visit_node(&mut self, _node: crate::parser::Node<'a, 'a>) -> Result<(), crate::XmlError> {
        Err(crate::XmlError::NotSupposeToBeCalled {
            extra_info: "Default visit_node called, should be overridden or not called at all"
                .to_string(),
        })
    }

    fn visit_attribute(
        &mut self,
        _attribute: crate::parser::Attribute<'a, 'a>,
    ) -> Result<(), crate::XmlError> {
        Err(crate::XmlError::NotSupposeToBeCalled {
            extra_info: "Default visit_attribute called, should be overridden or not called at all"
                .to_string(),
        })
    }

    /// Return the finished value after traversal.
    fn finish(self) -> Result<Self::Value, XmlError>;
}

/// =========== 2.  Blanket “Deserializer” driver  =============
pub struct NodeDeserializer<'a> {
    root: roxmltree::Node<'a, 'a>,
}

impl<'a> NodeDeserializer<'a> {
    pub fn new(root: roxmltree::Node<'a, 'a>) -> Self {
        Self { root }
    }

    /// Drive any visitor over the subtree rooted at `self.root`
    pub fn deserialize<V>(self, mut visitor: V) -> Result<V::Value, XmlError>
    where
        V: XmlVisitor<'a>,
    {
        visitor.visit_node(self.root)?;
        visitor.finish()
    }
}

/// =========== 3.  Per-type convenience trait  ================
pub trait XmlDeserialize<'a>: Sized {
    /// “Associated visitor” type that knows how to build Self
    type Visitor: XmlVisitor<'a, Value = Self>;

    /// Create the visitor that will build Self.
    fn visitor() -> Self::Visitor;

    /// One-liner users will call.
    fn from_node(node: roxmltree::Node<'a, 'a>) -> Result<Self, XmlError> {
        NodeDeserializer::new(node).deserialize(Self::visitor())
    }

    fn from_children(
        children: impl Iterator<Item = crate::parser::Node<'a, 'a>>,
    ) -> Result<Self, XmlError> {
        let mut visitor = Self::visitor();
        visitor.visit_children(children)?;
        visitor.finish()
    }

    fn from_attribute(attribute: crate::parser::Attribute<'a, 'a>) -> Result<Self, XmlError> {
        let mut visitor = Self::visitor();
        visitor.visit_attribute(attribute)?;
        visitor.finish()
    }
}


--- File: powershell_design.md ---
# PowerShell Layer Design for IronWinRM

## Design Discussion Summary

Our goal is to design the PowerShell execution layer for `ironwinrm`.

### Initial Proposal
I initially suggested a design where a `PowerShell` struct would hold a direct reference (`&'a RunspacePool`) to the `RunspacePool` it belonged to. This would have allowed for a fluent API like `PowerShell::new(&pool).add_script("...").invoke().await`.

### The Agreed-Upon Design
You correctly identified that my initial proposal was flawed. It would introduce complex lifetime management and tight coupling, which is not idiomatic or robust in Rust. You proposed a superior, decoupled design with the following key principles:

- **`PowerShell` as a Handle**: The public `PowerShell` struct should be a simple, lightweight, and copyable "handle" that contains only a `UUID` to uniquely identify a pipeline. It should not contain any complex state or references.
- **`RunspacePool` as the Central State Manager**: The `RunspacePool` must be the single source of truth. It will own and manage the complete state of all pipelines. This is achieved by maintaining an internal `HashMap`, where the key is the pipeline's `UUID` and the value is a struct (`Pipeline`) that holds all the data for that pipeline (its commands, invocation state, etc.).
- **Service-Oriented API**: All operations on a pipeline (creating it, adding commands, invoking it) will be methods on the `RunspacePool`. These methods will accept the `PowerShell` handle as an argument to identify which pipeline to operate on. This makes the `RunspacePool` a "service" that manages pipeline resources.

This refined design is more robust, avoids lifetime issues, and aligns perfectly with Rust's ownership principles.

## Detailed Implementation Skeleton

### 1. The `PowerShell` Handle
This is the simple, public-facing handle.

```rust
use uuid::Uuid;

/// A handle to a PowerShell pipeline managed by a `RunspacePool`.
///
/// This struct is a lightweight, copyable identifier for a specific pipeline.
/// All operations on the pipeline are performed via methods on the `RunspacePool`
/// that take this handle as an argument.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct PowerShell {
    pub(crate) id: Uuid,
}

impl PowerShell {
    /// Creates a new, unique PowerShell handle.
    ///
    /// This function is internal because handles should only be created by
    /// the `RunspacePool` to ensure they are tracked correctly.
    pub(crate) fn new() -> Self {
        Self { id: Uuid::new_v4() }
    }

    /// Returns the unique identifier for this PowerShell handle.
    pub fn id(&self) -> Uuid {
        self.id
    }
}
```

### 2. The Internal `Pipeline` State
This struct holds the actual data for a pipeline and is kept private within the `RunspacePool`.

```rust
use protocol_powershell_remoting::messages::create_pipeline::PowerShellPipeline as PsPipeline;
use protocol_powershell_remoting::messages::create_pipeline::Command;
use protocol_powershell_remoting::objects::PsValue;

/// Represents the possible states of a PowerShell pipeline invocation.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PipelineState {
    NotStarted,
    Running,
    Stopping,
    Stopped,
    Completed,
    Failed,
}

/// Internal representation of a PowerShell pipeline's state and configuration.
/// This is owned and managed by the `RunspacePool`.
#[derive(Debug, Clone)]
pub(crate) struct Pipeline {
    pub(crate) state: PipelineState,
    pub(crate) ps_pipeline: PsPipeline,
    pub(crate) output: Vec<PsValue>,
    pub(crate) errors: Vec<PsValue>,
}

impl Pipeline {
    pub(crate) fn new() -> Self {
        Self {
            state: PipelineState::NotStarted,
            ps_pipeline: PsPipeline::default(),
            output: Vec::new(),
            errors: Vec::new(),
        }
    }

    pub(crate) fn add_script(&mut self, script: String) {
        let command = Command::from_script(script);
        self.ps_pipeline.cmds.add_command(command);
    }

    pub(crate) fn add_command(&mut self, command: String) {
        let command = Command::from_command(command);
        self.ps_pipeline.cmds.add_command(command);
    }

    pub(crate) fn add_parameter(&mut self, name: &str, value: PsValue) {
        if let Some(last_cmd) = self.ps_pipeline.cmds.commands.last_mut() {
            last_cmd.add_parameter(name, value);
        } else {
            // In a real implementation, we might return an error here.
            // For the skeleton, we can log or panic.
            log::warn!("Attempted to add a parameter with no prior command.");
        }
    }
}
```

### 3. `RunspacePool` Modifications
The `RunspacePool` becomes the central orchestrator, managing the pipelines via its new `HashMap`.

```rust
// ...existing code...
use std::collections::HashMap;
use uuid::Uuid;
use crate::pipeline::{Pipeline, PipelineState};
use crate::powershell::PowerShell;
use crate::PwshCoreError;
use protocol_powershell_remoting::objects::PsValue;

pub struct RunspacePool {
    // ... existing fields: id, state, shell, fragmenter, etc.
    
    /// Manages the state of all pipelines associated with this pool.
    pipelines: HashMap<Uuid, Pipeline>,
}

impl RunspacePool {
    // ... existing methods: connect, close, etc. ...

    // --- PowerShell Pipeline Management API ---

    /// Creates a new PowerShell pipeline and returns a handle to it.
    ///
    /// The pipeline's state is managed internally by the `RunspacePool`.
    pub fn create_pipeline(&mut self) -> PowerShell {
        let handle = PowerShell::new();
        self.pipelines.insert(handle.id(), Pipeline::new());
        handle
    }

    /// Adds a script to the specified pipeline.
    ///
    /// # Arguments
    /// * `handle`: The handle to the pipeline to modify.
    /// * `script`: The script string to add.
    pub fn add_script(&mut self, handle: PowerShell, script: impl Into<String>) -> Result<(), PwshCoreError> {
        let pipeline = self.pipelines.get_mut(&handle.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;
        
        if pipeline.state != PipelineState::NotStarted {
            return Err(PwshCoreError::InvalidState("Cannot add to a pipeline that has already been started"));
        }

        pipeline.add_script(script.into());
        Ok(())
    }

    /// Adds a command (cmdlet) to the specified pipeline.
    pub fn add_command(&mut self, handle: PowerShell, command: impl Into<String>) -> Result<(), PwshCoreError> {
        let pipeline = self.pipelines.get_mut(&handle.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;
        
        if pipeline.state != PipelineState::NotStarted {
            return Err(PwshCoreError::InvalidState("Cannot add to a pipeline that has already been started"));
        }

        pipeline.add_command(command.into());
        Ok(())
    }

    /// Adds a parameter to the last command in the specified pipeline.
    pub fn add_parameter(&mut self, handle: PowerShell, name: &str, value: impl Into<PsValue>) -> Result<(), PwshCoreError> {
        let pipeline = self.pipelines.get_mut(&handle.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;
        
        if pipeline.state != PipelineState::NotStarted {
            return Err(PwshCoreError::InvalidState("Cannot add to a pipeline that has already been started"));
        }

        pipeline.add_parameter(name, value.into());
        Ok(())
    }

    /// Invokes the specified pipeline and waits for its completion.
    ///
    /// This method will handle the entire PSRP message exchange:
    /// 1. Send the `CreatePipeline` message.
    /// 2. Send `Command`, `Send`, and `EndOfInput` messages.
    /// 3. Enter a loop to `Receive` and process responses.
    /// 4. Defragment and deserialize messages, updating the pipeline's state, output, and error streams.
    /// 5. Return the final output upon completion.
    pub async fn invoke_pipeline(&mut self, handle: PowerShell) -> Result<&[PsValue], PwshCoreError> {
        let pipeline = self.pipelines.get_mut(&handle.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;

        // --- SKELETON LOGIC ---
        // 1. Set pipeline state to Running.
        pipeline.state = PipelineState::Running;
        log::info!("Invoking pipeline {}", handle.id());

        // 2. Build the `CreatePipeline` message from `pipeline.ps_pipeline`.
        // let create_msg = ...;

        // 3. Use `self.shell` to send the command and enter the receive loop.
        // let command_id = self.shell.command(...).await?;
        // while pipeline.state == PipelineState::Running {
        //     let responses = self.shell.receive(command_id).await?;
        //     // Process responses, update pipeline.state, pipeline.output, etc.
        // }
        
        // For the skeleton, we'll just simulate a result.
        pipeline.output.push(PsValue::String("Simulated Execution Result".to_string()));
        pipeline.state = PipelineState::Completed;
        log::info!("Invocation complete for pipeline {}", handle.id());
        // --- END SKELETON LOGIC ---

        // Return a reference to the results stored within the pipeline state.
        Ok(&self.pipelines.get(&handle.id()).unwrap().output)
    }
}
```

### 4. Example Usage
This is how a consumer of your `pwsh-core` crate would use the new API.

```rust
// Example of final usage
async fn main() -> anyhow::Result<()> {
    // Assume `pool` is an initialized `RunspacePool`
    let mut pool = RunspacePool::connect(...).await?;

    // 1. Create a pipeline and get its handle.
    let ps_handle = pool.create_pipeline();

    // 2. Build the command using the handle.
    pool.add_script(ps_handle, "Get-Process")?;
    pool.add_command(ps_handle, "Sort-Object")?;
    pool.add_parameter(ps_handle, "Property", "CPU")?;

    // 3. Invoke the pipeline.
    let results = pool.invoke_pipeline(ps_handle).await?;

    println!("Pipeline finished with {} results:", results.len());
    for res in results {
        println!("> {:?}", res);
    }

    pool.close().await?;
    Ok(())
}
```

## Key Benefits of This Design

1. **Separation of Concerns**: The `PowerShell` handle is just an identifier, while the `RunspacePool` manages all state and operations.

2. **No Lifetime Issues**: Since `PowerShell` doesn't hold references, there are no complex lifetime constraints.

3. **Resource Management**: The `RunspacePool` can properly manage pipeline resources, including cleanup when pipelines complete.

4. **Thread Safety**: This design naturally supports future thread-safety enhancements, as the `RunspacePool` can control access to pipeline state.

5. **Consistency**: All pipeline operations go through the same interface, making behavior predictable and debuggable.

## Implementation Notes

- The `Pipeline` struct should be expanded to include error streams, debug streams, and other PowerShell output streams.
- The `invoke_pipeline` method needs to implement the full PSRP protocol exchange.
- Error handling should be robust, with proper cleanup of pipeline state on failure.
- Consider adding pipeline cleanup methods to remove completed pipelines from the HashMap.


--- File: resources/create/creation_xml_failed.txt ---
AAAAAAAAAAEAAAAAAAAAAAMAAADHAgAAAAIAAQAqkuNn04tL0KY/KsV/nhsAAAAAAAAAAAAAAAAAAAAAADxPYmogUmVmSWQ9IjAiPjxNUz48VmVyc2lvbiBOPSJQU1ZlcnNpb24iPjIuMDwvVmVyc2lvbj48VmVyc2lvbiBOPSJTZXJpYWxpemF0aW9uVmVyc2lvbiI+MS4xLjAuMTwvVmVyc2lvbj48VmVyc2lvbiBOPSJwcm90b2NvbHZlcnNpb24iPjIuMzwvVmVyc2lvbj48L01TPjwvT2JqPgAAAAAAAAACAAAAAAAAAAADAAACQwIAAAAEAAEAKpLjZ9OLS9CmPyrFf54bAAAAAAAAAAAAAAAAAAAAAAA8T2JqIFJlZklkPSIwIj48TVM+PE9iaiBSZWZJZD0iMSIgTj0iQXBhcnRtZW50U3RhdGUiPjxUTiBSZWZJZD0iMCI+PFQ+U3lzdGVtLlRocmVhZGluZy5BcGFydG1lbnRTdGF0ZTwvVD48VD5TeXN0ZW0uRW51bTwvVD48VD5TeXN0ZW0uVmFsdWVUeXBlPC9UPjxUPlN5c3RlbS5PYmplY3Q8L1Q+PC9UTj48VG9TdHJpbmc+VW5rbm93bjwvVG9TdHJpbmc+PEkzMj4yPC9JMzI+PC9PYmo+PE5pbCBOPSJBcHBsaWNhdGlvbkFyZ3VtZW50cyIvPjxJMzIgTj0iTWF4UnVuc3BhY2VzIj4xPC9JMzI+PEkzMiBOPSJNaW5SdW5zcGFjZXMiPjE8L0kzMj48T2JqIFJlZklkPSIyIiBOPSJQU1RocmVhZE9wdGlvbnMiPjxUTiBSZWZJZD0iMSI+PFQ+U3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5SdW5zcGFjZXMuUFNUaHJlYWRPcHRpb25zPC9UPjxUPlN5c3RlbS5FbnVtPC9UPjxUPlN5c3RlbS5WYWx1ZVR5cGU8L1Q+PFQ+U3lzdGVtLk9iamVjdDwvVD48L1ROPjxUb1N0cmluZz5EZWZhdWx0PC9Ub1N0cmluZz48STMyPjA8L0kzMj48L09iaj48L01TPjwvT2JqPg==

--- File: resources/create/creation_xml_failed_analyzed.txt ---
📁 Reading from file: C:\dev\ironwinrm\resources\create\creation_xml_failed.txt
✅ Successfully read 1096 characters from file

================================================================================
                     POWERSHELL REMOTING PROTOCOL ANALYZER                      
================================================================================

------------------------------------------------------------
1. Base64 Decoding
------------------------------------------------------------
✅ Successfully decoded 820 bytes from base64 input

------------------------------------------------------------
2. PowerShell Remoting Message Parsing
------------------------------------------------------------
🎉 Successfully parsed 2 complete PowerShell remoting message(s)

------------------------------------------------------------
3. Message Summary
------------------------------------------------------------
📨 Message 1 Details:
   📋 Type: SessionCapability
   🎯 Destination: Server
   🆔 Runspace Pool ID: 2a92e367-d38b-4bd0-a63f-2ac57f9e1b00
   🔗 Pipeline ID: 00000000-0000-0000-0000-000000000000
   📏 Data Size: 159 bytes

📨 Message 2 Details:
   📋 Type: InitRunspacepool
   🎯 Destination: Server
   🆔 Runspace Pool ID: 2a92e367-d38b-4bd0-a63f-2ac57f9e1b00
   🔗 Pipeline ID: 00000000-0000-0000-0000-000000000000
   📏 Data Size: 539 bytes


================================================================================
                              ANALYZING MESSAGE 1                               
================================================================================

------------------------------------------------------------
4. Data Extraction & UTF-8 Decoding
------------------------------------------------------------
✅ Successfully decoded UTF-8 string (159 characters)
📄 Complete XML Data:
<Obj RefId="0"><MS><Version N="PSVersion">2.0</Version><Version N="SerializationVersion">1.1.0.1</Version><Version N="protocolversion">2.3</Version></MS></Obj>

------------------------------------------------------------
5. XML Structure Analysis
------------------------------------------------------------
✅ Successfully parsed XML structure
🏷️  Root XML element: <Obj>

------------------------------------------------------------
6. PowerShell Object Conversion
------------------------------------------------------------
✅ Successfully converted to PowerShell object representation

------------------------------------------------------------
7. PowerShell Object Details
------------------------------------------------------------
ComplexObject {
    type_def: None,
    to_string: None,
    content: Standard,
    adapted_properties: {},
    extended_properties: {
        "PSVersion": PsProperty {
            name: "PSVersion",
            value: Primitive(
                Version(
                    "2.0",
                ),
            ),
        },
        "SerializationVersion": PsProperty {
            name: "SerializationVersion",
            value: Primitive(
                Version(
                    "1.1.0.1",
                ),
            ),
        },
        "protocolversion": PsProperty {
            name: "protocolversion",
            value: Primitive(
                Version(
                    "2.3",
                ),
            ),
        },
    },
}

================================================================================
                              ANALYZING MESSAGE 2                               
================================================================================

------------------------------------------------------------
4. Data Extraction & UTF-8 Decoding
------------------------------------------------------------
✅ Successfully decoded UTF-8 string (539 characters)
📄 Complete XML Data:
<Obj RefId="0"><MS><Obj RefId="1" N="ApartmentState"><TN RefId="0"><T>System.Threading.ApartmentState</T><T>System.Enum</T><T>System.ValueType</T><T>System.Object</T></TN><ToString>Unknown</ToString><I32>2</I32></Obj><Nil N="ApplicationArguments"/><I32 N="MaxRunspaces">1</I32><I32 N="MinRunspaces">1</I32><Obj RefId="2" N="PSThreadOptions"><TN RefId="1"><T>System.Management.Automation.Runspaces.PSThreadOptions</T><T>System.Enum</T><T>System.ValueType</T><T>System.Object</T></TN><ToString>Default</ToString><I32>0</I32></Obj></MS></Obj>

------------------------------------------------------------
5. XML Structure Analysis
------------------------------------------------------------
✅ Successfully parsed XML structure
🏷️  Root XML element: <Obj>

------------------------------------------------------------
6. PowerShell Object Conversion
------------------------------------------------------------
✅ Successfully converted to PowerShell object representation

------------------------------------------------------------
7. PowerShell Object Details
------------------------------------------------------------
ComplexObject {
    type_def: None,
    to_string: None,
    content: Standard,
    adapted_properties: {},
    extended_properties: {
        "ApartmentState": PsProperty {
            name: "ApartmentState",
            value: Object(
                ComplexObject {
                    type_def: Some(
                        PsType {
                            type_names: [
                                "System.Threading.ApartmentState",
                                "System.Enum",
                                "System.ValueType",
                                "System.Object",
                            ],
                        },
                    ),
                    to_string: Some(
                        "Unknown",
                    ),
                    content: PsEnums(
                        PsEnums {
                            value: 2,
                        },
                    ),
                    adapted_properties: {},
                    extended_properties: {},
                },
            ),
        },
        "ApplicationArguments": PsProperty {
            name: "ApplicationArguments",
            value: Primitive(
                Nil,
            ),
        },
        "MaxRunspaces": PsProperty {
            name: "MaxRunspaces",
            value: Primitive(
                I32(
                    1,
                ),
            ),
        },
        "MinRunspaces": PsProperty {
            name: "MinRunspaces",
            value: Primitive(
                I32(
                    1,
                ),
            ),
        },
        "PSThreadOptions": PsProperty {
            name: "PSThreadOptions",
            value: Object(
                ComplexObject {
                    type_def: Some(
                        PsType {
                            type_names: [
                                "System.Management.Automation.Runspaces.PSThreadOptions",
                                "System.Enum",
                                "System.ValueType",
                                "System.Object",
                            ],
                        },
                    ),
                    to_string: Some(
                        "Default",
                    ),
                    content: PsEnums(
                        PsEnums {
                            value: 0,
                        },
                    ),
                    adapted_properties: {},
                    extended_properties: {},
                },
            ),
        },
    },
}

================================================================================
                               ANALYSIS COMPLETE                                
================================================================================
🎉 Successfully analyzed all PowerShell remoting messages!


--- File: resources/create/creation_xml_success.txt ---
AAAAAAAAAAEAAAAAAAAAAAMAAADKAgAAAAIAAQDQNGUtEmvjQLdzy6JkWc+oAAAAAAAAAAAAAAAAAAAAAO+7vzxPYmogUmVmSWQ9IjAiPjxNUz48VmVyc2lvbiBOPSJwcm90b2NvbHZlcnNpb24iPjIuMzwvVmVyc2lvbj48VmVyc2lvbiBOPSJQU1ZlcnNpb24iPjIuMDwvVmVyc2lvbj48VmVyc2lvbiBOPSJTZXJpYWxpemF0aW9uVmVyc2lvbiI+MS4xLjAuMTwvVmVyc2lvbj48L01TPjwvT2JqPgAAAAAAAAACAAAAAAAAAAADAAAO7QIAAAAEAAEA0DRlLRJr40C3c8uiZFnPqAAAAAAAAAAAAAAAAAAAAADvu788T2JqIFJlZklkPSIwIj48TVM+PEkzMiBOPSJNaW5SdW5zcGFjZXMiPjE8L0kzMj48STMyIE49Ik1heFJ1bnNwYWNlcyI+MTwvSTMyPjxPYmogTj0iUFNUaHJlYWRPcHRpb25zIiBSZWZJZD0iMSI+PFROIFJlZklkPSIwIj48VD5TeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLlJ1bnNwYWNlcy5QU1RocmVhZE9wdGlvbnM8L1Q+PFQ+U3lzdGVtLkVudW08L1Q+PFQ+U3lzdGVtLlZhbHVlVHlwZTwvVD48VD5TeXN0ZW0uT2JqZWN0PC9UPjwvVE4+PFRvU3RyaW5nPkRlZmF1bHQ8L1RvU3RyaW5nPjxJMzI+MDwvSTMyPjwvT2JqPjxPYmogTj0iQXBhcnRtZW50U3RhdGUiIFJlZklkPSIyIj48VE4gUmVmSWQ9IjEiPjxUPlN5c3RlbS5UaHJlYWRpbmcuQXBhcnRtZW50U3RhdGU8L1Q+PFQ+U3lzdGVtLkVudW08L1Q+PFQ+U3lzdGVtLlZhbHVlVHlwZTwvVD48VD5TeXN0ZW0uT2JqZWN0PC9UPjwvVE4+PFRvU3RyaW5nPlVua25vd248L1RvU3RyaW5nPjxJMzI+MjwvSTMyPjwvT2JqPjxPYmogTj0iQXBwbGljYXRpb25Bcmd1bWVudHMiIFJlZklkPSIzIj48VE4gUmVmSWQ9IjIiPjxUPlN5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uUFNQcmltaXRpdmVEaWN0aW9uYXJ5PC9UPjxUPlN5c3RlbS5Db2xsZWN0aW9ucy5IYXNodGFibGU8L1Q+PFQ+U3lzdGVtLk9iamVjdDwvVD48L1ROPjxEQ1Q+PEVuPjxTIE49IktleSI+UFNWZXJzaW9uVGFibGU8L1M+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjQiPjxUTlJlZiBSZWZJZD0iMiIgLz48RENUPjxFbj48UyBOPSJLZXkiPlBsYXRmb3JtPC9TPjxTIE49IlZhbHVlIj5XaW4zMk5UPC9TPjwvRW4+PEVuPjxTIE49IktleSI+U2VyaWFsaXphdGlvblZlcnNpb248L1M+PFZlcnNpb24gTj0iVmFsdWUiPjEuMS4wLjE8L1ZlcnNpb24+PC9Fbj48RW4+PFMgTj0iS2V5Ij5QU1ZlcnNpb248L1M+PFZlcnNpb24gTj0iVmFsdWUiPjcuNC4xMDwvVmVyc2lvbj48L0VuPjxFbj48UyBOPSJLZXkiPlBTQ29tcGF0aWJsZVZlcnNpb25zPC9TPjxPYmogTj0iVmFsdWUiIFJlZklkPSI1Ij48VE4gUmVmSWQ9IjMiPjxUPlN5c3RlbS5WZXJzaW9uW108L1Q+PFQ+U3lzdGVtLkFycmF5PC9UPjxUPlN5c3RlbS5PYmplY3Q8L1Q+PC9UTj48TFNUPjxWZXJzaW9uPjEuMDwvVmVyc2lvbj48VmVyc2lvbj4yLjA8L1ZlcnNpb24+PFZlcnNpb24+My4wPC9WZXJzaW9uPjxWZXJzaW9uPjQuMDwvVmVyc2lvbj48VmVyc2lvbj41LjA8L1ZlcnNpb24+PFZlcnNpb24+NS4xPC9WZXJzaW9uPjxWZXJzaW9uPjYuMDwvVmVyc2lvbj48VmVyc2lvbj43LjA8L1ZlcnNpb24+PC9MU1Q+PC9PYmo+PC9Fbj48RW4+PFMgTj0iS2V5Ij5XU01hblN0YWNrVmVyc2lvbjwvUz48VmVyc2lvbiBOPSJWYWx1ZSI+My4wPC9WZXJzaW9uPjwvRW4+PEVuPjxTIE49IktleSI+UFNTZW1hbnRpY1ZlcnNpb248L1M+PFMgTj0iVmFsdWUiPjcuNC4xMDwvUz48L0VuPjxFbj48UyBOPSJLZXkiPlBTUmVtb3RpbmdQcm90b2NvbFZlcnNpb248L1M+PFZlcnNpb24gTj0iVmFsdWUiPjIuMzwvVmVyc2lvbj48L0VuPjxFbj48UyBOPSJLZXkiPkdpdENvbW1pdElkPC9TPjxTIE49IlZhbHVlIj43LjQuMTA8L1M+PC9Fbj48RW4+PFMgTj0iS2V5Ij5QU0VkaXRpb248L1M+PFMgTj0iVmFsdWUiPkNvcmU8L1M+PC9Fbj48RW4+PFMgTj0iS2V5Ij5PUzwvUz48UyBOPSJWYWx1ZSI+TWljcm9zb2Z0IFdpbmRvd3MgMTAuMC4yMjYzMTwvUz48L0VuPjwvRENUPjwvT2JqPjwvRW4+PC9EQ1Q+PC9PYmo+PE9iaiBOPSJIb3N0SW5mbyIgUmVmSWQ9IjYiPjxNUz48QiBOPSJfaXNIb3N0VUlOdWxsIj5mYWxzZTwvQj48QiBOPSJfaXNIb3N0UmF3VUlOdWxsIj5mYWxzZTwvQj48QiBOPSJfaXNIb3N0TnVsbCI+ZmFsc2U8L0I+PE9iaiBOPSJfaG9zdERlZmF1bHREYXRhIiBSZWZJZD0iNyI+PE1TPjxPYmogTj0iZGF0YSIgUmVmSWQ9IjgiPjxUTiBSZWZJZD0iNCI+PFQ+U3lzdGVtLkNvbGxlY3Rpb25zLkhhc2h0YWJsZTwvVD48VD5TeXN0ZW0uT2JqZWN0PC9UPjwvVE4+PERDVD48RW4+PEkzMiBOPSJLZXkiPjk8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iOSI+PE1TPjxTIE49IlQiPlN5c3RlbS5TdHJpbmc8L1M+PFMgTj0iViI+UG93ZXJTaGVsbDwvUz48L01TPjwvT2JqPjwvRW4+PEVuPjxJMzIgTj0iS2V5Ij44PC9JMzI+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjEwIj48TVM+PFMgTj0iVCI+U3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5Ib3N0LlNpemU8L1M+PE9iaiBOPSJWIiBSZWZJZD0iMTEiPjxNUz48STMyIE49IndpZHRoIj4zODI0PC9JMzI+PEkzMiBOPSJoZWlnaHQiPjIxMjE8L0kzMj48L01TPjwvT2JqPjwvTVM+PC9PYmo+PC9Fbj48RW4+PEkzMiBOPSJLZXkiPjc8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iMTIiPjxNUz48UyBOPSJUIj5TeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLkhvc3QuU2l6ZTwvUz48T2JqIE49IlYiIFJlZklkPSIxMyI+PE1TPjxJMzIgTj0id2lkdGgiPjEyMDwvSTMyPjxJMzIgTj0iaGVpZ2h0Ij4zMDwvSTMyPjwvTVM+PC9PYmo+PC9NUz48L09iaj48L0VuPjxFbj48STMyIE49IktleSI+NjwvSTMyPjxPYmogTj0iVmFsdWUiIFJlZklkPSIxNCI+PE1TPjxTIE49IlQiPlN5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uSG9zdC5TaXplPC9TPjxPYmogTj0iViIgUmVmSWQ9IjE1Ij48TVM+PEkzMiBOPSJ3aWR0aCI+MTIwPC9JMzI+PEkzMiBOPSJoZWlnaHQiPjMwPC9JMzI+PC9NUz48L09iaj48L01TPjwvT2JqPjwvRW4+PEVuPjxJMzIgTj0iS2V5Ij41PC9JMzI+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjE2Ij48TVM+PFMgTj0iVCI+U3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5Ib3N0LlNpemU8L1M+PE9iaiBOPSJWIiBSZWZJZD0iMTciPjxNUz48STMyIE49IndpZHRoIj4xMjA8L0kzMj48STMyIE49ImhlaWdodCI+MzA8L0kzMj48L01TPjwvT2JqPjwvTVM+PC9PYmo+PC9Fbj48RW4+PEkzMiBOPSJLZXkiPjQ8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iMTgiPjxNUz48UyBOPSJUIj5TeXN0ZW0uSW50MzI8L1M+PEkzMiBOPSJWIj4yNTwvSTMyPjwvTVM+PC9PYmo+PC9Fbj48RW4+PEkzMiBOPSJLZXkiPjM8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iMTkiPjxNUz48UyBOPSJUIj5TeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLkhvc3QuQ29vcmRpbmF0ZXM8L1M+PE9iaiBOPSJWIiBSZWZJZD0iMjAiPjxNUz48STMyIE49IngiPjA8L0kzMj48STMyIE49InkiPjA8L0kzMj48L01TPjwvT2JqPjwvTVM+PC9PYmo+PC9Fbj48RW4+PEkzMiBOPSJLZXkiPjI8L0kzMj48T2JqIE49IlZhbHVlIiBSZWZJZD0iMjEiPjxNUz48UyBOPSJUIj5TeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLkhvc3QuQ29vcmRpbmF0ZXM8L1M+PE9iaiBOPSJWIiBSZWZJZD0iMjIiPjxNUz48STMyIE49IngiPjA8L0kzMj48STMyIE49InkiPjI3PC9JMzI+PC9NUz48L09iaj48L01TPjwvT2JqPjwvRW4+PEVuPjxJMzIgTj0iS2V5Ij4xPC9JMzI+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjIzIj48TVM+PFMgTj0iVCI+U3lzdGVtLkNvbnNvbGVDb2xvcjwvUz48STMyIE49IlYiPjA8L0kzMj48L01TPjwvT2JqPjwvRW4+PEVuPjxJMzIgTj0iS2V5Ij4wPC9JMzI+PE9iaiBOPSJWYWx1ZSIgUmVmSWQ9IjI0Ij48TVM+PFMgTj0iVCI+U3lzdGVtLkNvbnNvbGVDb2xvcjwvUz48STMyIE49IlYiPjc8L0kzMj48L01TPjwvT2JqPjwvRW4+PC9EQ1Q+PC9PYmo+PC9NUz48L09iaj48QiBOPSJfdXNlUnVuc3BhY2VIb3N0Ij5mYWxzZTwvQj48L01TPjwvT2JqPjwvTVM+PC9PYmo+

--- File: resources/create/creation_xml_success_analyzed.txt ---
📁 Reading from file: C:\dev\ironwinrm\resources\create\creation_xml_success.txt
✅ Successfully read 5420 characters from file

================================================================================
                     POWERSHELL REMOTING PROTOCOL ANALYZER                      
================================================================================

------------------------------------------------------------
1. Base64 Decoding
------------------------------------------------------------
✅ Successfully decoded 4065 bytes from base64 input

------------------------------------------------------------
2. PowerShell Remoting Message Parsing
------------------------------------------------------------
🎉 Successfully parsed 2 complete PowerShell remoting message(s)

------------------------------------------------------------
3. Message Summary
------------------------------------------------------------
📨 Message 1 Details:
   📋 Type: SessionCapability
   🎯 Destination: Server
   🆔 Runspace Pool ID: d034652d-126b-e340-b773-cba26459cfa8
   🔗 Pipeline ID: 00000000-0000-0000-0000-000000000000
   📏 Data Size: 162 bytes

📨 Message 2 Details:
   📋 Type: InitRunspacepool
   🎯 Destination: Server
   🆔 Runspace Pool ID: d034652d-126b-e340-b773-cba26459cfa8
   🔗 Pipeline ID: 00000000-0000-0000-0000-000000000000
   📏 Data Size: 3781 bytes


================================================================================
                              ANALYZING MESSAGE 1                               
================================================================================

------------------------------------------------------------
4. Data Extraction & UTF-8 Decoding
------------------------------------------------------------
✅ Successfully decoded UTF-8 string (162 characters)
📄 Complete XML Data:
﻿<Obj RefId="0"><MS><Version N="protocolversion">2.3</Version><Version N="PSVersion">2.0</Version><Version N="SerializationVersion">1.1.0.1</Version></MS></Obj>

------------------------------------------------------------
5. XML Structure Analysis
------------------------------------------------------------
✅ Successfully parsed XML structure
🏷️  Root XML element: <Obj>

------------------------------------------------------------
6. PowerShell Object Conversion
------------------------------------------------------------
✅ Successfully converted to PowerShell object representation

------------------------------------------------------------
7. PowerShell Object Details
------------------------------------------------------------
ComplexObject {
    type_def: None,
    to_string: None,
    content: Standard,
    adapted_properties: {},
    extended_properties: {
        "PSVersion": PsProperty {
            name: "PSVersion",
            value: Primitive(
                Version(
                    "2.0",
                ),
            ),
        },
        "SerializationVersion": PsProperty {
            name: "SerializationVersion",
            value: Primitive(
                Version(
                    "1.1.0.1",
                ),
            ),
        },
        "protocolversion": PsProperty {
            name: "protocolversion",
            value: Primitive(
                Version(
                    "2.3",
                ),
            ),
        },
    },
}

================================================================================
                              ANALYZING MESSAGE 2                               
================================================================================

------------------------------------------------------------
4. Data Extraction & UTF-8 Decoding
------------------------------------------------------------
✅ Successfully decoded UTF-8 string (3781 characters)
📄 Complete XML Data:
﻿<Obj RefId="0"><MS><I32 N="MinRunspaces">1</I32><I32 N="MaxRunspaces">1</I32><Obj N="PSThreadOptions" RefId="1"><TN RefId="0"><T>System.Management.Automation.Runspaces.PSThreadOptions</T><T>System.Enum</T><T>System.ValueType</T><T>System.Object</T></TN><ToString>Default</ToString><I32>0</I32></Obj><Obj N="ApartmentState" RefId="2"><TN RefId="1"><T>System.Threading.ApartmentState</T><T>System.Enum</T><T>System.ValueType</T><T>System.Object</T></TN><ToString>Unknown</ToString><I32>2</I32></Obj><Obj N="ApplicationArguments" RefId="3"><TN RefId="2"><T>System.Management.Automation.PSPrimitiveDictionary</T><T>System.Collections.Hashtable</T><T>System.Object</T></TN><DCT><En><S N="Key">PSVersionTable</S><Obj N="Value" RefId="4"><TNRef RefId="2" /><DCT><En><S N="Key">Platform</S><S N="Value">Win32NT</S></En><En><S N="Key">SerializationVersion</S><Version N="Value">1.1.0.1</Version></En><En><S N="Key">PSVersion</S><Version N="Value">7.4.10</Version></En><En><S N="Key">PSCompatibleVersions</S><Obj N="Value" RefId="5"><TN RefId="3"><T>System.Version[]</T><T>System.Array</T><T>System.Object</T></TN><LST><Version>1.0</Version><Version>2.0</Version><Version>3.0</Version><Version>4.0</Version><Version>5.0</Version><Version>5.1</Version><Version>6.0</Version><Version>7.0</Version></LST></Obj></En><En><S N="Key">WSManStackVersion</S><Version N="Value">3.0</Version></En><En><S N="Key">PSSemanticVersion</S><S N="Value">7.4.10</S></En><En><S N="Key">PSRemotingProtocolVersion</S><Version N="Value">2.3</Version></En><En><S N="Key">GitCommitId</S><S N="Value">7.4.10</S></En><En><S N="Key">PSEdition</S><S N="Value">Core</S></En><En><S N="Key">OS</S><S N="Value">Microsoft Windows 10.0.22631</S></En></DCT></Obj></En></DCT></Obj><Obj N="HostInfo" RefId="6"><MS><B N="_isHostUINull">false</B><B N="_isHostRawUINull">false</B><B N="_isHostNull">false</B><Obj N="_hostDefaultData" RefId="7"><MS><Obj N="data" RefId="8"><TN RefId="4"><T>System.Collections.Hashtable</T><T>System.Object</T></TN><DCT><En><I32 N="Key">9</I32><Obj N="Value" RefId="9"><MS><S N="T">System.String</S><S N="V">PowerShell</S></MS></Obj></En><En><I32 N="Key">8</I32><Obj N="Value" RefId="10"><MS><S N="T">System.Management.Automation.Host.Size</S><Obj N="V" RefId="11"><MS><I32 N="width">3824</I32><I32 N="height">2121</I32></MS></Obj></MS></Obj></En><En><I32 N="Key">7</I32><Obj N="Value" RefId="12"><MS><S N="T">System.Management.Automation.Host.Size</S><Obj N="V" RefId="13"><MS><I32 N="width">120</I32><I32 N="height">30</I32></MS></Obj></MS></Obj></En><En><I32 N="Key">6</I32><Obj N="Value" RefId="14"><MS><S N="T">System.Management.Automation.Host.Size</S><Obj N="V" RefId="15"><MS><I32 N="width">120</I32><I32 N="height">30</I32></MS></Obj></MS></Obj></En><En><I32 N="Key">5</I32><Obj N="Value" RefId="16"><MS><S N="T">System.Management.Automation.Host.Size</S><Obj N="V" RefId="17"><MS><I32 N="width">120</I32><I32 N="height">30</I32></MS></Obj></MS></Obj></En><En><I32 N="Key">4</I32><Obj N="Value" RefId="18"><MS><S N="T">System.Int32</S><I32 N="V">25</I32></MS></Obj></En><En><I32 N="Key">3</I32><Obj N="Value" RefId="19"><MS><S N="T">System.Management.Automation.Host.Coordinates</S><Obj N="V" RefId="20"><MS><I32 N="x">0</I32><I32 N="y">0</I32></MS></Obj></MS></Obj></En><En><I32 N="Key">2</I32><Obj N="Value" RefId="21"><MS><S N="T">System.Management.Automation.Host.Coordinates</S><Obj N="V" RefId="22"><MS><I32 N="x">0</I32><I32 N="y">27</I32></MS></Obj></MS></Obj></En><En><I32 N="Key">1</I32><Obj N="Value" RefId="23"><MS><S N="T">System.ConsoleColor</S><I32 N="V">0</I32></MS></Obj></En><En><I32 N="Key">0</I32><Obj N="Value" RefId="24"><MS><S N="T">System.ConsoleColor</S><I32 N="V">7</I32></MS></Obj></En></DCT></Obj></MS></Obj><B N="_useRunspaceHost">false</B></MS></Obj></MS></Obj>

------------------------------------------------------------
5. XML Structure Analysis
------------------------------------------------------------
✅ Successfully parsed XML structure
🏷️  Root XML element: <Obj>

------------------------------------------------------------
6. PowerShell Object Conversion
------------------------------------------------------------
✅ Successfully converted to PowerShell object representation

------------------------------------------------------------
7. PowerShell Object Details
------------------------------------------------------------
ComplexObject {
    type_def: None,
    to_string: None,
    content: Standard,
    adapted_properties: {},
    extended_properties: {
        "ApartmentState": PsProperty {
            name: "ApartmentState",
            value: Object(
                ComplexObject {
                    type_def: Some(
                        PsType {
                            type_names: [
                                "System.Threading.ApartmentState",
                                "System.Enum",
                                "System.ValueType",
                                "System.Object",
                            ],
                        },
                    ),
                    to_string: Some(
                        "Unknown",
                    ),
                    content: PsEnums(
                        PsEnums {
                            value: 2,
                        },
                    ),
                    adapted_properties: {},
                    extended_properties: {},
                },
            ),
        },
        "ApplicationArguments": PsProperty {
            name: "ApplicationArguments",
            value: Object(
                ComplexObject {
                    type_def: Some(
                        PsType {
                            type_names: [
                                "System.Management.Automation.PSPrimitiveDictionary",
                                "System.Collections.Hashtable",
                                "System.Object",
                            ],
                        },
                    ),
                    to_string: None,
                    content: Container(
                        Dictionary(
                            {
                                Primitive(
                                    Str(
                                        "PSVersionTable",
                                    ),
                                ): Object(
                                    ComplexObject {
                                        type_def: Some(
                                            PsType {
                                                type_names: [
                                                    "System.Management.Automation.PSPrimitiveDictionary",
                                                    "System.Collections.Hashtable",
                                                    "System.Object",
                                                ],
                                            },
                                        ),
                                        to_string: None,
                                        content: Container(
                                            Dictionary(
                                                {
                                                    Primitive(
                                                        Str(
                                                            "GitCommitId",
                                                        ),
                                                    ): Primitive(
                                                        Str(
                                                            "7.4.10",
                                                        ),
                                                    ),
                                                    Primitive(
                                                        Str(
                                                            "OS",
                                                        ),
                                                    ): Primitive(
                                                        Str(
                                                            "Microsoft Windows 10.0.22631",
                                                        ),
                                                    ),
                                                    Primitive(
                                                        Str(
                                                            "PSCompatibleVersions",
                                                        ),
                                                    ): Object(
                                                        ComplexObject {
                                                            type_def: Some(
                                                                PsType {
                                                                    type_names: [
                                                                        "System.Version[]",
                                                                        "System.Array",
                                                                        "System.Object",
                                                                    ],
                                                                },
                                                            ),
                                                            to_string: None,
                                                            content: Container(
                                                                List(
                                                                    [
                                                                        Primitive(
                                                                            Version(
                                                                                "1.0",
                                                                            ),
                                                                        ),
                                                                        Primitive(
                                                                            Version(
                                                                                "2.0",
                                                                            ),
                                                                        ),
                                                                        Primitive(
                                                                            Version(
                                                                                "3.0",
                                                                            ),
                                                                        ),
                                                                        Primitive(
                                                                            Version(
                                                                                "4.0",
                                                                            ),
                                                                        ),
                                                                        Primitive(
                                                                            Version(
                                                                                "5.0",
                                                                            ),
                                                                        ),
                                                                        Primitive(
                                                                            Version(
                                                                                "5.1",
                                                                            ),
                                                                        ),
                                                                        Primitive(
                                                                            Version(
                                                                                "6.0",
                                                                            ),
                                                                        ),
                                                                        Primitive(
                                                                            Version(
                                                                                "7.0",
                                                                            ),
                                                                        ),
                                                                    ],
                                                                ),
                                                            ),
                                                            adapted_properties: {},
                                                            extended_properties: {},
                                                        },
                                                    ),
                                                    Primitive(
                                                        Str(
                                                            "PSEdition",
                                                        ),
                                                    ): Primitive(
                                                        Str(
                                                            "Core",
                                                        ),
                                                    ),
                                                    Primitive(
                                                        Str(
                                                            "PSRemotingProtocolVersion",
                                                        ),
                                                    ): Primitive(
                                                        Version(
                                                            "2.3",
                                                        ),
                                                    ),
                                                    Primitive(
                                                        Str(
                                                            "PSSemanticVersion",
                                                        ),
                                                    ): Primitive(
                                                        Str(
                                                            "7.4.10",
                                                        ),
                                                    ),
                                                    Primitive(
                                                        Str(
                                                            "PSVersion",
                                                        ),
                                                    ): Primitive(
                                                        Version(
                                                            "7.4.10",
                                                        ),
                                                    ),
                                                    Primitive(
                                                        Str(
                                                            "Platform",
                                                        ),
                                                    ): Primitive(
                                                        Str(
                                                            "Win32NT",
                                                        ),
                                                    ),
                                                    Primitive(
                                                        Str(
                                                            "SerializationVersion",
                                                        ),
                                                    ): Primitive(
                                                        Version(
                                                            "1.1.0.1",
                                                        ),
                                                    ),
                                                    Primitive(
                                                        Str(
                                                            "WSManStackVersion",
                                                        ),
                                                    ): Primitive(
                                                        Version(
                                                            "3.0",
                                                        ),
                                                    ),
                                                },
                                            ),
                                        ),
                                        adapted_properties: {},
                                        extended_properties: {},
                                    },
                                ),
                            },
                        ),
                    ),
                    adapted_properties: {},
                    extended_properties: {},
                },
            ),
        },
        "HostInfo": PsProperty {
            name: "HostInfo",
            value: Object(
                ComplexObject {
                    type_def: None,
                    to_string: None,
                    content: Standard,
                    adapted_properties: {},
                    extended_properties: {
                        "_hostDefaultData": PsProperty {
                            name: "_hostDefaultData",
                            value: Object(
                                ComplexObject {
                                    type_def: None,
                                    to_string: None,
                                    content: Standard,
                                    adapted_properties: {},
                                    extended_properties: {
                                        "data": PsProperty {
                                            name: "data",
                                            value: Object(
                                                ComplexObject {
                                                    type_def: Some(
                                                        PsType {
                                                            type_names: [
                                                                "System.Collections.Hashtable",
                                                                "System.Object",
                                                            ],
                                                        },
                                                    ),
                                                    to_string: None,
                                                    content: Container(
                                                        Dictionary(
                                                            {
                                                                Primitive(
                                                                    I32(
                                                                        0,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.ConsoleColor",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Primitive(
                                                                                    I32(
                                                                                        7,
                                                                                    ),
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                                Primitive(
                                                                    I32(
                                                                        1,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.ConsoleColor",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Primitive(
                                                                                    I32(
                                                                                        0,
                                                                                    ),
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                                Primitive(
                                                                    I32(
                                                                        2,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.Management.Automation.Host.Coordinates",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Object(
                                                                                    ComplexObject {
                                                                                        type_def: None,
                                                                                        to_string: None,
                                                                                        content: Standard,
                                                                                        adapted_properties: {},
                                                                                        extended_properties: {
                                                                                            "x": PsProperty {
                                                                                                name: "x",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        0,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                            "y": PsProperty {
                                                                                                name: "y",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        27,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                        },
                                                                                    },
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                                Primitive(
                                                                    I32(
                                                                        3,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.Management.Automation.Host.Coordinates",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Object(
                                                                                    ComplexObject {
                                                                                        type_def: None,
                                                                                        to_string: None,
                                                                                        content: Standard,
                                                                                        adapted_properties: {},
                                                                                        extended_properties: {
                                                                                            "x": PsProperty {
                                                                                                name: "x",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        0,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                            "y": PsProperty {
                                                                                                name: "y",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        0,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                        },
                                                                                    },
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                                Primitive(
                                                                    I32(
                                                                        4,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.Int32",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Primitive(
                                                                                    I32(
                                                                                        25,
                                                                                    ),
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                                Primitive(
                                                                    I32(
                                                                        5,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.Management.Automation.Host.Size",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Object(
                                                                                    ComplexObject {
                                                                                        type_def: None,
                                                                                        to_string: None,
                                                                                        content: Standard,
                                                                                        adapted_properties: {},
                                                                                        extended_properties: {
                                                                                            "height": PsProperty {
                                                                                                name: "height",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        30,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                            "width": PsProperty {
                                                                                                name: "width",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        120,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                        },
                                                                                    },
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                                Primitive(
                                                                    I32(
                                                                        6,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.Management.Automation.Host.Size",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Object(
                                                                                    ComplexObject {
                                                                                        type_def: None,
                                                                                        to_string: None,
                                                                                        content: Standard,
                                                                                        adapted_properties: {},
                                                                                        extended_properties: {
                                                                                            "height": PsProperty {
                                                                                                name: "height",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        30,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                            "width": PsProperty {
                                                                                                name: "width",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        120,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                        },
                                                                                    },
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                                Primitive(
                                                                    I32(
                                                                        7,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.Management.Automation.Host.Size",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Object(
                                                                                    ComplexObject {
                                                                                        type_def: None,
                                                                                        to_string: None,
                                                                                        content: Standard,
                                                                                        adapted_properties: {},
                                                                                        extended_properties: {
                                                                                            "height": PsProperty {
                                                                                                name: "height",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        30,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                            "width": PsProperty {
                                                                                                name: "width",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        120,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                        },
                                                                                    },
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                                Primitive(
                                                                    I32(
                                                                        8,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.Management.Automation.Host.Size",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Object(
                                                                                    ComplexObject {
                                                                                        type_def: None,
                                                                                        to_string: None,
                                                                                        content: Standard,
                                                                                        adapted_properties: {},
                                                                                        extended_properties: {
                                                                                            "height": PsProperty {
                                                                                                name: "height",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        2121,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                            "width": PsProperty {
                                                                                                name: "width",
                                                                                                value: Primitive(
                                                                                                    I32(
                                                                                                        3824,
                                                                                                    ),
                                                                                                ),
                                                                                            },
                                                                                        },
                                                                                    },
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                                Primitive(
                                                                    I32(
                                                                        9,
                                                                    ),
                                                                ): Object(
                                                                    ComplexObject {
                                                                        type_def: None,
                                                                        to_string: None,
                                                                        content: Standard,
                                                                        adapted_properties: {},
                                                                        extended_properties: {
                                                                            "T": PsProperty {
                                                                                name: "T",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "System.String",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                            "V": PsProperty {
                                                                                name: "V",
                                                                                value: Primitive(
                                                                                    Str(
                                                                                        "PowerShell",
                                                                                    ),
                                                                                ),
                                                                            },
                                                                        },
                                                                    },
                                                                ),
                                                            },
                                                        ),
                                                    ),
                                                    adapted_properties: {},
                                                    extended_properties: {},
                                                },
                                            ),
                                        },
                                    },
                                },
                            ),
                        },
                        "_isHostNull": PsProperty {
                            name: "_isHostNull",
                            value: Primitive(
                                Bool(
                                    false,
                                ),
                            ),
                        },
                        "_isHostRawUINull": PsProperty {
                            name: "_isHostRawUINull",
                            value: Primitive(
                                Bool(
                                    false,
                                ),
                            ),
                        },
                        "_isHostUINull": PsProperty {
                            name: "_isHostUINull",
                            value: Primitive(
                                Bool(
                                    false,
                                ),
                            ),
                        },
                        "_useRunspaceHost": PsProperty {
                            name: "_useRunspaceHost",
                            value: Primitive(
                                Bool(
                                    false,
                                ),
                            ),
                        },
                    },
                },
            ),
        },
        "MaxRunspaces": PsProperty {
            name: "MaxRunspaces",
            value: Primitive(
                I32(
                    1,
                ),
            ),
        },
        "MinRunspaces": PsProperty {
            name: "MinRunspaces",
            value: Primitive(
                I32(
                    1,
                ),
            ),
        },
        "PSThreadOptions": PsProperty {
            name: "PSThreadOptions",
            value: Object(
                ComplexObject {
                    type_def: Some(
                        PsType {
                            type_names: [
                                "System.Management.Automation.Runspaces.PSThreadOptions",
                                "System.Enum",
                                "System.ValueType",
                                "System.Object",
                            ],
                        },
                    ),
                    to_string: Some(
                        "Default",
                    ),
                    content: PsEnums(
                        PsEnums {
                            value: 0,
                        },
                    ),
                    adapted_properties: {},
                    extended_properties: {},
                },
            ),
        },
    },
}

================================================================================
                               ANALYSIS COMPLETE                                
================================================================================
🎉 Successfully analyzed all PowerShell remoting messages!


--- File: resources/create/wsman/failed.xml ---
<s:Envelope
    xmlns:p="http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd"
    xmlns:s="http://www.w3.org/2003/05/soap-envelope"
    xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"
    xmlns:w="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd">
    <s:Header>
        <a:To>
            http://10.10.0.3:5985/wsman?PSVersion=7.4.10
            </a:To>
        <a:Action
            s:mustUnderstand="true">
            http://schemas.xmlsoap.org/ws/2004/09/transfer/Create
            </a:Action>
        <a:ReplyTo
            s:mustUnderstand="true">
            <a:Address>
                http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous
                </a:Address>
            </a:ReplyTo>
        <a:MessageID>
            uuid:622d032a-f9b3-498d-b447-1359c3bb14f3
            </a:MessageID>
        <w:ResourceURI
            s:mustUnderstand="true">
            http://schemas.microsoft.com/powershell/Microsoft.PowerShell
            </w:ResourceURI>
        <w:MaxEnvelopeSize
            s:mustUnderstand="true">
            512000
            </w:MaxEnvelopeSize>
        <w:Locale
            xml:lang="en-US"
            s:mustUnderstand="false"/>
        <p:DataLocale
            s:mustUnderstand="false"
            xml:lang="en-CA"/>
        <p:SessionId
            s:mustUnderstand="false">
            uuid:ac93b121-bf5e-4486-9e8e-cc336a77efe2
            </p:SessionId>
        <p:OperationID
            s:mustUnderstand="false">
            uuid:9178a378-f1b0-4ede-9ee2-52e43056aa28
            </p:OperationID>
        <p:SequenceId
            s:mustUnderstand="false">
            1
            </p:SequenceId>
        <w:OptionSet
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            s:mustUnderstand="true">
            <w:Option
                Name="protocolversion"
                MustComply="true">
                2.3
                </w:Option>
            </w:OptionSet>
        <w:OperationTimeout>
            PT180.000S
            </w:OperationTimeout>
        <rsp:CompressionType
            xmlns:rsp="http://schemas.microsoft.com/wbem/wsman/1/windows/shell"
            s:mustUnderstand="true">
            xpress
            </rsp:CompressionType>
        </s:Header>
    <s:Body>
        <rsp:Shell
            xmlns:rsp="http://schemas.microsoft.com/wbem/wsman/1/windows/shell"
            ShellId="07936b27-7752-4325-8b0d-e7a1e9448320"
            Name="Runspace1">
            <rsp:InputStreams>
                stdin pr
                </rsp:InputStreams>
            <rsp:OutputStreams>
                stdout
                </rsp:OutputStreams>
            <creationXml
                xmlns="http://schemas.microsoft.com/powershell">
                 […]AAAAAAAAAAEAAAAAAAAAAAMAAADHAgAAAAIAAQAHk2snd1JDJYsN56HpRIMgAAAAAAAAAAAAAAAAAAAAADxPYmogUmVmSWQ9IjAiPjxNUz48VmVyc2lvbiBOPSJQU1ZlcnNpb24iPjIuMDwvVmVyc2lvbj48VmVyc2lvbiBOPSJTZXJpYWxpemF0aW9uVmVyc2lvbiI+MS4xLjAuMTwvVmVyc2lvbj48VmVyc2lvb
                </creationXml>
            </rsp:Shell>
        </s:Body>
    </s:Envelope>


--- File: resources/create/wsman/success.xml ---
<s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope"
        xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"
        xmlns:w="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"
        xmlns:p="http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd">
        <s:Header>
                <a:To> http://10.10.0.3:5985/wsman?PSVersion=7.4.10
                </a:To>
                <w:ResourceURI s:mustUnderstand="true">
                http://schemas.microsoft.com/powershell/Microsoft.PowerShell
                </w:ResourceURI>
                <a:ReplyTo>
                        <a:Address s:mustUnderstand="true">
                    http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous
                        </a:Address>
                </a:ReplyTo>
                <a:Action s:mustUnderstand="true">
                http://schemas.xmlsoap.org/ws/2004/09/transfer/Create
                </a:Action>
                <w:MaxEnvelopeSize s:mustUnderstand="true">
                512000
                </w:MaxEnvelopeSize>
                <a:MessageID>
                uuid:D1D65143-B634-4725-BBF6-869CC4D3062F
                </a:MessageID>
                <w:Locale xml:lang="en-US" s:mustUnderstand="false"/>
                <p:DataLocale xml:lang="en-CA" s:mustUnderstand="false"/>
                <p:SessionId s:mustUnderstand="false">
                uuid:9EC885D6-F5A4-4771-9D47-4BDF7DAAEA8C
                </p:SessionId>
                <p:OperationID s:mustUnderstand="false">
                uuid:73C4BCA6-7FF0-4AFE-B8C3-335FB19BA649
                </p:OperationID>
                <p:SequenceId s:mustUnderstand="false">
                1
                </p:SequenceId>
                <w:OptionSet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" s:mustUnderstand="true">
                        <w:Option Name="protocolversion" MustComply="true">
                    2.3
                        </w:Option>
                </w:OptionSet>
                <w:OperationTimeout>
                PT180.000S
                </w:OperationTimeout>
                <rsp:CompressionType s:mustUnderstand="true"
                        xmlns:rsp="http://schemas.microsoft.com/wbem/wsman/1/windows/shell">
                xpress
                </rsp:CompressionType>
        </s:Header>
        <s:Body>
                <rsp:Shell xmlns:rsp="http://schemas.microsoft.com/wbem/wsman/1/windows/shell" Name="Runspace1" ShellId="2D6534D0-6B12-40E3-B773-CBA26459CFA8">
                        <rsp:InputStreams>
                    stdin pr
                        </rsp:InputStreams>
                        <rsp:OutputStreams>
                    stdout
                        </rsp:OutputStreams>
                        <creationXml xmlns="http://schemas.microsoft.com/powershell">
                     […]AAAAAAAAAAEAAAAAAAAAAAMAAADKAgAAAAIAAQDQNGUtEmvjQLdzy6JkWc+oAAAAAAAAAAAAAAAAAAAAAO+7vzxPYmogUmVmSWQ9IjAiPjxNUz48VmVyc2lvbiBOPSJwcm90b2NvbHZlcnNpb24iPjIuMzwvVmVyc2lvbj48VmVyc2lvbiBOPSJQU1ZlcnNpb24iPjIuMDwvVmVyc2lvbj48VmVyc2lvbiBOPSJTZ
                        </creationXml>
                </rsp:Shell>
        </s:Body>
</s:Envelope>


