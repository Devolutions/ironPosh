--- File: crates/ironposh-client-core/Cargo.toml ---
[package]
name = "ironposh-client-core"
version = "0.1.0"
edition = "2024"

[dependencies]
hyper = "1.6.0"
thiserror = "2.0.12"
uuid = { version = "1.17.0", features = ["v4"] }
ironposh-winrm = { path = "../ironposh-winrm" }
ironposh-psrp = { path = "../ironposh-psrp" }
ironposh-xml = { path = "../ironposh-xml" }
typed-builder = "0.21.0"
base64 = "0.22.1"
tracing = "0.1.41"
sspi = { path = "C:\\dev\\sspi-rs", features = ["ring"] }
url = "2.5.7"
# sspi = { version = "0.16.1", features = ["ring"] }


[dev-dependencies]
ureq = "2"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
tokio = { version = "1", features = ["full"] }
anyhow = "1"
regex = "1"


--- File: crates/ironposh-client-core/examples/auth_sequence.rs ---
use anyhow::Result;
use ironposh_client_core::{
    KerberosConfig, SspiAuthConfig,
    connector::{
        auth_sequence::{AuthSequence, SecurityContextBuilderHolder},
        authenticator::{ActionReqired, SecContextMaybeInit},
        http::{HttpBuilder, ServerAddress},
    },
    credentials::{ClientAuthIdentity, ClientUserName},
};
use url::Url;

fn main() -> Result<()> {
    let username = ClientUserName::new("administrator", None)?;
    let identity = ClientAuthIdentity::new(username, "DevoLabs123!".into());
    let sspi_config = SspiAuthConfig::Kerberos {
        target_name: "HTTP/IT-HELP.DC.ad.it-help.ninja".into(),
        identity,
        kerberos_config: KerberosConfig {
            kdc_url: Some(Url::parse("tcp://IT-HELP.DC.ad.it-help.ninja:88")?),
            client_computer_name: None,
        },
    };
    let http_builder = HttpBuilder::new(
        ServerAddress::Domain("www.example.com".into()),
        80,
        ironposh_client_core::connector::Scheme::Http,
    );

    let mut auth_sequence = AuthSequence::new(sspi_config, http_builder)?;

    let final_token = loop {
        let mut holder = SecurityContextBuilderHolder::new();
        let init = {
            let result = auth_sequence.try_init_sec_context(None, &mut holder)?;
            let init = match result {
                SecContextMaybeInit::Initialized(sec_context_init) => sec_context_init,
                SecContextMaybeInit::RunGenerator {
                    mut packet,
                    mut generator_holder,
                } => loop {
                    let response = send(packet)?;
                    match AuthSequence::resume(generator_holder, response)? {
                        SecContextMaybeInit::Initialized(sec_context_init) => {
                            break sec_context_init;
                        }
                        SecContextMaybeInit::RunGenerator {
                            packet: packet2,
                            generator_holder: generator2,
                        } => {
                            packet = packet2;
                            generator_holder = generator2;
                        }
                    }
                },
            };
            init
        };

        println!("Would process context here and potentially loop again");

        drop(holder); // Need to explicitly drop the holder to release borrows
        let action = auth_sequence.process_initialized_sec_context(init)?;

        match action {
            ActionReqired::TryInitSecContextAgain { token } => {
                // In a real scenario, you would use this token in the next HTTP request.
                println!("Got token for next round: {:?}", token);
                todo!("Send HTTP request with token and get response");
            }
            ActionReqired::Done { token } => {
                println!("Authentication finished. Final token: {:?}", token);
                break token;
            }
        }
    };

    println!("Final token: {:?}", final_token);

    Ok(())
}

pub fn send(packet: sspi::generator::NetworkRequest) -> Result<Vec<u8>> {
    println!("Sending packet to server...{:?}", packet);
    panic!("Not implemented");
    // In a real implementation, this would send the packet over the network
    // and return the server's response.
    // For this example, we return an empty Vec<u8> to simulate a response.
    Ok(Vec::new())
}


--- File: crates/ironposh-client-core/examples/borrow_issue.rs ---
struct Builder<'a> {
    _data: &'a mut Vec<u8>,
}

// This simulates the Generator that borrows from the Builder
struct Generator<'a> {
    _builder_ref: &'a mut Builder<'a>,
}

// This simulates our AuthContext that owns the data
struct Context {
    data: Vec<u8>,
}

// This simulates the holder for the builder (like our builder_holder)
type BuilderHolder<'a> = Option<Builder<'a>>;

// This function simulates try_init_sec_context
fn create_generator<'ctx, 'holder>(
    context: &'ctx mut Context,
    holder: &'holder mut BuilderHolder<'ctx>,
) -> Generator<'ctx>
where
    'holder: 'ctx, // holder must outlive the borrow from context
{
    // Create a builder that borrows from context
    let builder = Builder {
        _data: &mut context.data,
    };

    // Store builder in holder
    *holder = Some(builder);

    // Create generator that borrows from the builder in holder
    Generator {
        _builder_ref: holder.as_mut().unwrap(),
    }
}

fn main() {
    // This fails - actual loop (uncomment to see the error)
    {
        let mut holder = None;
        // UNCOMMENT TO SEE THE ERROR:
        let mut context = Context {
            data: vec![1, 2, 3],
        };
        let mut iteration = 0;

        loop {
            iteration += 1;
            println!("Iteration {}", iteration);

            // This fails on second iteration!
            // The generator from iteration 1 still "holds" the borrows
            {
                let _gen = create_generator(&mut context, &mut holder);
            }

            holder = None; // Clear the holder to simulate breaking the loop
            if iteration >= 10 {
                break;
            }
        }
    }
}


--- File: crates/ironposh-client-core/examples/sspi.rs ---
use anyhow::Result;
use ironposh_client_core::ClientAuthIdentity;
use ironposh_client_core::connector::authenticator::{
    AuthContext, SecContextInit, SecContextMaybeInit, SspiAuthenticator,
};
use ironposh_client_core::credentials::ClientUserName;
use sspi::Sspi;

fn main() -> Result<()> {
    let username = ClientUserName::new("administrator", None)?;
    let identity = ClientAuthIdentity::new(username, "DevoLabs123!".into());

    // Create NTLM context
    let mut context = AuthContext::new_ntlm(
        identity,
        ironposh_client_core::SspiAuthConfig::Negotiate {
            target_name: (),
            identity: (),
            kerberos_config: (),
        },
    )?;

    // let mut auth_response = None;

    // THIS IS THE PROBLEMATIC LOOP PATTERN FROM connection.rs
    let mut holder = None;
    let final_token = loop {
        // Let's try wrapping EVERYTHING in a block
        let init = {
            let result = SspiAuthenticator::try_init_sec_context(None, &mut context, &mut holder)?;
            let init = match result {
                SecContextMaybeInit::Initialized(sec_context_init) => sec_context_init,
                SecContextMaybeInit::RunGenerator {
                    mut packet,
                    mut generator_holder,
                } => {
                    loop {
                        let response = send(packet)?;
                        match SspiAuthenticator::resume(generator_holder, response)? {
                            SecContextMaybeInit::Initialized(sec_context_init) => {
                                break sec_context_init;
                            }
                            SecContextMaybeInit::RunGenerator {
                                packet: packet2,
                                generator_holder: generator2,
                            } => {
                                // Continue the loop with new packet and generator
                                packet = packet2;
                                generator_holder = generator2;
                            }
                        }
                    }
                }
            };

            init
        }; // The entire borrow scope ends here

        println!("Would process context here and potentially loop again");

        holder = None; // Clear the holder to simulate breaking the loop
        let action = SspiAuthenticator::process_initialized_sec_context(&mut context, init)?;

        match action {
            ironposh_client_core::connector::authenticator::ActionReqired::TryInitSecContextAgain { token } => {
                continue;

            },
            ironposh_client_core::connector::authenticator::ActionReqired::Done { token } => {
                break token;
            },
        }
    };

    Ok(())
}

pub fn send(packet: sspi::generator::NetworkRequest) -> Result<Vec<u8>> {
    // send the packet over the network
    Ok(Vec::new())
}


--- File: crates/ironposh-client-core/src/connector/active_session.rs ---
use crate::{
    connector::http::{HttpBuilder, HttpRequest, HttpResponse},
    host::{HostCallRequest, HostCallResponse, HostCallScope},
    pipeline::PipelineCommand,
    powershell::PipelineHandle,
    runspace_pool::{RunspacePool, pool::AcceptResponsResult},
};
use ironposh_psrp::{PipelineOutput, PsValue};
use tracing::{debug, error, info, instrument};

#[derive(Debug, PartialEq, Eq)]
pub enum UserEvent {
    PipelineCreated {
        powershell: PipelineHandle,
    },
    PipelineFinished {
        powershell: PipelineHandle,
    },
    PipelineOutput {
        powershell: PipelineHandle,
        output: PipelineOutput,
    },
}

impl UserEvent {
    pub fn pipeline_id(&self) -> uuid::Uuid {
        match self {
            UserEvent::PipelineCreated { powershell }
            | UserEvent::PipelineFinished { powershell }
            | UserEvent::PipelineOutput { powershell, .. } => powershell.id(),
        }
    }
}

#[derive(Debug)]
pub enum ActiveSessionOutput {
    SendBack(Vec<HttpRequest<String>>),
    SendBackError(crate::PwshCoreError),
    UserEvent(UserEvent),
    HostCall(HostCallRequest),
    OperationSuccess,
}

impl PartialEq for ActiveSessionOutput {
    fn eq(&self, other: &Self) -> bool {
        self.priority() == other.priority()
    }
}

impl Eq for ActiveSessionOutput {}

impl PartialOrd for ActiveSessionOutput {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for ActiveSessionOutput {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.priority().cmp(&other.priority())
    }
}

impl ActiveSessionOutput {
    pub fn priority(&self) -> u8 {
        match self {
            ActiveSessionOutput::HostCall { .. } => 1,
            ActiveSessionOutput::SendBack(_) => 2,
            ActiveSessionOutput::SendBackError(_) => 3,
            ActiveSessionOutput::UserEvent(_) => 4,
            ActiveSessionOutput::OperationSuccess => 5,
        }
    }
}

#[derive(Debug)]
pub enum PowershellOperations {
    AddCommand { command: PipelineCommand },
}

#[derive(Debug)]
pub enum UserOperation {
    CreatePipeline {
        uuid: uuid::Uuid,
    },
    OperatePipeline {
        powershell: PipelineHandle,
        operation: PowershellOperations,
    },
    InvokePipeline {
        powershell: PipelineHandle,
    },
    /// Reply to a server-initiated host call (PipelineHostCall or RunspacePoolHostCall)
    SubmitHostResponse {
        response: Box<HostCallResponse>,
    },
    /// Allow UI to abort a pending prompt cleanly (timeout, user cancelled)
    CancelHostCall {
        scope: HostCallScope,
        call_id: i64,
        reason: Option<String>,
    },
}

/// ActiveSession manages post-connection operations
#[derive(Debug)]
pub struct ActiveSession {
    runspace_pool: RunspacePool,
    http_builder: HttpBuilder,
    /// Tracks pending host calls by (scope, call_id) to validate responses
    pending_host_calls: std::collections::HashMap<(HostCallScope, i64), ()>,
}

impl ActiveSession {
    pub fn new(runspace_pool: RunspacePool, http_builder: HttpBuilder) -> Self {
        Self {
            runspace_pool,
            http_builder,
            pending_host_calls: std::collections::HashMap::new(),
        }
    }

    /// Handle a client-initiated operation
    #[instrument(skip_all)]
    pub fn accept_client_operation(
        &mut self,
        operation: UserOperation,
    ) -> Result<ActiveSessionOutput, crate::PwshCoreError> {
        info!(?operation, "Accepting client operation");

        match operation {
            UserOperation::CreatePipeline { uuid } => {
                Ok(ActiveSessionOutput::UserEvent(UserEvent::PipelineCreated {
                    powershell: self.runspace_pool.init_pipeline(uuid)?,
                }))
            }
            UserOperation::OperatePipeline {
                powershell,
                operation,
            } => {
                match operation {
                    PowershellOperations::AddCommand { command } => {
                        self.runspace_pool.add_command(powershell, command)?;
                    }
                }
                Ok(ActiveSessionOutput::OperationSuccess)
            }
            UserOperation::InvokePipeline { powershell } => {
                let command_request = self.runspace_pool.invoke_pipeline_request(powershell);

                match command_request {
                    Ok(request) => {
                        let response = self.http_builder.post("/wsman", request);
                        Ok(ActiveSessionOutput::SendBack(vec![response]))
                    }
                    Err(e) => Ok(ActiveSessionOutput::SendBackError(e)),
                }
            }
            UserOperation::SubmitHostResponse { response } => {
                let HostCallResponse {
                    call_scope,
                    call_id,
                    method_id,
                    method_name,
                    method_result: result,
                    method_exception: error,
                } = *response;
                // Validate that this host call is actually pending
                let key = (call_scope.clone(), call_id);
                if !self.pending_host_calls.contains_key(&key) {
                    return Err(crate::PwshCoreError::InvalidState(
                        "Host call not found or already completed",
                    ));
                }

                // Remove from pending calls
                self.pending_host_calls.remove(&key);

                // Create the appropriate host response message based on scope
                match call_scope {
                    HostCallScope::Pipeline { command_id } => self.send_pipeline_host_response(
                        command_id,
                        call_id,
                        method_id,
                        method_name,
                        result,
                        error,
                    ),
                    HostCallScope::RunspacePool => self.send_runspace_pool_host_response(
                        call_id,
                        method_id,
                        method_name,
                        result,
                        error,
                    ),
                }
            }
            UserOperation::CancelHostCall {
                scope,
                call_id,
                reason: _reason,
            } => {
                // Remove from pending calls if it exists
                let key = (scope.clone(), call_id);
                self.pending_host_calls.remove(&key);

                // For cancellation, send an error response
                let error_msg = format!("Host call {call_id} was cancelled");
                let error = Some(PsValue::Primitive(ironposh_psrp::PsPrimitiveValue::Str(
                    error_msg,
                )));

                match scope {
                    HostCallScope::Pipeline { command_id } => self.send_pipeline_host_response(
                        command_id,
                        call_id,
                        0,
                        "Cancelled".to_string(),
                        None,
                        error,
                    ),
                    HostCallScope::RunspacePool => self.send_runspace_pool_host_response(
                        call_id,
                        0,
                        "Cancelled".to_string(),
                        None,
                        error,
                    ),
                }
            }
        }
    }

    /// Handle a server response
    #[instrument(skip(self, response))]
    pub fn accept_server_response(
        &mut self,
        response: HttpResponse<String>,
    ) -> Result<Vec<ActiveSessionOutput>, crate::PwshCoreError> {
        let body = response.body.ok_or(crate::PwshCoreError::InvalidState(
            "Expected a body in server response",
        ))?;

        debug!("Response body length: {}", body.len());

        let results = self.runspace_pool.accept_response(body).map_err(|e| {
            error!("RunspacePool.accept_response failed: {:#}", e);
            e
        })?;

        let mut step_output = Vec::new();
        debug!(?results, "RunspacePool accept_response results");

        for (index, result) in results.into_iter().enumerate() {
            debug!("Processing result {}: {:?}", index, result);

            match result {
                AcceptResponsResult::ReceiveResponse { desired_streams } => {
                    debug!(
                        "Creating receive request for streams: {:?}",
                        desired_streams
                    );
                    let receive_request = self
                        .runspace_pool
                        .fire_receive(desired_streams)
                        .map_err(|e| {
                            error!("Failed to create receive request: {:#}", e);
                            e
                        })?;
                    let response = self.http_builder.post("/wsman", receive_request);
                    step_output.push(ActiveSessionOutput::SendBack(vec![response]));
                }
                AcceptResponsResult::PipelineCreated(pipeline) => {
                    debug!(?pipeline, "Pipeline created");
                    step_output.push(ActiveSessionOutput::UserEvent(UserEvent::PipelineCreated {
                        powershell: pipeline,
                    }));
                }
                AcceptResponsResult::PipelineFinished(pipeline) => {
                    debug!(?pipeline, "Pipeline finished");
                    step_output.push(ActiveSessionOutput::UserEvent(
                        UserEvent::PipelineFinished {
                            powershell: pipeline,
                        },
                    ));
                }
                AcceptResponsResult::HostCall(host_call) => {
                    debug!(host_call = ?host_call, "Received host call request");
                    // Track this host call as pending
                    let scope: HostCallScope = host_call.call_type.clone();
                    let key = (scope, host_call.call_id);
                    self.pending_host_calls.insert(key, ());

                    step_output.push(ActiveSessionOutput::HostCall(host_call));
                }
                AcceptResponsResult::PipelineOutput { output, handle } => {
                    debug!("Pipeline output: {:?}", output);
                    step_output.push(ActiveSessionOutput::UserEvent(UserEvent::PipelineOutput {
                        output,
                        powershell: handle,
                    }));
                }
            }
        }

        step_output.sort();
        debug!("Returning {} step outputs", step_output.len());
        Ok(step_output)
    }

    /// Send a pipeline host response back to the server
    fn send_pipeline_host_response(
        &mut self,
        command_id: uuid::Uuid,
        call_id: i64,
        method_id: i32,
        method_name: String,
        result: Option<PsValue>,
        error: Option<PsValue>,
    ) -> Result<ActiveSessionOutput, crate::PwshCoreError> {
        // Only send a response if we have a result or error to report
        // Void methods (like Write, WriteLine, WriteProgress) don't need responses
        if result.is_none() && error.is_none() {
            return Ok(ActiveSessionOutput::OperationSuccess);
        }

        use ironposh_psrp::PipelineHostResponse;

        let host_response = PipelineHostResponse::builder()
            .call_id(call_id)
            .method_id(method_id)
            .method_name(method_name)
            .method_result_opt(result)
            .method_exception_opt(error)
            .build();

        // Fragment and send via RunspacePool
        let request = self
            .runspace_pool
            .send_pipeline_host_response(command_id, host_response)?;
        let http_response = self.http_builder.post("/wsman", request);

        // Queue a receive after sending the response
        let receive_request = self.runspace_pool.fire_receive(
            crate::runspace_pool::DesiredStream::pipeline_streams(command_id),
        )?;
        let receive_http_response = self.http_builder.post("/wsman", receive_request);

        Ok(ActiveSessionOutput::SendBack(vec![
            http_response,
            receive_http_response,
        ]))
    }

    /// Send a runspace pool host response back to the server
    fn send_runspace_pool_host_response(
        &mut self,
        call_id: i64,
        method_id: i32,
        method_name: String,
        result: Option<PsValue>,
        error: Option<PsValue>,
    ) -> Result<ActiveSessionOutput, crate::PwshCoreError> {
        // Only send a response if we have a result or error to report
        // Void methods (like Write, WriteLine, WriteProgress) don't need responses
        if result.is_none() && error.is_none() {
            return Ok(ActiveSessionOutput::OperationSuccess);
        }

        use ironposh_psrp::RunspacePoolHostResponse;

        let host_response = RunspacePoolHostResponse::builder()
            .call_id(call_id)
            .method_id(method_id)
            .method_name(method_name)
            .method_result_opt(result)
            .method_exception_opt(error)
            .build();

        // Fragment and send via RunspacePool
        let request = self
            .runspace_pool
            .send_runspace_pool_host_response(host_response)?;
        let http_response = self.http_builder.post("/wsman", request);

        // Queue a receive after sending the response
        let receive_request = self
            .runspace_pool
            .fire_receive(crate::runspace_pool::DesiredStream::runspace_pool_streams())?;
        let receive_http_response = self.http_builder.post("/wsman", receive_request);

        Ok(ActiveSessionOutput::SendBack(vec![
            http_response,
            receive_http_response,
        ]))
    }
}


--- File: crates/ironposh-client-core/src/connector/auth_sequence.rs ---
use std::fmt::Debug;

use sspi::{NegotiateConfig, ntlm::NtlmConfig};

use crate::{
    PwshCoreError, SspiAuthConfig,
    connector::{
        authenticator::{
            AuthContext, SecContextMaybeInit, SecurityContextBuilder, SspiAuthenticator, Token,
        },
        http::{HttpBuilder, HttpRequest, HttpResponse},
    },
};

pub enum AnyAuthContext {
    Ntlm(AuthContext<sspi::ntlm::Ntlm>),
    Kerberos(AuthContext<sspi::kerberos::Kerberos>),
    Negotiate(AuthContext<sspi::negotiate::Negotiate>),
}

pub struct SecurityContextBuilderHolder<'ctx> {
    ntlm: Option<SecurityContextBuilder<'ctx, sspi::ntlm::Ntlm>>,
    kerberos: Option<SecurityContextBuilder<'ctx, sspi::kerberos::Kerberos>>,
    negotiate: Option<SecurityContextBuilder<'ctx, sspi::negotiate::Negotiate>>,
}

impl<'ctx> SecurityContextBuilderHolder<'ctx> {
    pub fn new() -> Self {
        SecurityContextBuilderHolder {
            ntlm: None,
            kerberos: None,
            negotiate: None,
        }
    }

    pub fn as_mut_ntlm(&mut self) -> &mut Option<SecurityContextBuilder<'ctx, sspi::ntlm::Ntlm>> {
        &mut self.ntlm
    }

    pub fn as_mut_kerberos(
        &mut self,
    ) -> &mut Option<SecurityContextBuilder<'ctx, sspi::kerberos::Kerberos>> {
        &mut self.kerberos
    }

    pub fn as_mut_negotiate(
        &mut self,
    ) -> &mut Option<SecurityContextBuilder<'ctx, sspi::negotiate::Negotiate>> {
        &mut self.negotiate
    }

    pub fn clear(&mut self) {
        self.ntlm = None;
        self.kerberos = None;
        self.negotiate = None;
    }
}

impl AnyAuthContext {
    pub fn new(sspi_config: SspiAuthConfig) -> Result<Self, crate::PwshCoreError> {
        match &sspi_config {
            SspiAuthConfig::NTLM { identity, .. } => {
                AuthContext::new_ntlm(identity.clone(), sspi_config).map(AnyAuthContext::Ntlm)
            }
            SspiAuthConfig::Kerberos {
                identity,
                kerberos_config,
                target_name: _,
            } => AuthContext::new_kerberos(
                identity.clone(),
                sspi::KerberosConfig {
                    kdc_url: kerberos_config.kdc_url.clone(),
                    client_computer_name: kerberos_config.client_computer_name.clone(),
                },
                sspi_config,
            )
            .map(AnyAuthContext::Kerberos),
            SspiAuthConfig::Negotiate {
                identity,
                kerberos_config,
                target_name: _,
            } => {
                if let Some(kerberos_config) = kerberos_config {
                    let client_computer_name = kerberos_config
                        .client_computer_name
                        .clone()
                        .unwrap_or("IronWinRMClient".to_string());

                    AuthContext::new_negotiate(
                        identity.clone(),
                        NegotiateConfig::from_protocol_config(
                            Box::new(sspi::KerberosConfig {
                                kdc_url: kerberos_config.kdc_url.clone(),
                                client_computer_name: kerberos_config.client_computer_name.clone(),
                            }),
                            client_computer_name,
                        ),
                        sspi_config,
                    )
                    .map(AnyAuthContext::Negotiate)
                } else {
                    let client_computer_name = "IronWinRMClient".to_string();
                    AuthContext::new_negotiate(
                        identity.clone(),
                        NegotiateConfig::from_protocol_config(
                            Box::new(NtlmConfig::default()),
                            client_computer_name,
                        ),
                        sspi_config,
                    )
                    .map(AnyAuthContext::Negotiate)
                }
            }
        }
    }
}

pub struct AuthSequence {
    context: AnyAuthContext,
    http_builder: HttpBuilder,
}

pub enum SecCtxInited {
    Continue(HttpRequest<String>),
    Done(Option<Token>),
}

impl Debug for AuthSequence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AuthSequence")
            .field("context", &"AnyAuthContext { ... }")
            .field("http_builder", &self.http_builder)
            .finish()
    }
}

impl AuthSequence {
    pub fn new(
        sspi_config: SspiAuthConfig,
        http_builder: HttpBuilder,
    ) -> Result<Self, crate::PwshCoreError> {
        let context = AnyAuthContext::new(sspi_config)?;
        Ok(AuthSequence {
            context,
            http_builder,
        })
    }

    pub fn try_init_sec_context<'ctx, 'builder, 'generator>(
        self: &'ctx mut Self,
        response: Option<&HttpResponse<String>>,
        sec_ctx_holder: &'builder mut SecurityContextBuilderHolder<'ctx>,
    ) -> Result<SecContextMaybeInit<'generator>, PwshCoreError>
    where
        'ctx: 'builder,
        'builder: 'generator,
    {
        Ok(match &mut self.context {
            AnyAuthContext::Ntlm(auth_context) => SspiAuthenticator::try_init_sec_context(
                response,
                auth_context,
                sec_ctx_holder.as_mut_ntlm(),
            )?,
            AnyAuthContext::Kerberos(auth_context) => SspiAuthenticator::try_init_sec_context(
                response,
                auth_context,
                sec_ctx_holder.as_mut_kerberos(),
            )?,
            AnyAuthContext::Negotiate(auth_context) => SspiAuthenticator::try_init_sec_context(
                response,
                auth_context,
                sec_ctx_holder.as_mut_negotiate(),
            )?,
        })
    }

    pub fn resume<'a>(
        generator_holder: crate::connector::authenticator::GeneratorHolder<'a>,
        kdc_response: Vec<u8>,
    ) -> Result<SecContextMaybeInit<'a>, PwshCoreError> {
        SspiAuthenticator::resume(generator_holder, kdc_response)
    }

    pub fn process_initialized_sec_context(
        &mut self,
        sec_context: crate::connector::authenticator::SecContextInit,
    ) -> Result<SecCtxInited, PwshCoreError> {
        let res = match &mut self.context {
            AnyAuthContext::Ntlm(auth_context) => {
                SspiAuthenticator::process_initialized_sec_context(auth_context, sec_context)
            }
            AnyAuthContext::Kerberos(auth_context) => {
                SspiAuthenticator::process_initialized_sec_context(auth_context, sec_context)
            }
            AnyAuthContext::Negotiate(auth_context) => {
                SspiAuthenticator::process_initialized_sec_context(auth_context, sec_context)
            }
        }?;

        match res {
            super::authenticator::ActionReqired::TryInitSecContextAgain { token } => {
                self.http_builder.with_auth_header(token.0);
                Ok(SecCtxInited::Continue(
                    self.http_builder.post("/wsman", String::new()),
                ))
            }
            super::authenticator::ActionReqired::Done { token } => Ok(SecCtxInited::Done(token)),
        }
    }
}


--- File: crates/ironposh-client-core/src/connector/authenticator.rs ---
use std::fmt::Debug;

use base64::Engine;
use sspi::builders::{
    InitializeSecurityContext, WithContextRequirements, WithCredentialsHandle, WithOutput,
    WithTargetDataRepresentation,
};
use sspi::generator::{Generator, GeneratorState};
use sspi::kerberos::config;
use sspi::{
    BufferType, ClientRequestFlags, CredentialUse, Credentials, DataRepresentation, Error,
    InitializeSecurityContextResult, Kerberos, KerberosConfig, Negotiate, NegotiateConfig,
    NetworkRequest, Ntlm, SecurityBuffer, SecurityStatus, Sspi, SspiImpl,
};

use crate::connector::http::HttpResponse;
use crate::credentials::ClientAuthIdentity;
use crate::{PwshCoreError, SspiAuthConfig};

pub type SecurityContextBuilder<'a, P> = InitializeSecurityContext<
    'a,
    <P as SspiImpl>::CredentialsHandle,
    WithCredentialsHandle,
    WithContextRequirements,
    WithTargetDataRepresentation,
    WithOutput,
>;

/// Caller-owned "Context" the generator borrows.
/// Holds provider, credential handle, in/out buffers, and the ISC builder for the current round.
#[derive(Debug)]
pub struct AuthContext<P: Sspi> {
    pub(crate) provider: P,
    // Box<T> provides a stable heap address; we keep borrows within the same `AuthFurniture`.
    cred: Box<P::CredentialsHandle>,
    out: [SecurityBuffer; 1],
    // Keep the builder + input buffer alive for the duration of the suspension (generator borrows them).
    inbuf: Option<[SecurityBuffer; 1]>,
    sspi_auth_config: SspiAuthConfig,
}

impl AuthContext<Ntlm> {
    pub fn new_ntlm(id: ClientAuthIdentity, config: SspiAuthConfig) -> Result<Self, PwshCoreError> {
        Self::new_with_identity(Ntlm::new(), id, config)
    }
}

impl AuthContext<Negotiate> {
    pub fn new_negotiate(
        id: ClientAuthIdentity,
        config: NegotiateConfig,
        sspi_config: SspiAuthConfig,
    ) -> Result<Self, PwshCoreError> {
        Self::new_with_credential(
            Negotiate::new_client(config)?,
            Credentials::AuthIdentity(id.into_inner()),
            sspi_config,
        )
    }
}

impl AuthContext<Kerberos> {
    pub fn new_kerberos(
        id: ClientAuthIdentity,
        config: KerberosConfig,
        sspi_config: SspiAuthConfig,
    ) -> Result<Self, PwshCoreError> {
        Self::new_with_credential(
            Kerberos::new_client_from_config(config)?,
            Credentials::AuthIdentity(id.into_inner()),
            sspi_config,
        )
    }
}

impl<P> AuthContext<P>
where
    P: Sspi + SspiImpl<AuthenticationData = sspi::Credentials>,
{
    pub fn new_with_credential(mut provider: P, id: Credentials, config: SspiAuthConfig) -> Result<Self, PwshCoreError> {
        let acq = provider
            .acquire_credentials_handle()
            .with_credential_use(CredentialUse::Outbound)
            .with_auth_data(&id);
        let cred = acq.execute(&mut provider)?.credentials_handle;

        Ok(Self {
            provider,
            cred: Box::new(cred),
            out: [SecurityBuffer::new(Vec::new(), BufferType::Token)],
            inbuf: None,
            sspi_auth_config: config,
        })
    }
}

impl<P> AuthContext<P>
where
    P: Sspi + SspiImpl<AuthenticationData = sspi::AuthIdentity>,
{
    pub fn new_with_identity(
        mut provider: P,
        id: ClientAuthIdentity,
        config: SspiAuthConfig,
    ) -> Result<Self, PwshCoreError> {
        let id: sspi::AuthIdentity = id.into_inner();
        let acq = provider
            .acquire_credentials_handle()
            .with_credential_use(CredentialUse::Outbound)
            .with_auth_data(&id);
        let cred = acq.execute(&mut provider)?.credentials_handle;

        Ok(Self {
            provider,
            cred: Box::new(cred),
            out: [SecurityBuffer::new(Vec::new(), BufferType::Token)],
            inbuf: None,
            sspi_auth_config: config,
        })
    }
}

impl<P> AuthContext<P>
where
    P: Sspi,
{
    /// Prepare for the next `InitializeSecurityContext` round.
    /// We only clear here, right before wiring a new round.
    fn clear_for_next_round(&mut self) {
        self.inbuf = None;
        self.out[0].buffer.clear();
    }

    /// Parse the server's negotiate token (if present) and set `inbuf`.
    fn take_input(&mut self, response: Option<&HttpResponse<String>>) -> Result<(), PwshCoreError> {
        if let Some(resp) = response {
            let server_token = parse_negotiate_token(&resp.headers)
                .ok_or_else(|| PwshCoreError::Auth("no Negotiate token"))?;
            self.inbuf = Some([SecurityBuffer::new(server_token, BufferType::Token)]);
        }
        Ok(())
    }
}

#[derive(Debug)]
pub struct GeneratorHolder<'g> {
    pub(super) generator: Generator<
        'g,
        NetworkRequest,
        Result<Vec<u8>, Error>,
        Result<InitializeSecurityContextResult, Error>,
    >,
}

#[derive(Debug, Default)]
pub struct SspiAuthenticator {}

#[derive(Debug)]
pub struct SecContextInit {
    init_sec_context_res: InitializeSecurityContextResult,
}

pub enum SecContextMaybeInit<'g> {
    RunGenerator {
        packet: NetworkRequest,
        generator_holder: GeneratorHolder<'g>,
    },
    Initialized(SecContextInit),
}

pub enum ActionReqired {
    TryInitSecContextAgain { token: Token },
    Done { token: Option<Token> },
}

impl SspiAuthenticator {
    /// Drive one step of the SSPI handshake.
    ///
    /// We mutate `self.state` in place (no `mem::take`), so early returns don't
    /// strand the state as `Taken`. This avoids hard-to-debug invalid-state errors.
    pub fn try_init_sec_context<'ctx, 'builder, 'generator, P>(
        response: Option<&HttpResponse<String>>,
        context: &'ctx mut AuthContext<P>,
        sec_ctx_holder: &'builder mut Option<SecurityContextBuilder<'ctx, P>>,
    ) -> Result<SecContextMaybeInit<'generator>, PwshCoreError>
    where
        P: Sspi + SspiImpl,
        'ctx: 'builder,
        'builder: 'generator,
    {
        context.clear_for_next_round();
        context.take_input(response)?;

        // Build the builder; wire inputs/outputs.
        let mut isc: SecurityContextBuilder<P> = context
            .provider
            .initialize_security_context()
            .with_credentials_handle(&mut *context.cred)
            .with_target_name(context.sspi_auth_config.target_name())
            .with_context_requirements(
                // TODO: expose these flags to callers for tuning.
                ClientRequestFlags::CONFIDENTIALITY | ClientRequestFlags::ALLOCATE_MEMORY,
            )
            .with_target_data_representation(DataRepresentation::Native)
            .with_output(&mut context.out);

        if let Some(input_buffer) = &mut context.inbuf {
            isc = isc.with_input(input_buffer);
        }

        *sec_ctx_holder = Some(isc);

        // Produce the generator for this round.
        let mut generator = context
            .provider
            .initialize_security_context_impl(sec_ctx_holder.as_mut().unwrap())?;

        match generator.start() {
            GeneratorState::Suspended(request) => {
                // We have to suspend to send the packet to the server.
                Ok(SecContextMaybeInit::RunGenerator {
                    packet: request,
                    generator_holder: GeneratorHolder { generator },
                })
            }
            GeneratorState::Completed(init_sec_context_res) => {
                // Do NOT touch `out` here; `isc` still holds &mut out.
                // Defer token extraction to next call.
                let init_sec_context_res = init_sec_context_res?;

                Ok(SecContextMaybeInit::Initialized(SecContextInit {
                    init_sec_context_res,
                }))
            }
        }
    }

    /// Resume a previously-suspended generator with the raw KDC (or similar) response.
    ///
    /// We set the state to `ProcessInitializedContextPending` on completion, and only in the
    /// *next* call to `step` will we drop the builder and extract the token.
    pub fn resume<'a>(
        generator_holder: GeneratorHolder<'a>,
        kdc_response: Vec<u8>,
    ) -> Result<SecContextMaybeInit<'a>, PwshCoreError> {
        let mut generator = generator_holder.generator;

        match generator.resume(Ok(kdc_response)) {
            GeneratorState::Suspended(request) => Ok(SecContextMaybeInit::RunGenerator {
                packet: request,
                generator_holder: GeneratorHolder { generator },
            }),

            GeneratorState::Completed(res) => {
                let init_sec_context_res = res?;
                Ok(SecContextMaybeInit::Initialized(SecContextInit {
                    init_sec_context_res,
                }))
            }
        }
    }

    pub fn process_initialized_sec_context<'a, P: Sspi>(
        furniture: &'a mut AuthContext<P>,
        sec_context: SecContextInit,
    ) -> Result<ActionReqired, PwshCoreError>
    where
        P: Sspi + SspiImpl,
    {
        let produced = std::mem::take(&mut furniture.out[0].buffer);
        let token = token_header_from(&produced).map(Token);

        match sec_context.init_sec_context_res.status {
            SecurityStatus::ContinueNeeded => Ok(ActionReqired::TryInitSecContextAgain {
                token: token.ok_or(PwshCoreError::Auth(
                    "SSPI ContinueNeeded but no token produced",
                ))?,
            }),
            SecurityStatus::Ok => Ok(ActionReqired::Done { token }),
            _ => Err(PwshCoreError::Auth(
                "SSPI InitializeSecurityContext status needs to be handled",
            )),
        }
    }
}

#[derive(Debug, Clone)]
pub struct Token(pub(crate) String);

/// Create an `Authorization` header value if a token exists.
fn token_header_from(bytes: &[u8]) -> Option<String> {
    if bytes.is_empty() {
        None
    } else {
        Some(format!(
            "Negotiate {}",
            base64::engine::general_purpose::STANDARD.encode(bytes)
        ))
    }
}

/// Parse the "WWW-Authenticate: Negotiate <b64>" header case-insensitively.
///
/// If multiple `WWW-Authenticate` headers are present, we take the first `Negotiate` one.
fn parse_negotiate_token(headers: &[(String, String)]) -> Option<Vec<u8>> {
    for (key, value) in headers {
        if key.eq_ignore_ascii_case("www-authenticate") {
            // Try case-insensitive "Negotiate ".
            if let Some(rest) = value
                .strip_prefix("Negotiate ")
                .or_else(|| value.strip_prefix("negotiate "))
            {
                if let Ok(bytes) = base64::engine::general_purpose::STANDARD.decode(rest.trim()) {
                    return Some(bytes);
                }
            }
        }
    }
    None
}


--- File: crates/ironposh-client-core/src/connector/config.rs ---
use url::Url;

#[derive(Debug, Clone)]
pub struct KerberosConfig {
    /// Optional KDC URL. If not set, the KDC will be discovered via DNS SRV records.
    pub kdc_url: Option<Url>,

    /// Optional client computer name. If not set, the local computer name will be used.
    pub client_computer_name: Option<String>,
}

#[derive(Debug, Clone)]
pub enum SspiAuthConfig {
    NTLM {
        target_name: String,
        identity: crate::credentials::ClientAuthIdentity,
    },
    Kerberos {
        target_name: String,
        identity: crate::credentials::ClientAuthIdentity,
        kerberos_config: KerberosConfig,
    },
    Negotiate {
        target_name: String,
        identity: crate::credentials::ClientAuthIdentity,
        kerberos_config: Option<KerberosConfig>,
    },
}

impl SspiAuthConfig {

    pub(crate) fn target_name(&self) -> &str {
        match self {
            SspiAuthConfig::NTLM { target_name, .. } => target_name,
            SspiAuthConfig::Kerberos { target_name, .. } => target_name,
            SspiAuthConfig::Negotiate { target_name, .. } => target_name,
        }
    }
    
}

#[derive(Debug, Clone)]
pub enum Authentication {
    Basic { username: String, password: String },

    Sspi(SspiAuthConfig),
}


--- File: crates/ironposh-client-core/src/connector/http.rs ---
use std::{fmt::Display, net::IpAddr};

#[derive(Debug, Clone)]
pub enum ServerAddress {
    Ip(IpAddr),
    Domain(String),
}

impl ServerAddress {
    pub fn parse(value: &str) -> Result<Self, crate::PwshCoreError> {
        if let Ok(ip) = value.parse::<IpAddr>() {
            Ok(ServerAddress::Ip(ip))
        } else if !value.trim().is_empty() {
            Ok(ServerAddress::Domain(value.to_string()))
        } else {
            Err(crate::PwshCoreError::InvalidServerAddress(
                "server address cannot be empty",
            ))
        }
    }
    
}

impl Display for ServerAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ServerAddress::Ip(ip) => write!(f, "{ip}"),
            ServerAddress::Domain(domain) => write!(f, "{domain}"),
        }
    }
}

#[derive(Debug, Clone)]
pub enum Method {
    Get,
    Post,
    Put,
    Delete,
}

#[derive(Debug, Clone)]
pub struct HttpRequest<T> {
    pub method: Method,
    pub url: String,
    pub headers: Vec<(String, String)>,
    pub body: Option<T>,
    pub cookie: Option<String>,
}

impl<T> HttpRequest<T> {
    pub fn with_headers(mut self, headers: Vec<(String, String)>) -> Self {
        self.headers.extend(headers);
        self
    }
}

#[derive(Debug, Clone)]
pub struct HttpResponse<T> {
    pub status_code: u16,
    pub headers: Vec<(String, String)>,
    pub body: Option<T>,
}

#[derive(Debug)]
pub struct HttpBuilder {
    pub(crate) server: ServerAddress,
    pub(crate) port: u16,
    pub(crate) scheme: crate::connector::Scheme,
    // pub(crate) authentication: crate::connector::Authentication,
    pub(crate) cookie: Option<String>,
    pub(crate) headers: Vec<(String, String)>,
}

impl HttpBuilder {
    pub fn new(server: ServerAddress, port: u16, scheme: crate::connector::Scheme) -> Self {
        Self {
            server,
            port,
            scheme,
            headers: vec![],
            cookie: None,
        }
    }

    pub fn with_cookie(&mut self, cookie: String) {
        self.cookie = Some(cookie);
    }

    pub fn with_auth_header(&mut self, header: String) {
        self.headers.push(("Authorization".to_string(), header));
    }

    fn build_url(&self, path: &str) -> String {
        let scheme_str = match self.scheme {
            crate::connector::Scheme::Http => "http",
            crate::connector::Scheme::Https => "https",
        };

        let server_str = match &self.server {
            ServerAddress::Ip(ip) => ip.to_string(),
            ServerAddress::Domain(domain) => domain.clone(),
        };

        format!("{}://{}:{}{}", scheme_str, server_str, self.port, path)
    }

    fn build_host_header(&self) -> String {
        match &self.server {
            ServerAddress::Ip(ip) => format!("{}:{}", ip, self.port),
            ServerAddress::Domain(domain) => format!("{}:{}", domain, self.port),
        }
    }

    fn build_headers(&mut self, body: Option<&str>) -> Vec<(String, String)> {
        let mut headers = vec![
            ("Host".to_string(), self.build_host_header()),
            (
                "Content-Type".to_string(),
                "application/soap+xml; charset=utf-8".to_string(),
            ),
            // ("Authorization".to_string(), self.build_auth_header()),
        ];

        if let Some(body_content) = body {
            headers.push(("Content-Length".to_string(), body_content.len().to_string()));
        } else {
            headers.push(("Content-Length".to_string(), "0".to_string()));
        }

        if let Some(cookie) = &self.cookie {
            headers.push(("Cookie".to_string(), cookie.clone()));
        }

        headers.append(&mut self.headers);

        headers
    }

    pub fn post(&mut self, path: &str, body: String) -> HttpRequest<String> {
        HttpRequest {
            method: Method::Post,
            url: self.build_url(path),
            headers: self.build_headers(Some(&body)),
            body: Some(body),
            cookie: self.cookie.clone(),
        }
    }

    // pub fn get(&self, path: &str) -> HttpRequest<String> {
    //     HttpRequest {
    //         method: Method::Get,
    //         url: self.build_url(path),
    //         headers: self.build_headers(None),
    //         body: None,
    //         cookie: self.cookie.clone(),
    //     }
    // }

    // pub fn put(&self, path: &str, body: String) -> HttpRequest<String> {
    //     HttpRequest {
    //         method: Method::Put,
    //         url: self.build_url(path),
    //         headers: self.build_headers(Some(&body)),
    //         body: Some(body),
    //         cookie: self.cookie.clone(),
    //     }
    // }

    // pub fn delete(&self, path: &str) -> HttpRequest<String> {
    //     HttpRequest {
    //         method: Method::Delete,
    //         url: self.build_url(path),
    //         headers: self.build_headers(None),
    //         body: None,
    //         cookie: self.cookie.clone(),
    //     }
    // }
}


--- File: crates/ironposh-client-core/src/connector/mod.rs ---
use std::{fmt::Debug, sync::Arc};

use base64::Engine;
use ironposh_psrp::HostInfo;
use ironposh_winrm::ws_management::WsMan;

// I'm lasy for now, just re-export from sspi
pub use sspi::{generator::NetworkRequest, network_client::NetworkProtocol};

use tracing::{info, instrument, warn};

use crate::{
    connector::{
        // auth_sequence::{AnyContext, AuthSequence, SecContextProcessResult, TryInitSecContext},,
        auth_sequence::AuthSequence,
        config::{Authentication, SspiAuthConfig},
        http::{HttpBuilder, HttpRequest, HttpResponse, ServerAddress},
    },
    runspace_pool::{
        DesiredStream, ExpectShellCreated, RunspacePool, RunspacePoolCreator, RunspacePoolState,
        pool::AcceptResponsResult,
    },
};

pub use active_session::{ActiveSession, ActiveSessionOutput, UserOperation};
pub mod active_session;
pub mod auth_sequence;
pub mod authenticator;
pub mod config;
pub mod http;

#[derive(Debug, Clone)]
pub enum Scheme {
    Http,
    Https,
}

#[derive(Debug, Clone)]
pub struct ConnectorConfig {
    pub server: (ServerAddress, u16),
    pub scheme: Scheme,
    pub authentication: Authentication,
    pub host_info: HostInfo,
}

impl ConnectorConfig {
    pub fn wsman_to(&self, query: Option<&str>) -> String {
        let query = query
            .map(|q| format!("?{}", q.trim_start_matches('?')))
            .unwrap_or_default();

        match &self.scheme {
            Scheme::Http => format!("http://{}:{}/wsman{}", self.server.0, self.server.1, query),
            Scheme::Https => format!("https://{}:{}/wsman{}", self.server.0, self.server.1, query),
        }
    }
}

#[derive(Debug)]
pub enum ConnectorStepResult {
    SendBack(HttpRequest<String>),
    SendBackError(crate::PwshCoreError),
    Auth {
        sequence: AuthSequence,
    },
    Connected {
        /// use box to avoid large enum variant
        active_session: Box<ActiveSession>,
        next_receive_request: HttpRequest<String>,
    },
}

impl ConnectorStepResult {
    pub fn name(&self) -> &'static str {
        match self {
            ConnectorStepResult::SendBack(_) => "SendBack",
            ConnectorStepResult::SendBackError(_) => "SendBackError",
            ConnectorStepResult::Connected { .. } => "Connected",
            ConnectorStepResult::Auth { .. } => "Auth",
        }
    }
}

impl ConnectorStepResult {
    pub fn priority(&self) -> u8 {
        match self {
            ConnectorStepResult::Auth { .. } => 0,
            ConnectorStepResult::SendBack(_) => 1,
            ConnectorStepResult::SendBackError(_) => 2,
            ConnectorStepResult::Connected { .. } => 3,
        }
    }
}

#[derive(Default, Debug)]
pub enum ConnectorState {
    Idle,
    #[default]
    Taken,
    AuthenticateInProgress {},
    Connecting {
        expect_shell_created: ExpectShellCreated,
        http_builder: HttpBuilder,
    },
    ConnectReceiveCycle {
        runspace_pool: RunspacePool,
        http_builder: HttpBuilder,
    },
    Connected,
    Failed,
}

impl ConnectorState {
    fn state_name(&self) -> &'static str {
        match self {
            ConnectorState::Idle => "Idle",
            ConnectorState::Taken => "Taken",
            ConnectorState::Connecting { .. } => "Connecting",
            ConnectorState::AuthenticateInProgress { .. } => "Authenticate",
            ConnectorState::ConnectReceiveCycle { .. } => "ConnectReceiveCycle",
            ConnectorState::Connected => "Connected",
            ConnectorState::Failed => "Failed",
        }
    }
}

#[derive(Debug)]
pub struct Connector {
    state: ConnectorState,
    config: ConnectorConfig,
}

impl Connector {
    pub fn new(config: ConnectorConfig) -> Self {
        Self {
            state: ConnectorState::Idle,
            config,
        }
    }

    pub fn set_state(&mut self, state: ConnectorState) {
        info!(state = state.state_name(), "Setting connector state");
        self.state = state;
    }

    pub fn authenticate(
        &mut self,
        last_token: Option<String>,
        mut http_builder: HttpBuilder,
    ) -> Result<HttpRequest<String>, crate::PwshCoreError> {
        match self.state {
            ConnectorState::AuthenticateInProgress {} => {}
            _ => {
                return Err(crate::PwshCoreError::InvalidState(
                    "Connector is not in Authenticate state",
                ));
            }
        };

        if let Some(token) = last_token {
            http_builder.with_auth_header(token);
        }

        let connection = Arc::new(WsMan::builder().to(self.config.wsman_to(None)).build());

        let runspace_pool = RunspacePoolCreator::builder()
            .host_info(self.config.host_info.clone())
            .build()
            .into_runspace_pool(connection);

        let (xml_body, expect_shell_created) = runspace_pool.open()?;

        let request = http_builder.post("/wsman", xml_body);

        self.set_state(ConnectorState::Connecting {
            expect_shell_created,
            http_builder,
        });

        Ok(request)
    }

    #[instrument(skip(self, server_response), name = "Connector::step")]
    pub fn step<'conn, 'auth>(
        &'conn mut self,
        server_response: Option<HttpResponse<String>>,
    ) -> Result<ConnectorStepResult, crate::PwshCoreError> {
        let state = std::mem::take(&mut self.state);

        let (new_state, response) = match state {
            ConnectorState::Taken => {
                return Err(crate::PwshCoreError::UnlikelyToHappen(
                    "Connector should not be in Taken state when stepping",
                ));
            }
            ConnectorState::Failed => {
                warn!("Connector is in Failed state, cannot proceed");
                return Err(crate::PwshCoreError::InvalidState(
                    "Connector is in Failed state",
                ));
            }
            ConnectorState::Connected => {
                warn!("Connector is already connected, cannot step further");
                return Err(crate::PwshCoreError::InvalidState(
                    "Connector is already connected",
                ));
            }
            ConnectorState::Idle => {
                debug_assert!(
                    server_response.is_none(),
                    "Request should be None in Idle state"
                );

                let mut http_builder = HttpBuilder::new(
                    self.config.server.0.clone(),
                    self.config.server.1,
                    self.config.scheme.clone(),
                );

                // if matches!(self.config.authentication, Authentication::Basic { .. }) {
                match self.config.authentication.clone() {
                    Authentication::Basic { username, password } => {
                        let auth_header = format!(
                            "Basic {}",
                            base64::engine::general_purpose::STANDARD
                                .encode(format!("{}:{}", username, password))
                        );

                        http_builder.with_auth_header(auth_header);

                        let connection =
                            Arc::new(WsMan::builder().to(self.config.wsman_to(None)).build());

                        let runspace_pool = RunspacePoolCreator::builder()
                            .host_info(self.config.host_info.clone())
                            .build()
                            .into_runspace_pool(connection);

                        let (xml_body, expect_shell_created) = runspace_pool.open()?;

                        let response = http_builder.post("/wsman", xml_body);

                        let new_state = ConnectorState::Connecting {
                            expect_shell_created,
                            http_builder,
                        };

                        (new_state, ConnectorStepResult::SendBack(response))
                    }
                    Authentication::Sspi(sspi_auth) => (
                        ConnectorState::AuthenticateInProgress {},
                        ConnectorStepResult::Auth {
                            sequence: AuthSequence::new(sspi_auth, http_builder)?,
                        },
                    ),
                }
            }
            ConnectorState::AuthenticateInProgress { .. } => {
                return Err(crate::PwshCoreError::InvalidState(
                    "Connector is already in AuthenticateInProgress state, should use AuthSequence",
                ));
            }
            ConnectorState::Connecting {
                expect_shell_created,
                mut http_builder,
            } => {
                info!("Processing Connecting state");
                let response = server_response.ok_or({
                    crate::PwshCoreError::InvalidState("Expected a response in Connecting state")
                })?;

                let body = response.body.ok_or({
                    crate::PwshCoreError::InvalidState("Expected a body in Connecting state")
                })?;

                let mut runspace_pool = expect_shell_created.accept(body)?;

                let receive_request =
                    runspace_pool.fire_receive(DesiredStream::runspace_pool_streams())?;

                let response = http_builder.post("/wsman", receive_request);

                let new_state = ConnectorState::ConnectReceiveCycle {
                    runspace_pool,
                    http_builder,
                };

                (new_state, ConnectorStepResult::SendBack(response))
            }
            ConnectorState::ConnectReceiveCycle {
                mut runspace_pool,
                mut http_builder,
            } => {
                let response = server_response.ok_or({
                    crate::PwshCoreError::InvalidState(
                        "Expected a response in ConnectReceiveCycle state",
                    )
                })?;

                let body = response.body.ok_or({
                    crate::PwshCoreError::InvalidState(
                        "Expected a body in ConnectReceiveCycle state",
                    )
                })?;

                let accept_response_results = runspace_pool.accept_response(body)?;
                let Some(AcceptResponsResult::ReceiveResponse { desired_streams }) =
                    accept_response_results
                        .into_iter()
                        .find(|r| matches!(r, AcceptResponsResult::ReceiveResponse { .. }))
                else {
                    return Err(crate::PwshCoreError::InvalidState(
                        "Expected ReceiveResponse in ConnectReceiveCycle state",
                    ));
                };

                if let RunspacePoolState::NegotiationSent = runspace_pool.state {
                    let receive_request = runspace_pool.fire_receive(desired_streams)?;
                    let response = http_builder.post("/wsman", receive_request);
                    let new_state = ConnectorState::ConnectReceiveCycle {
                        runspace_pool,
                        http_builder,
                    };
                    (new_state, ConnectorStepResult::SendBack(response))
                } else if let RunspacePoolState::Opened = runspace_pool.state {
                    info!("Connection established successfully - returning ActiveSession");
                    let next_receive_request = runspace_pool.fire_receive(desired_streams)?;
                    let next_http_request = http_builder.post("/wsman", next_receive_request);
                    let active_session = ActiveSession::new(runspace_pool, http_builder);
                    (
                        ConnectorState::Connected,
                        ConnectorStepResult::Connected {
                            active_session: Box::new(active_session),
                            next_receive_request: next_http_request,
                        },
                    )
                } else {
                    warn!("Unexpected RunspacePool state: {:?}", runspace_pool.state);
                    (
                        ConnectorState::Failed,
                        ConnectorStepResult::SendBackError(crate::PwshCoreError::InvalidState(
                            "Unexpected RunspacePool state",
                        )),
                    )
                }
            }
        };

        self.set_state(new_state);

        Ok(response)
    }
}


--- File: crates/ironposh-client-core/src/credentials.rs ---
use crate::PwshCoreError;

#[derive(Debug, Clone)]
pub struct ClientUserName {
    inner: sspi::Username,
}

impl ClientUserName {
    pub fn new_upn(account_name: &str, upn_suffix: &str) -> Result<Self, crate::PwshCoreError> {
        let inner = sspi::Username::new_upn(account_name, upn_suffix)
            .map_err(|_| PwshCoreError::UsernameError("failed to create UPN username"))?;
        Ok(Self { inner })
    }

    pub fn new_down_level_logon_name(
        account_name: &str,
        netbios_domain_name: &str,
    ) -> Result<Self, crate::PwshCoreError> {
        let inner = sspi::Username::new_down_level_logon_name(account_name, netbios_domain_name)
            .map_err(|_| PwshCoreError::UsernameError("failed to create down-level logon name"))?;

        Ok(Self { inner })
    }
    pub fn new(
        account_name: &str,
        netbios_domain_name: Option<&str>,
    ) -> Result<Self, crate::PwshCoreError> {
        let inner = match netbios_domain_name {
            Some(netbios_domain_name) if !netbios_domain_name.is_empty() => {
                sspi::Username::new_down_level_logon_name(account_name, netbios_domain_name)
                    .map_err(|_| {
                        PwshCoreError::UsernameError("failed to create down-level logon name")
                    })?
            }
            _ => sspi::Username::parse(account_name)
                .map_err(|_| PwshCoreError::UsernameError("failed to parse username"))?,
        };
        Ok(Self { inner })
    }

    /// Parses the value in order to find if the value is a user principal name or a down-level logon name
    ///
    /// If there is no `\` or `@` separator, the value is considered to be a down-level logon name with
    /// an empty NetBIOS domain.
    pub fn parse(value: &str) -> Result<Self, crate::PwshCoreError> {
        let inner = sspi::Username::parse(value)
            .map_err(|_| PwshCoreError::UsernameError("failed to parse username"))?;
        Ok(Self { inner })
    }

    /// Returns the internal representation, as-is
    pub fn inner(&self) -> &str {
        self.inner.inner()
    }

    /// Returns the username format for this username
    pub fn format(&self) -> sspi::UserNameFormat {
        self.inner.format()
    }

    /// May return an UPN suffix or NetBIOS domain name depending on the internal format
    pub fn domain_name(&self) -> Option<&str> {
        self.inner.domain_name()
    }

    /// Returns the account name
    pub fn account_name(&self) -> &str {
        self.inner.account_name()
    }
}

/// Public wrapper for authentication credentials that hides the sspi AuthIdentity
#[derive(Debug, Clone)]
pub struct ClientAuthIdentity {
    inner: sspi::AuthIdentity,
}

impl ClientAuthIdentity {
    pub fn new(username: ClientUserName, password: String) -> Self {
        let inner = sspi::AuthIdentity {
            username: username.inner,
            password: password.into(),
        };
        Self { inner }
    }

    pub(crate) fn into_inner(self) -> sspi::AuthIdentity {
        self.inner
    }
}


--- File: crates/ironposh-client-core/src/host/conversions.rs ---
use super::{
    error::HostError,
    methods::{HostCallMethodWithParams, HostMethodParams, RawUIMethodParams, UIMethodParams},
};

/// Convert HostCallRequest to HostCallMethodWithParams based on method_id and parameters
impl TryFrom<&super::HostCallRequest> for HostCallMethodWithParams {
    type Error = HostError;

    fn try_from(call: &super::HostCallRequest) -> Result<Self, Self::Error> {
        // PowerShell method IDs based on the protocol specification
        // Host methods: 1-10, UI methods: 11-30, RawUI methods: 31-60
        match call.method_id {
            // Host methods (1-10)
            1 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetName,
            )),
            2 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetVersion,
            )),
            3 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetInstanceId,
            )),
            4 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetCurrentCulture,
            )),
            5 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::GetCurrentUICulture,
            )),
            6 => {
                let exit_code = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::HostMethod(
                    HostMethodParams::SetShouldExit(exit_code),
                ))
            }
            7 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::EnterNestedPrompt,
            )),
            8 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::ExitNestedPrompt,
            )),
            9 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::NotifyBeginApplication,
            )),
            10 => Ok(HostCallMethodWithParams::HostMethod(
                HostMethodParams::NotifyEndApplication,
            )),

            // UI methods (11-30)
            11 => Ok(HostCallMethodWithParams::UIMethod(UIMethodParams::ReadLine)),
            12 => Ok(HostCallMethodWithParams::UIMethod(
                UIMethodParams::ReadLineAsSecureString,
            )),
            13 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(UIMethodParams::Write(
                    value,
                )))
            }
            14 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteLine(value),
                ))
            }
            15 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteErrorLine(value),
                ))
            }
            16 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteDebugLine(value),
                ))
            }
            17 => {
                let source_id = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i64())
                    .ok_or(HostError::InvalidParameters)?;
                let record = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteProgress(source_id, record),
                ))
            }
            18 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteVerboseLine(value),
                ))
            }
            19 => {
                let value = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::WriteWarningLine(value),
                ))
            }
            20 => {
                let caption = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let descriptions = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string_array())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(UIMethodParams::Prompt(
                    caption,
                    descriptions,
                )))
            }
            21 => {
                let caption = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let message = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let choices = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_string_array())
                    .ok_or(HostError::InvalidParameters)?;
                let default_choice = call
                    .parameters
                    .get(3)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::PromptForChoice(caption, message, choices, default_choice),
                ))
            }
            22 => {
                let caption = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let message = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let user_name = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                let target_name = call
                    .parameters
                    .get(3)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::UIMethod(
                    UIMethodParams::PromptForCredential(caption, message, user_name, target_name),
                ))
            }

            // RawUI methods (31-60)
            31 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetForegroundColor,
            )),
            32 => {
                let color = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetForegroundColor(color),
                ))
            }
            33 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetBackgroundColor,
            )),
            34 => {
                let color = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetBackgroundColor(color),
                ))
            }
            35 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetCursorPosition,
            )),
            36 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetCursorPosition(x, y),
                ))
            }
            37 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetWindowPosition,
            )),
            38 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetWindowPosition(x, y),
                ))
            }
            39 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetCursorSize,
            )),
            40 => {
                let percentage = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetCursorSize(percentage),
                ))
            }
            41 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetBufferSize,
            )),
            42 => {
                let width = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let height = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetBufferSize(width, height),
                ))
            }
            43 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetWindowSize,
            )),
            44 => {
                let width = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let height = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetWindowSize(width, height),
                ))
            }
            45 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetMaxWindowSize,
            )),
            46 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetMaxPhysicalWindowSize,
            )),
            47 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::GetKeyAvailable,
            )),
            48 => {
                let options = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::ReadKey(options),
                ))
            }
            49 => Ok(HostCallMethodWithParams::RawUIMethod(
                RawUIMethodParams::FlushInputBuffer,
            )),
            50 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let contents = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::SetBufferContents(x, y, contents),
                ))
            }
            51 => {
                let x = call
                    .parameters
                    .first()
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let y = call
                    .parameters
                    .get(1)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let width = call
                    .parameters
                    .get(2)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                let height = call
                    .parameters
                    .get(3)
                    .and_then(|p| p.as_i32())
                    .ok_or(HostError::InvalidParameters)?;
                Ok(HostCallMethodWithParams::RawUIMethod(
                    RawUIMethodParams::GetBufferContents(x, y, width, height),
                ))
            }
            52 => {
                // ScrollBufferContents has complex parameters - simplified for now
                let params: Vec<i32> = call
                    .parameters
                    .iter()
                    .take(6)
                    .filter_map(|p| p.as_i32())
                    .collect();
                let fill = call
                    .parameters
                    .get(6)
                    .and_then(|p| p.as_string())
                    .ok_or(HostError::InvalidParameters)?;

                if params.len() == 6 {
                    Ok(HostCallMethodWithParams::RawUIMethod(
                        RawUIMethodParams::ScrollBufferContents(
                            params[0], params[1], params[2], params[3], params[4], params[5], fill,
                        ),
                    ))
                } else {
                    Err(HostError::InvalidParameters)
                }
            }

            _ => Err(HostError::NotImplemented),
        }
    }
}


--- File: crates/ironposh-client-core/src/host/error.rs ---
/// Error type for host operations
#[derive(Debug, Clone, PartialEq)]
pub enum HostError {
    NotImplemented,
    InvalidParameters,
    RequestReturnMismatch,
    Cancelled,
    Other(String),
}

impl std::fmt::Display for HostError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HostError::NotImplemented => write!(f, "Operation not implemented"),
            HostError::InvalidParameters => write!(f, "Invalid parameters"),
            HostError::RequestReturnMismatch => write!(f, "Request and return types do not match"),
            HostError::Cancelled => write!(f, "Operation cancelled"),
            HostError::Other(msg) => write!(f, "{msg}"),
        }
    }
}

impl std::error::Error for HostError {}

/// Result type for host operations
pub type HostResult<T> = Result<T, HostError>;


--- File: crates/ironposh-client-core/src/host/methods.rs ---
use uuid::Uuid;

/// PowerShell Host method calls (requests with parameters)
#[derive(Debug, Clone, PartialEq)]
pub enum HostMethodParams {
    GetName,
    GetVersion,
    GetInstanceId,
    GetCurrentCulture,
    GetCurrentUICulture,
    SetShouldExit(i32), // exit_code
    EnterNestedPrompt,
    ExitNestedPrompt,
    NotifyBeginApplication,
    NotifyEndApplication,
}

/// PowerShell Host UI method calls (requests with parameters)
#[derive(Debug, Clone, PartialEq)]
pub enum UIMethodParams {
    ReadLine,
    ReadLineAsSecureString,
    Write(String),                                       // value
    WriteLine(String),                                   // value
    WriteErrorLine(String),                              // value
    WriteDebugLine(String),                              // value
    WriteProgress(i64, String),                          // source_id, record
    WriteVerboseLine(String),                            // value
    WriteWarningLine(String),                            // value
    Prompt(String, Vec<String>),                         // caption, descriptions
    PromptForChoice(String, String, Vec<String>, i32), // caption, message, choices, default_choice
    PromptForCredential(String, String, String, String), // caption, message, user_name, target_name
}

/// PowerShell Host Raw UI method calls (requests with parameters)
#[derive(Debug, Clone, PartialEq)]
pub enum RawUIMethodParams {
    GetForegroundColor,
    SetForegroundColor(i32), // color
    GetBackgroundColor,
    SetBackgroundColor(i32), // color
    GetCursorPosition,
    SetCursorPosition(i32, i32), // x, y
    GetWindowPosition,
    SetWindowPosition(i32, i32), // x, y
    GetCursorSize,
    SetCursorSize(i32), // percentage
    GetBufferSize,
    SetBufferSize(i32, i32), // width, height
    GetWindowSize,
    SetWindowSize(i32, i32), // width, height
    GetMaxWindowSize,
    GetMaxPhysicalWindowSize,
    GetKeyAvailable,
    ReadKey(i32), // options
    FlushInputBuffer,
    SetBufferContents(i32, i32, String),   // x, y, contents
    GetBufferContents(i32, i32, i32, i32), // x, y, width, height
    ScrollBufferContents(i32, i32, i32, i32, i32, i32, String), // source rectangle, destination, clip, fill
}

/// Host call request containing the method and metadata
#[derive(Debug, Clone, PartialEq)]
pub enum HostCallMethodWithParams {
    HostMethod(HostMethodParams),
    UIMethod(UIMethodParams),
    RawUIMethod(RawUIMethodParams),
}

impl HostCallMethodWithParams {
    /// Submit the result and validate that the request and return types match
    /// Returns (method_result, method_exception)
    pub fn submit(
        self,
        result: HostCallMethodReturn,
    ) -> Result<
        (
            Option<ironposh_psrp::PsValue>,
            Option<ironposh_psrp::PsValue>,
        ),
        super::error::HostError,
    > {
        use ironposh_psrp::{PsPrimitiveValue, PsValue};

        // Validate that the request and return types match
        if !matches(&self, &result) {
            return Err(super::error::HostError::RequestReturnMismatch);
        }

        let (method_result, method_exception) = match result {
            HostCallMethodReturn::Error(error) => {
                // Convert error to PsValue exception
                let error_message = error.to_string();
                (
                    None,
                    Some(PsValue::Primitive(PsPrimitiveValue::Str(error_message))),
                )
            }
            HostCallMethodReturn::HostMethod(method_return) => {
                let result = match method_return {
                    HostMethodReturn::GetName(name) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(name)))
                    }
                    HostMethodReturn::GetVersion(version) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(version)))
                    }
                    HostMethodReturn::GetInstanceId(id) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(id.to_string())))
                    }
                    HostMethodReturn::GetCurrentCulture(culture) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(culture)))
                    }
                    HostMethodReturn::GetCurrentUICulture(culture) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(culture)))
                    }
                    HostMethodReturn::SetShouldExit
                    | HostMethodReturn::EnterNestedPrompt
                    | HostMethodReturn::ExitNestedPrompt
                    | HostMethodReturn::NotifyBeginApplication
                    | HostMethodReturn::NotifyEndApplication => None, // void returns
                };
                (result, None)
            }
            HostCallMethodReturn::UIMethod(ui_return) => {
                let result = match ui_return {
                    UIMethodReturn::ReadLine(text) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Str(text)))
                    }
                    UIMethodReturn::ReadLineAsSecureString(secure_data) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Bytes(secure_data)))
                    }
                    UIMethodReturn::Prompt(values) => Some(PsValue::from_string_array(values)),
                    UIMethodReturn::PromptForChoice(choice) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(choice)))
                    }
                    UIMethodReturn::PromptForCredential(username, password) => {
                        // Create a credential-like object
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "UserName".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "UserName".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::Str(username)),
                            },
                        );
                        properties.insert(
                            "Password".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "Password".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::Bytes(password)),
                            },
                        );
                        Some(PsValue::Object(ironposh_psrp::ComplexObject {
                            type_def: None,
                            to_string: None,
                            content: ironposh_psrp::ComplexObjectContent::Standard,
                            adapted_properties: std::collections::BTreeMap::new(),
                            extended_properties: properties,
                        }))
                    }
                    UIMethodReturn::Write
                    | UIMethodReturn::WriteLine
                    | UIMethodReturn::WriteErrorLine
                    | UIMethodReturn::WriteDebugLine
                    | UIMethodReturn::WriteProgress
                    | UIMethodReturn::WriteVerboseLine
                    | UIMethodReturn::WriteWarningLine => None, // void returns
                };
                (result, None)
            }
            HostCallMethodReturn::RawUIMethod(raw_ui_return) => {
                let result = match raw_ui_return {
                    RawUIMethodReturn::GetForegroundColor(color) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(color)))
                    }
                    RawUIMethodReturn::GetBackgroundColor(color) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(color)))
                    }
                    RawUIMethodReturn::GetCursorPosition(x, y)
                    | RawUIMethodReturn::GetWindowPosition(x, y) => {
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "X".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "X".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(x)),
                            },
                        );
                        properties.insert(
                            "Y".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "Y".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(y)),
                            },
                        );
                        Some(PsValue::Object(ironposh_psrp::ComplexObject {
                            type_def: None,
                            to_string: None,
                            content: ironposh_psrp::ComplexObjectContent::Standard,
                            adapted_properties: std::collections::BTreeMap::new(),
                            extended_properties: properties,
                        }))
                    }
                    RawUIMethodReturn::GetCursorSize(size) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::I32(size)))
                    }
                    RawUIMethodReturn::GetBufferSize(width, height)
                    | RawUIMethodReturn::GetWindowSize(width, height)
                    | RawUIMethodReturn::GetMaxWindowSize(width, height)
                    | RawUIMethodReturn::GetMaxPhysicalWindowSize(width, height) => {
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "Width".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "Width".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(width)),
                            },
                        );
                        properties.insert(
                            "Height".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "Height".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(height)),
                            },
                        );
                        Some(PsValue::Object(ironposh_psrp::ComplexObject {
                            type_def: None,
                            to_string: None,
                            content: ironposh_psrp::ComplexObjectContent::Standard,
                            adapted_properties: std::collections::BTreeMap::new(),
                            extended_properties: properties,
                        }))
                    }
                    RawUIMethodReturn::GetKeyAvailable(available) => {
                        Some(PsValue::Primitive(PsPrimitiveValue::Bool(available)))
                    }
                    RawUIMethodReturn::ReadKey(virtual_key, character, control_state, key_down) => {
                        let mut properties = std::collections::BTreeMap::new();
                        properties.insert(
                            "VirtualKeyCode".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "VirtualKeyCode".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(virtual_key)),
                            },
                        );
                        properties.insert(
                            "Character".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "Character".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::Str(
                                    character.to_string(),
                                )),
                            },
                        );
                        properties.insert(
                            "ControlKeyState".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "ControlKeyState".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(control_state)),
                            },
                        );
                        properties.insert(
                            "KeyDown".to_string(),
                            ironposh_psrp::PsProperty {
                                name: "KeyDown".to_string(),
                                value: PsValue::Primitive(PsPrimitiveValue::I32(key_down)),
                            },
                        );
                        Some(PsValue::Object(ironposh_psrp::ComplexObject {
                            type_def: None,
                            to_string: None,
                            content: ironposh_psrp::ComplexObjectContent::Standard,
                            adapted_properties: std::collections::BTreeMap::new(),
                            extended_properties: properties,
                        }))
                    }
                    RawUIMethodReturn::GetBufferContents(contents) => {
                        Some(PsValue::from_string_array(contents))
                    }
                    RawUIMethodReturn::SetForegroundColor
                    | RawUIMethodReturn::SetBackgroundColor
                    | RawUIMethodReturn::SetCursorPosition
                    | RawUIMethodReturn::SetWindowPosition
                    | RawUIMethodReturn::SetCursorSize
                    | RawUIMethodReturn::SetBufferSize
                    | RawUIMethodReturn::SetWindowSize
                    | RawUIMethodReturn::FlushInputBuffer
                    | RawUIMethodReturn::SetBufferContents
                    | RawUIMethodReturn::ScrollBufferContents => None, // void returns
                };
                (result, None)
            }
        };

        Ok((method_result, method_exception))
    }
}

/// PowerShell Host method responses (return values)
#[derive(Debug, Clone, PartialEq)]
pub enum HostMethodReturn {
    GetName(String),
    GetVersion(String), // Version string
    GetInstanceId(Uuid),
    GetCurrentCulture(String),   // CultureInfo
    GetCurrentUICulture(String), // CultureInfo
    SetShouldExit,               // void return
    EnterNestedPrompt,
    ExitNestedPrompt,
    NotifyBeginApplication,
    NotifyEndApplication,
}

/// PowerShell Host UI method responses (return values)
#[derive(Debug, Clone, PartialEq)]
pub enum UIMethodReturn {
    ReadLine(String),
    ReadLineAsSecureString(Vec<u8>), // SecureString representation
    Write,                           // void return
    WriteLine,                       // void return
    WriteErrorLine,                  // void return
    WriteDebugLine,                  // void return
    WriteProgress,                   // void return
    WriteVerboseLine,                // void return
    WriteWarningLine,                // void return
    Prompt(Vec<String>),             // field values
    PromptForChoice(i32),            // selected choice index
    PromptForCredential(String, Vec<u8>), // username, password (SecureString)
}

/// PowerShell Host Raw UI method responses (return values)
#[derive(Debug, Clone, PartialEq)]
pub enum RawUIMethodReturn {
    GetForegroundColor(i32),
    SetForegroundColor, // void return
    GetBackgroundColor(i32),
    SetBackgroundColor,          // void return
    GetCursorPosition(i32, i32), // x, y
    SetCursorPosition,           // void return
    GetWindowPosition(i32, i32), // x, y
    SetWindowPosition,           // void return
    GetCursorSize(i32),
    SetCursorSize,                      // void return
    GetBufferSize(i32, i32),            // width, height
    SetBufferSize,                      // void return
    GetWindowSize(i32, i32),            // width, height
    SetWindowSize,                      // void return
    GetMaxWindowSize(i32, i32),         // width, height
    GetMaxPhysicalWindowSize(i32, i32), // width, height
    GetKeyAvailable(bool),
    ReadKey(i32, char, i32, i32), // virtual_key_code, character, control_key_state, key_down
    FlushInputBuffer,             // void return
    SetBufferContents,            // void return
    GetBufferContents(Vec<String>), // cell contents
    ScrollBufferContents,         // void return
}

/// Complete host call response
#[derive(Debug, Clone, PartialEq)]
pub enum HostCallMethodReturn {
    HostMethod(HostMethodReturn),
    UIMethod(UIMethodReturn),
    RawUIMethod(RawUIMethodReturn),
    Error(super::error::HostError),
}

fn matches(params: &HostCallMethodWithParams, returns: &HostCallMethodReturn) -> bool {
    match (params, returns) {
        // Host method matches
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetName),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetName(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetVersion),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetVersion(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetInstanceId),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetInstanceId(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetCurrentCulture),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetCurrentCulture(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::GetCurrentUICulture),
            HostCallMethodReturn::HostMethod(HostMethodReturn::GetCurrentUICulture(_)),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::SetShouldExit(_)),
            HostCallMethodReturn::HostMethod(HostMethodReturn::SetShouldExit),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::EnterNestedPrompt),
            HostCallMethodReturn::HostMethod(HostMethodReturn::EnterNestedPrompt),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::ExitNestedPrompt),
            HostCallMethodReturn::HostMethod(HostMethodReturn::ExitNestedPrompt),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::NotifyBeginApplication),
            HostCallMethodReturn::HostMethod(HostMethodReturn::NotifyBeginApplication),
        ) => true,
        (
            HostCallMethodWithParams::HostMethod(HostMethodParams::NotifyEndApplication),
            HostCallMethodReturn::HostMethod(HostMethodReturn::NotifyEndApplication),
        ) => true,

        // UI method matches
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::ReadLine),
            HostCallMethodReturn::UIMethod(UIMethodReturn::ReadLine(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::ReadLineAsSecureString),
            HostCallMethodReturn::UIMethod(UIMethodReturn::ReadLineAsSecureString(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::Write(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::Write),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteErrorLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteErrorLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteDebugLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteDebugLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteProgress(_, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteProgress),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteVerboseLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteVerboseLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::WriteWarningLine(_)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::WriteWarningLine),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::Prompt(_, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::Prompt(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::PromptForChoice(_, _, _, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::PromptForChoice(_)),
        ) => true,
        (
            HostCallMethodWithParams::UIMethod(UIMethodParams::PromptForCredential(_, _, _, _)),
            HostCallMethodReturn::UIMethod(UIMethodReturn::PromptForCredential(_, _)),
        ) => true,

        // RawUI method matches
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetForegroundColor),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetForegroundColor(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetForegroundColor(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetForegroundColor),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetBackgroundColor),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBackgroundColor(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetBackgroundColor(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetBackgroundColor),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetCursorPosition),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetCursorPosition(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetCursorPosition(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetCursorPosition),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetWindowPosition),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetWindowPosition(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetWindowPosition(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetWindowPosition),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetCursorSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetCursorSize(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetCursorSize(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetCursorSize),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetBufferSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetBufferSize(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetBufferSize),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetWindowSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetWindowSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetWindowSize(_, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetWindowSize),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetMaxWindowSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetMaxWindowSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetMaxPhysicalWindowSize),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetMaxPhysicalWindowSize(_, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetKeyAvailable),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetKeyAvailable(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::ReadKey(_)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::ReadKey(_, _, _, _)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::FlushInputBuffer),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::FlushInputBuffer),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::SetBufferContents(_, _, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::SetBufferContents),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::GetBufferContents(_, _, _, _)),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferContents(_)),
        ) => true,
        (
            HostCallMethodWithParams::RawUIMethod(RawUIMethodParams::ScrollBufferContents(
                _,
                _,
                _,
                _,
                _,
                _,
                _,
            )),
            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::ScrollBufferContents),
        ) => true,

        // Error can match with any request
        (_, HostCallMethodReturn::Error(_)) => true,

        // No match
        _ => false,
    }
}


--- File: crates/ironposh-client-core/src/host/mod.rs ---
mod conversions;
mod error;
mod methods;
mod types;

pub use error::*;
pub use methods::*;
pub use types::*;

use ironposh_psrp::{PipelineHostCall, PsValue};

#[derive(Debug, Clone)]
pub struct HostCallRequest {
    /// Type of the host call
    pub call_type: HostCallScope,
    /// Unique identifier for this host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Parameters for the method call as a list of values
    pub parameters: Vec<PsValue>,
}

impl HostCallRequest {
    pub fn new(
        call_type: HostCallScope,
        call_id: i64,
        method_id: i32,
        method_name: String,
        parameters: Vec<PsValue>,
    ) -> Self {
        Self {
            call_type,
            call_id,
            method_id,
            method_name,
            parameters,
        }
    }

    /// Extract the method call with typed parameters
    pub fn get_param(&self) -> Result<HostCallMethodWithParams, HostError> {
        HostCallMethodWithParams::try_from(self)
    }

    /// Submit the result and create a response
    pub fn submit_result(self, result: HostCallMethodReturn) -> HostCallResponse {
        // Extract method and delegate to the new submit method
        let method = match self.get_param() {
            Ok(method) => method,
            Err(error) => {
                // If we can't extract the method, create an error response
                return HostCallResponse {
                    call_scope: self.call_type,
                    call_id: self.call_id,
                    method_id: self.method_id,
                    method_name: self.method_name,
                    method_result: None,
                    method_exception: Some(PsValue::Primitive(
                        ironposh_psrp::PsPrimitiveValue::Str(error.to_string()),
                    )),
                };
            }
        };

        let (method_result, method_exception) = match method.submit(result) {
            Ok((result, exception)) => (result, exception),
            Err(error) => {
                // If submit fails, create an error response
                (
                    None,
                    Some(PsValue::Primitive(ironposh_psrp::PsPrimitiveValue::Str(
                        error.to_string(),
                    ))),
                )
            }
        };

        HostCallResponse {
            call_scope: self.call_type,
            call_id: self.call_id,
            method_id: self.method_id,
            method_name: self.method_name,
            method_result,
            method_exception,
        }
    }

    /// Convenience method to extract method and get a closure for submitting results
    /// Usage: let (method_result, method_exception) = self.get_method()?.submit(result)?;
    pub fn extract_method_and_submit(
        self,
        result: HostCallMethodReturn,
    ) -> Result<(Option<PsValue>, Option<PsValue>), HostError> {
        self.get_param()?.submit(result)
    }
}

#[derive(Debug, Clone)]
pub struct HostCallResponse {
    /// Type of the host call
    pub call_scope: HostCallScope,
    /// Unique identifier for this host call
    pub call_id: i64,
    /// The host method identifier (enum value)
    pub method_id: i32,
    /// String representation of the method name
    pub method_name: String,
    /// Optional return value from the method
    pub method_result: Option<PsValue>,
    /// Optional exception thrown by the method invocation
    pub method_exception: Option<PsValue>,
}

impl From<(&PipelineHostCall, HostCallScope)> for HostCallRequest {
    fn from((call, call_type): (&PipelineHostCall, HostCallScope)) -> Self {
        let PipelineHostCall {
            call_id,
            method_id,
            method_name,
            parameters,
        } = call;

        Self {
            call_type,
            call_id: *call_id,
            method_id: *method_id,
            method_name: method_name.to_string(),
            parameters: parameters.to_vec(),
        }
    }
}

impl From<HostCallRequest> for PipelineHostCall {
    fn from(val: HostCallRequest) -> Self {
        PipelineHostCall {
            call_id: val.call_id,
            method_id: val.method_id,
            method_name: val.method_name,
            parameters: val.parameters,
        }
    }
}


--- File: crates/ironposh-client-core/src/host/types.rs ---
use uuid::Uuid;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum HostCallScope {
    Pipeline { command_id: Uuid },
    RunspacePool,
}


--- File: crates/ironposh-client-core/src/lib.rs ---
use std::borrow::Cow;

pub mod connector;
pub mod credentials;
pub mod host;
pub mod pipeline;
pub mod powershell;
pub mod runspace;
pub mod runspace_pool;

pub use connector::config::{Authentication, KerberosConfig, SspiAuthConfig};
pub use credentials::ClientAuthIdentity;

#[derive(Debug, thiserror::Error)]
pub enum PwshCoreError {
    #[error("Connector error: {0}")]
    ConnectorError(String),

    #[error("Runspace error: {0}")]
    RunspaceError(String),

    #[error("Hyper error: {0}")]
    IOError(std::io::Error),

    #[error("Hyper error: {0}")]
    HyperError(#[from] hyper::http::Error),

    #[error("Invalid state: {0}")]
    InvalidState(&'static str),

    #[error("Something unlikely happened: {0}")]
    UnlikelyToHappen(&'static str),

    #[error("Protocol error: {0}")]
    PowerShellRemotingError(#[from] ironposh_psrp::PowerShellRemotingError),

    #[error("XML parsing error: {0}")]
    XmlParsingError(#[from] ironposh_xml::XmlError),

    #[error("Invalid response: {0}")]
    InvalidResponse(Cow<'static, str>),

    #[error("Host error: {0}")]
    HostError(#[from] crate::host::HostError),

    #[error("SSPI error: {0}")]
    SspiError(#[from] sspi::Error),

    #[error("SSPI username error: {0}")]
    UsernameError(&'static str),

    #[error("Authentication error: {0}")]
    Auth(&'static str),
    

    #[error("Invalid server address: {0}")]
    InvalidServerAddress(&'static str),
}


--- File: crates/ironposh-client-core/src/pipeline.rs ---
use ironposh_psrp::{CommandParameter, PsValue};

use crate::runspace_pool::PsInvocationState;

/// Represents a single parameter for a command
#[derive(Debug, Clone, PartialEq)]
pub enum Parameter {
    Named { name: String, value: PsValue },
    Positional { value: PsValue },
    Switch { name: String, value: bool },
}

/// Represents a single PowerShell command in business logic terms
#[derive(Debug, Clone, PartialEq)]
pub struct PipelineCommand {
    pub command_text: String,
    pub is_script: bool,
    pub parameters: Vec<Parameter>,
}

impl PipelineCommand {
    pub fn new_script(script: String) -> Self {
        Self {
            command_text: script,
            is_script: true,
            parameters: Vec::new(),
        }
    }

    pub fn new_command(command: String) -> Self {
        Self {
            command_text: command,
            is_script: false,
            parameters: Vec::new(),
        }
    }

    pub fn add_parameter(&mut self, params: Parameter) {
        self.parameters.push(params);
    }

    pub fn with_parameter(mut self, params: Parameter) -> Self {
        self.parameters.push(params);
        self
    }

    pub(crate) fn new_output_stream() -> PipelineCommand {
        let mut command = PipelineCommand::new_command("Out-String".to_string());
        command.add_parameter(Parameter::Switch {
            name: "Stream".to_string(),
            value: true,
        });
        command
    }
}

/// Represents execution results in business terms
#[derive(Debug, Clone, Default)]
pub struct ExecutionResult {
    pub error_messages: Vec<String>,
    pub warning_messages: Vec<String>,
    pub debug_messages: Vec<String>,
    pub information_messages: Vec<String>,
    pub progress_records: Vec<ironposh_psrp::ProgressRecord>,
    pub information_records: Vec<ironposh_psrp::InformationRecord>,
}

/// Internal representation of a PowerShell pipeline's state and configuration.
/// This is owned and managed by the `RunspacePool`.
#[derive(Debug, Clone)]
pub struct Pipeline {
    pub(crate) state: PsInvocationState,
    pub(crate) commands: Vec<PipelineCommand>,
    pub(crate) results: ExecutionResult,
}

impl Pipeline {
    pub(crate) fn new() -> Self {
        Self {
            state: PsInvocationState::NotStarted,
            commands: Vec::new(),
            results: ExecutionResult::default(),
        }
    }

    pub(crate) fn add_information_record(&mut self, record: ironposh_psrp::InformationRecord) {
        self.results.information_records.push(record);
    }

    pub(crate) fn add_progress_record(&mut self, record: ironposh_psrp::ProgressRecord) {
        self.results.progress_records.push(record);
    }

    pub(crate) fn add_command(&mut self, command: PipelineCommand) {
        self.commands.push(command);
    }

    pub fn as_stream(&mut self) -> &mut Self {
        self.commands.push(PipelineCommand::new_output_stream());
        self
    }
}

impl Pipeline {
    /// Convert the business-level pipeline to a protocol-level PowerShellPipeline
    pub(crate) fn to_protocol_pipeline(
        &self,
    ) -> Result<ironposh_psrp::messages::create_pipeline::PowerShellPipeline, crate::PwshCoreError>
    {
        use ironposh_psrp::Command;

        // Convert all commands to protocol commands
        let protocol_commands: Vec<Command> = self
            .commands
            .iter()
            .map(|cmd| {
                ironposh_psrp::Command::builder()
                    .cmd(cmd.command_text.clone())
                    .is_script(cmd.is_script)
                    .args(
                        cmd.parameters
                            .iter()
                            .map(|param| match param {
                                Parameter::Named { name, value } => {
                                    CommandParameter::named(name.to_string(), value.clone())
                                }
                                Parameter::Positional { value } => {
                                    CommandParameter::positional(value.clone())
                                }
                                Parameter::Switch { name, value } => {
                                    CommandParameter::named(name.to_string(), *value)
                                }
                            })
                            .collect(),
                    )
                    .build()
            })
            .collect();

        Ok(
            ironposh_psrp::messages::create_pipeline::PowerShellPipeline::builder()
                .is_nested(false)
                .redirect_shell_error_output_pipe(true)
                .cmds(protocol_commands)
                .build(),
        )
    }
}


--- File: crates/ironposh-client-core/src/powershell.rs ---
use uuid::Uuid;

use crate::{
    connector::UserOperation,
    pipeline::{Parameter, PipelineCommand},
};

/// A handle to a PowerShell pipeline managed by a `RunspacePool`.
///
/// This struct is a lightweight, copyable identifier for a specific pipeline.
/// All operations on the pipeline are performed via methods on the `RunspacePool`
/// that take this handle as an argument.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct PipelineHandle {
    pub(crate) id: uuid::Uuid,
}

impl PipelineHandle {
    /// Returns the unique identifier for this PowerShell handle.
    pub fn id(&self) -> uuid::Uuid {
        self.id
    }

    pub fn new(id: Uuid) -> Self {
        Self { id }
    }

    pub fn invoke(&self) -> UserOperation {
        UserOperation::InvokePipeline { powershell: *self }
    }

    pub fn script(&self, script: String) -> UserOperation {
        UserOperation::OperatePipeline {
            powershell: *self,
            operation: crate::connector::active_session::PowershellOperations::AddCommand {
                command: PipelineCommand::new_script(script),
            },
        }
    }

    pub fn command(&self, command: String, params: Vec<Parameter>) -> UserOperation {
        let mut command = PipelineCommand::new_command(command);

        for params in params {
            command.add_parameter(params);
        }

        UserOperation::OperatePipeline {
            powershell: *self,
            operation: crate::connector::active_session::PowershellOperations::AddCommand {
                command,
            },
        }
    }

    pub fn command_builder(&self, command: String) -> SimpleCommandBuilder {
        SimpleCommandBuilder::new(*self, command)
    }
}

pub struct SimpleCommandBuilder {
    powershell: PipelineHandle,
    command: String,
    params: Vec<Parameter>,
}

impl SimpleCommandBuilder {
    pub fn new(powershell: PipelineHandle, command: String) -> Self {
        Self {
            powershell,
            command,
            params: Vec::new(),
        }
    }

    pub fn with_param(mut self, param: Parameter) -> Self {
        self.params.push(param);
        self
    }

    pub fn build(self) -> UserOperation {
        let mut command = PipelineCommand::new_command(self.command);

        for params in self.params {
            command.add_parameter(params);
        }

        UserOperation::OperatePipeline {
            powershell: self.powershell,
            operation: crate::connector::active_session::PowershellOperations::AddCommand {
                command,
            },
        }
    }
}


--- File: crates/ironposh-client-core/src/runspace/mod.rs ---
pub mod win_rs;


--- File: crates/ironposh-client-core/src/runspace/win_rs.rs ---
use base64::Engine;
use ironposh_winrm::{
    cores::{Attribute, DesiredStream, Receive, Shell, Tag, Text, Time, tag_name},
    rsp::{
        commandline::CommandLineValue,
        receive::{CommandStateValue, ReceiveValue},
        shell_value::ShellValue,
    },
    soap::{SoapEnvelope, body::SoapBody},
    ws_management::{self, OptionSetValue, SelectorSetValue, WsMan},
};
use ironposh_xml::builder::Element;
use tracing::{debug, instrument};
use uuid::Uuid;

#[derive(Debug, Clone, typed_builder::TypedBuilder)]
pub struct WinRunspace {
    #[builder(default = "stdin pr".to_string())]
    input_streams: String,
    #[builder(default = "stdout".to_string())]
    output_streams: String,
    #[builder(default, setter(strip_option))]
    #[allow(dead_code)]
    environment: Option<std::collections::HashMap<String, String>>,
    #[builder(default, setter(strip_option))]
    idle_time_out: Option<f64>,
    #[builder(default, setter(strip_option))]
    name: Option<String>,

    #[builder(default = "http://schemas.microsoft.com/powershell/Microsoft.PowerShell".to_string())]
    resource_uri: String,

    #[builder(default = uuid::Uuid::new_v4())]
    id: uuid::Uuid,

    #[builder(default)]
    no_profile: Option<bool>,

    #[builder(default)]
    codepage: Option<u32>,

    #[builder(default)]
    shell_id: Option<String>,
    #[builder(default)]
    owner: Option<String>,
    #[builder(default)]
    client_ip: Option<String>,
    #[builder(default)]
    shell_run_time: Option<String>,
    #[builder(default)]
    shell_inactivity: Option<String>,

    #[builder(default)]
    selector_set: SelectorSetValue,

    #[builder(default)]
    opened: bool,
}

impl WinRunspace {
    pub fn open<'a>(
        &'a self,
        ws_man: &'a WsMan,
        option_set: Option<OptionSetValue>,
        open_content: &'a str,
    ) -> impl Into<Element<'a>> {
        let shell = Tag::from_name(Shell)
            .with_attribute(ironposh_winrm::cores::Attribute::ShellId(
                self.id.to_string().into(),
            ))
            .with_attribute(ironposh_winrm::cores::Attribute::Name(
                self.name.as_deref().unwrap_or("Runspace1").into(),
            ))
            .with_declaration(ironposh_winrm::cores::Namespace::WsmanShell);

        let shell_value = ShellValue::builder()
            .input_streams(self.input_streams.as_ref())
            .output_streams(self.output_streams.as_ref())
            .idle_time_out_opt(self.idle_time_out.map(Time).map(Tag::new))
            .creation_xml(
                Tag::new(open_content)
                    .with_declaration(ironposh_winrm::cores::Namespace::PowerShellRemoting),
            )
            .build();

        let shell = shell.with_value(shell_value);

        let mut option_set = option_set.unwrap_or_default();

        if let Some(profile) = self.no_profile {
            option_set = option_set.add_option("WINRS_NOPROFILE", profile.to_string());
        }

        if let Some(codepage) = self.codepage {
            option_set = option_set.add_option("WINRS_CODEPAGE", codepage.to_string());
        }

        ws_man.invoke(
            ws_management::WsAction::Create,
            None,
            SoapBody::builder().shell(shell).build(),
            Some(option_set),
            None,
        )
    }

    pub fn fire_receive<'a>(
        &'a self,
        ws_man: &'a WsMan,
        desired_streams: Vec<crate::runspace_pool::DesiredStream>,
    ) -> impl Into<Element<'a>> {
        let desired_streams = desired_streams
            .into_iter()
            .map(|stream| {
                let mut tag =
                    Tag::from_name(DesiredStream).with_value(Text::from(stream.name().to_owned()));

                if let Some(command_id) = stream.command_id() {
                    tag = tag.with_attribute(Attribute::CommandId(*command_id));
                }

                tag
            })
            .collect();

        let receive = ReceiveValue::builder()
            .desired_streams(desired_streams)
            .build();

        let receive_tag = Tag::from_name(Receive)
            .with_value(receive)
            .with_declaration(ironposh_winrm::cores::Namespace::WsmanShell);

        let option_set = OptionSetValue::default()
            .add_option("WSMAN_CMDSHELL_OPTION_KEEPALIVE", true.to_string());

        let selector_set = self
            .shell_id
            .as_ref()
            .map(|shell_id| SelectorSetValue::new().add_selector("ShellId", shell_id));

        ws_man.invoke(
            ws_management::WsAction::ShellReceive,
            Some(&self.resource_uri),
            SoapBody::builder().receive(receive_tag).build(),
            Some(option_set),
            selector_set,
        )
    }

    #[instrument(skip_all)]
    pub(crate) fn accept_receive_response<'a>(
        &mut self,
        soap_envelope: &SoapEnvelope<'a>,
    ) -> Result<(Vec<Stream>, Option<CommandState>), crate::PwshCoreError> {
        let receive_response = &soap_envelope
            .body
            .as_ref()
            .receive_response
            .as_ref()
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "No ReceiveResponse found in response".into(),
            ))?;

        let streams = receive_response
            .value
            .streams
            .iter()
            .map(Stream::try_from)
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| {
                crate::PwshCoreError::InvalidResponse("Failed to decode streams".into())
            })?;

        let command_state = receive_response
            .value
            .command_state
            .as_ref()
            .map(CommandState::try_from)
            .transpose()?;

        debug!(receive_response = ?receive_response,?command_state, "Received streams and command state");

        Ok((streams, command_state))
    }

    pub fn accept_create_response<'a>(
        &mut self,
        soap_envelop: &SoapEnvelope<'a>,
    ) -> Result<(), crate::PwshCoreError> {
        let shell = &soap_envelop.body.as_ref().shell.as_ref().ok_or(
            crate::PwshCoreError::InvalidResponse("No shell found in response".into()),
        )?;
        let shell_id = shell.as_ref().shell_id.as_ref().map(|id| id.clone_value());
        let resource_uri = &shell.as_ref().resource_uri;
        let owner = &shell.as_ref().owner;
        let client_ip = &shell.as_ref().client_ip;
        let idle_time_out = &shell.as_ref().idle_time_out;
        let output_stream = &shell.as_ref().output_streams;
        let shell_run_time = &shell.as_ref().shell_run_time;
        let shell_inactivity = &shell.as_ref().shell_inactivity;

        self.shell_id = shell_id.map(|s| s.as_ref().to_string());
        self.owner = owner.as_ref().map(|o| o.value.as_ref().to_string());
        self.client_ip = client_ip.as_ref().map(|c| c.value.as_ref().to_string());
        self.idle_time_out = idle_time_out.as_ref().map(|t| t.value.0);
        self.output_streams = output_stream
            .as_ref()
            .map(|o| o.value.as_ref().to_string())
            .unwrap_or_else(|| "stdout".to_string());

        self.resource_uri = resource_uri
            .as_ref()
            .map(|r| r.value.as_ref().to_string())
            .unwrap_or_else(|| self.resource_uri.clone());

        self.shell_run_time = shell_run_time
            .as_ref()
            .map(|t| t.value.as_ref().to_string());

        self.shell_inactivity = shell_inactivity
            .as_ref()
            .map(|t| t.value.as_ref().to_string());

        let resource_created = soap_envelop.body.as_ref().resource_created.as_ref().ok_or(
            crate::PwshCoreError::InvalidResponse("No ResourceCreated found in response".into()),
        )?;

        let reference_parameters = resource_created.as_ref().reference_parameters.as_ref();

        let selector_set = &reference_parameters.selector_set;

        self.selector_set = selector_set.value.clone();

        self.opened = true;

        Ok(())
    }

    pub(crate) fn create_pipeline_request<'a>(
        &'a self,
        connection: &'a WsMan,
        command_id: uuid::Uuid,
        arguments: Vec<String>,
        executable: Option<String>,
        no_shell: Option<bool>,
    ) -> Result<impl Into<Element<'a>>, crate::PwshCoreError> {
        let command_line = CommandLineValue {
            command: executable,
            arguments,
        };

        let request = connection.invoke(
            ws_management::WsAction::Command,
            Some(self.resource_uri.as_ref()),
            SoapBody::builder()
                .command_line(
                    Tag::new(command_line).with_attribute(Attribute::CommandId(command_id)),
                )
                .build(),
            Some(OptionSetValue::default().add_option(
                "WINRS_SKIP_CMD_SHELL",
                no_shell.unwrap_or_default().to_string(),
            )),
            self.selector_set.clone().into(),
        );

        Ok(request)
    }

    /// Send data to the shell stdin (for host responses)
    /// TODO: We should handle fragmentation properly
    pub fn send_data_request<'a>(
        &'a self,
        connection: &'a WsMan,
        command_id: Option<uuid::Uuid>,
        data: Vec<String>,
    ) -> Result<impl Into<Element<'a>>, crate::PwshCoreError> {
        use ironposh_winrm::{
            cores::{Tag, tag_name::Send},
            soap::body::SoapBody,
        };

        // Add send tag with data
        let send_tag = if let Some(cmd_id) = command_id {
            // For pipeline-scoped sends, include CommandId
            Tag::from_name(Send)
                .with_value(Text::from(data.join("")))
                .with_attribute(Attribute::CommandId(cmd_id))
        } else {
            // For runspace-scoped sends, no CommandId
            Tag::from_name(Send).with_value(Text::from(data.join("")))
        };

        let request = connection.invoke(
            ws_management::WsAction::Send,
            Some(self.resource_uri.as_ref()),
            SoapBody::builder().send(send_tag).build(),
            Some(
                OptionSetValue::default()
                    .add_option("WSMAN_CMDSHELL_OPTION_KEEPALIVE", true.to_string()),
            ),
            self.selector_set.clone().into(),
        );

        Ok(request)
    }

    pub fn accept_commannd_response<'a>(
        &mut self,
        soap_envelope: &SoapEnvelope<'a>,
    ) -> Result<Uuid, crate::PwshCoreError> {
        let command_id = soap_envelope
            .body
            .as_ref()
            .command_response
            .as_ref()
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "No CommandResponse found in response".into(),
            ))?
            .as_ref()
            .as_ref();

        Ok(command_id.0)
    }
}

#[derive(Debug, Clone)]
pub(crate) struct Stream {
    name: String,
    command_id: Option<Uuid>,
    value: Vec<u8>,
}

impl Stream {
    pub(crate) fn name(&self) -> &str {
        &self.name
    }

    pub(crate) fn command_id(&self) -> Option<&Uuid> {
        self.command_id.as_ref()
    }

    pub(crate) fn value(&self) -> &[u8] {
        &self.value
    }
}

impl<'a> TryFrom<&Tag<'a, Text<'a>, tag_name::Stream>> for Stream {
    type Error = crate::PwshCoreError;

    fn try_from(value: &Tag<'a, Text<'a>, tag_name::Stream>) -> Result<Self, Self::Error> {
        let attributes = &value.attributes;
        let name = attributes
            .iter()
            .find_map(|attr| match attr {
                Attribute::Name(name) => Some(name.to_string()),
                _ => None,
            })
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "Stream tag missing name attribute".into(),
            ))?;

        let command_id = attributes.iter().find_map(|attr| match attr {
            Attribute::CommandId(id) => Some(id.to_owned()),
            _ => None,
        });

        // let value = value.value.as_ref();
        let value = base64::engine::general_purpose::STANDARD
            .decode(value.value.as_ref())
            .map_err(|_| {
                crate::PwshCoreError::InvalidResponse("Failed to decode stream value".into())
            })?;

        Ok(Stream {
            name,
            command_id,
            value,
        })
    }
}

#[derive(Debug)]
pub struct CommandState {
    pub command_id: Uuid,
    pub state: String,
    pub exit_code: Option<i32>,
}

impl<'a> TryFrom<&Tag<'a, CommandStateValue<'a>, tag_name::CommandState>> for CommandState {
    type Error = crate::PwshCoreError;

    fn try_from(
        value: &Tag<'a, CommandStateValue<'a>, tag_name::CommandState>,
    ) -> Result<Self, Self::Error> {
        let command_id = value
            .attributes
            .iter()
            .find_map(|attr| match attr {
                Attribute::CommandId(id) => Some(id),
                _ => None,
            })
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "CommandState tag missing command_id attribute".into(),
            ))?;

        let state = value
            .attributes
            .iter()
            .find_map(|attr| match attr {
                Attribute::State(state) => Some(state.to_string()),
                _ => None,
            })
            .ok_or(crate::PwshCoreError::InvalidResponse(
                "CommandState tag missing state attribute".into(),
            ))?;

        let exit_code = value
            .value
            .exit_code
            .as_ref()
            .map(|exit_code| exit_code.value.0);

        Ok(CommandState {
            command_id: *command_id,
            state: state.to_string(),
            exit_code,
        })
    }
}

impl CommandState {
    pub fn is_done(&self) -> bool {
        self.state == "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/CommandState/Done"
    }
}


--- File: crates/ironposh-client-core/src/runspace_pool/creator.rs ---
use std::{collections::HashMap, sync::Arc};

use ironposh_psrp::{
    ApartmentState, ApplicationPrivateData, Defragmenter, Fragmenter, HostInfo, PSThreadOptions,
    PsValue, SessionCapability,
};
use ironposh_winrm::ws_management::WsMan;

use crate::{pipeline::Pipeline, runspace::win_rs::WinRunspace};

use super::{enums::RunspacePoolState, pool::RunspacePool};

#[derive(Debug, typed_builder::TypedBuilder)]
pub struct RunspacePoolCreator {
    #[builder(default = uuid::Uuid::new_v4())]
    id: uuid::Uuid,
    #[builder(default = RunspacePoolState::BeforeOpen)]
    pub(crate) state: RunspacePoolState,

    #[builder(default = 1)]
    min_runspaces: usize,
    #[builder(default = 1)]
    max_runspaces: usize,

    #[builder(default = PSThreadOptions::Default)]
    thread_options: PSThreadOptions,

    #[builder(default = ApartmentState::Unknown)]
    apartment_state: ApartmentState,

    host_info: HostInfo,

    #[builder(default = std::collections::BTreeMap::new())]
    application_arguments: std::collections::BTreeMap<PsValue, PsValue>,

    #[builder(default = Defragmenter::new())]
    defragmenter: Defragmenter,

    #[builder(default)]
    application_private_data: Option<ApplicationPrivateData>,

    #[builder(default)]
    session_capability: Option<SessionCapability>,

    #[builder(default)]
    pipelines: HashMap<uuid::Uuid, Pipeline>,
}

impl RunspacePoolCreator {
    pub fn into_runspace_pool(self, connection: Arc<WsMan>) -> RunspacePool {
        let shell = WinRunspace::builder().id(self.id).build();

        RunspacePool {
            id: self.id,
            state: self.state,
            min_runspaces: self.min_runspaces,
            max_runspaces: self.max_runspaces,
            thread_options: self.thread_options,
            apartment_state: self.apartment_state,
            host_info: self.host_info,
            application_arguments: self.application_arguments,
            fragmenter: Fragmenter::new(connection.max_envelope_size() as usize),
            connection,
            shell,
            defragmenter: self.defragmenter,
            application_private_data: self.application_private_data,
            session_capability: self.session_capability,
            pipelines: self.pipelines,
            runspace_pool_desired_stream_is_pooling: false,
        }
    }
}


--- File: crates/ironposh-client-core/src/runspace_pool/enums.rs ---
use ironposh_psrp::RunspacePoolStateValue;

#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub enum PowerShellState {
    CreatePipelineSent,
    Ready,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PsInvocationState {
    NotStarted = 0,
    Running = 1,
    Stopping = 2,
    Stopped = 3,
    Completed = 4,
    Failed = 5,
    Disconnected = 6,
}

impl From<ironposh_psrp::PSInvocationState> for PsInvocationState {
    fn from(value: ironposh_psrp::PSInvocationState) -> Self {
        match value {
            ironposh_psrp::PSInvocationState::NotStarted => PsInvocationState::NotStarted,
            ironposh_psrp::PSInvocationState::Running => PsInvocationState::Running,
            ironposh_psrp::PSInvocationState::Stopping => PsInvocationState::Stopping,
            ironposh_psrp::PSInvocationState::Stopped => PsInvocationState::Stopped,
            ironposh_psrp::PSInvocationState::Completed => PsInvocationState::Completed,
            ironposh_psrp::PSInvocationState::Failed => PsInvocationState::Failed,
            ironposh_psrp::PSInvocationState::Disconnected => PsInvocationState::Disconnected,
        }
    }
}

/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/b05495bc-a9b2-4794-9f43-4bf1f3633900
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum RunspacePoolState {
    BeforeOpen = 0,
    Opening = 1,
    Opened = 2,
    Closed = 3,
    Closing = 4,
    Broken = 5,
    NegotiationSent = 6,
    NegotiationSucceeded = 7,
    Connecting = 8,
    Disconnected = 9,
}

impl From<&RunspacePoolStateValue> for RunspacePoolState {
    fn from(value: &RunspacePoolStateValue) -> Self {
        match value {
            RunspacePoolStateValue::BeforeOpen => RunspacePoolState::BeforeOpen,
            RunspacePoolStateValue::Opening => RunspacePoolState::Opening,
            RunspacePoolStateValue::Opened => RunspacePoolState::Opened,
            RunspacePoolStateValue::Closed => RunspacePoolState::Closed,
            RunspacePoolStateValue::Closing => RunspacePoolState::Closing,
            RunspacePoolStateValue::Broken => RunspacePoolState::Broken,
            RunspacePoolStateValue::NegotiationSent => RunspacePoolState::NegotiationSent,
            RunspacePoolStateValue::NegotiationSucceeded => RunspacePoolState::NegotiationSucceeded,
            RunspacePoolStateValue::Connecting => RunspacePoolState::Connecting,
            RunspacePoolStateValue::Disconnected => RunspacePoolState::Disconnected,
        }
    }
}


--- File: crates/ironposh-client-core/src/runspace_pool/expect_shell_created.rs ---
use ironposh_winrm::soap::SoapEnvelope;
use ironposh_xml::parser::XmlDeserialize;

use super::pool::RunspacePool;

#[derive(Debug)]
pub struct ExpectShellCreated {
    pub(super) runspace_pool: RunspacePool,
}

impl ExpectShellCreated {
    pub fn accept(self, response: String) -> Result<RunspacePool, crate::PwshCoreError> {
        let ExpectShellCreated { mut runspace_pool } = self;

        let parsed = ironposh_xml::parser::parse(response.as_str())?;

        let soap_response = SoapEnvelope::from_node(parsed.root_element())
            .map_err(crate::PwshCoreError::XmlParsingError)?;

        runspace_pool.shell.accept_create_response(&soap_response)?;

        Ok(runspace_pool)
    }
}


--- File: crates/ironposh-client-core/src/runspace_pool/mod.rs ---
pub mod creator;
pub mod enums;
pub mod expect_shell_created;
pub mod pool;
pub mod types;

// Re-export public types
pub use creator::RunspacePoolCreator;
pub use enums::{PowerShellState, PsInvocationState, RunspacePoolState};
pub use expect_shell_created::ExpectShellCreated;
pub use pool::{DesiredStream, RunspacePool};
pub use types::{PipelineRepresentation, Runspace};


--- File: crates/ironposh-client-core/src/runspace_pool/pool.rs ---
use std::{
    collections::{HashMap, HashSet},
    sync::Arc,
};

use base64::Engine;
use ironposh_psrp::{
    ApartmentState, ApplicationPrivateData, CreatePipeline, Defragmenter, HostInfo,
    InitRunspacePool, PSThreadOptions, PipelineOutput, PsValue, RunspacePoolStateMessage,
    SessionCapability, fragmentation,
};
use ironposh_winrm::{
    soap::SoapEnvelope,
    ws_management::{OptionSetValue, WsMan},
};
use ironposh_xml::parser::XmlDeserialize;
use tracing::{debug, error, info, instrument, trace, warn};
use uuid::Uuid;

use crate::{
    PwshCoreError,
    host::{HostCallRequest, HostCallScope},
    pipeline::{Pipeline, PipelineCommand},
    powershell::PipelineHandle,
    runspace::win_rs::WinRunspace,
    runspace_pool::PsInvocationState,
};

use super::enums::RunspacePoolState;

const PROTOCOL_VERSION: &str = "2.3";
const PS_VERSION: &str = "2.0";
const SERIALIZATION_VERSION: &str = "1.1.0.1";

#[derive(Debug, Clone)]
pub struct DesiredStream {
    name: String,
    command_id: Option<Uuid>,
}
impl DesiredStream {
    pub(crate) fn new(name: impl Into<String>, command_id: Option<Uuid>) -> Self {
        Self {
            name: name.into(),
            command_id,
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn command_id(&self) -> Option<&Uuid> {
        self.command_id.as_ref()
    }

    pub(crate) fn runspace_pool_streams() -> Vec<Self> {
        vec![DesiredStream {
            name: "stdout".to_string(),
            command_id: None,
        }]
    }

    pub(crate) fn pipeline_streams(command_id: Uuid) -> Vec<Self> {
        vec![
            DesiredStream {
                name: "stdout".to_string(),
                command_id: Some(command_id),
            },
            DesiredStream {
                name: "stderr".to_string(),
                command_id: Some(command_id),
            },
        ]
    }

    pub(crate) fn stdout_for_command(command_id: Uuid) -> Self {
        DesiredStream {
            name: "stdout".to_string(),
            command_id: Some(command_id),
        }
    }
}

#[derive(Debug)]
pub enum AcceptResponsResult {
    ReceiveResponse {
        desired_streams: Vec<DesiredStream>,
    },
    PipelineCreated(PipelineHandle),
    PipelineFinished(PipelineHandle),
    HostCall(HostCallRequest),
    PipelineOutput {
        output: PipelineOutput,
        handle: PipelineHandle,
    },
}

#[derive(Debug)]
pub enum PwshMessageResponse {
    HostCall(HostCallRequest),
    PipelineOutput {
        output: PipelineOutput,
        handle: PipelineHandle,
    },
}

impl PwshMessageResponse {
    pub fn name(&self) -> &str {
        match self {
            PwshMessageResponse::HostCall(_) => "HostCall",
            PwshMessageResponse::PipelineOutput { .. } => "PipelineOutput",
        }
    }
}

impl From<PwshMessageResponse> for AcceptResponsResult {
    fn from(response: PwshMessageResponse) -> Self {
        match response {
            PwshMessageResponse::HostCall(host_call) => AcceptResponsResult::HostCall(host_call),
            PwshMessageResponse::PipelineOutput { output, handle } => {
                AcceptResponsResult::PipelineOutput { output, handle }
            }
        }
    }
}

#[derive(Debug)]
pub struct RunspacePool {
    pub(super) id: uuid::Uuid,
    pub(crate) state: RunspacePoolState,
    pub(super) min_runspaces: usize,
    pub(super) max_runspaces: usize,
    pub(super) thread_options: PSThreadOptions,
    pub(super) apartment_state: ApartmentState,
    pub(super) host_info: HostInfo,
    pub(super) application_arguments: std::collections::BTreeMap<PsValue, PsValue>,
    pub(super) shell: WinRunspace,
    pub(super) connection: Arc<WsMan>,
    pub(super) defragmenter: Defragmenter,
    pub(super) application_private_data: Option<ApplicationPrivateData>,
    pub(super) session_capability: Option<SessionCapability>,
    pub(super) pipelines: HashMap<uuid::Uuid, Pipeline>,
    pub(super) fragmenter: fragmentation::Fragmenter,
    pub(super) runspace_pool_desired_stream_is_pooling: bool,
}

impl RunspacePool {
    #[instrument(skip(self), name = "RunspacePool::open")]
    pub fn open(
        mut self,
    ) -> Result<(String, super::expect_shell_created::ExpectShellCreated), crate::PwshCoreError>
    {
        if self.state != RunspacePoolState::BeforeOpen {
            return Err(crate::PwshCoreError::InvalidState(
                "RunspacePool must be in BeforeOpen state to open",
            ));
        }

        let session_capability = SessionCapability {
            protocol_version: PROTOCOL_VERSION.to_string(),
            ps_version: PS_VERSION.to_string(),
            serialization_version: SERIALIZATION_VERSION.to_string(),
            time_zone: None,
        };

        let init_runspace_pool = InitRunspacePool {
            min_runspaces: self.min_runspaces as i32,
            max_runspaces: self.max_runspaces as i32,
            thread_options: self.thread_options,
            apartment_state: self.apartment_state,
            host_info: self.host_info.clone(),
            application_arguments: self.application_arguments.clone(),
        };

        debug!(
            session_capability = ?session_capability,
            min_runspaces = self.min_runspaces,
            max_runspaces = self.max_runspaces,
            "starting runspace pool open"
        );
        debug!(init_runspace_pool = ?init_runspace_pool);

        let request_groups = self.fragmenter.fragment_multiple(
            &[&session_capability, &init_runspace_pool],
            self.id,
            None,
        )?;

        trace!(
            target: "fragmentation",
            request_groups = ?request_groups,
            group_count = request_groups.len(),
            "fragmented negotiation requests"
        );

        self.state = RunspacePoolState::NegotiationSent;

        debug_assert!(
            request_groups.len() == 1,
            "We should have only one request group for the opening negotiation"
        );

        let request = request_groups
            .into_iter()
            .next()
            .ok_or(crate::PwshCoreError::UnlikelyToHappen(
                "No request group generated for negotiation",
            ))
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))?;

        let option_set = OptionSetValue::new().add_option("protocolversion", PROTOCOL_VERSION);

        let result = self
            .shell
            .open(&self.connection, Some(option_set), &request);

        Ok((
            result.into().to_xml_string()?,
            super::expect_shell_created::ExpectShellCreated {
                runspace_pool: self,
            },
        ))
    }

    // We should accept the pipeline id here, but for now let's ignore it
    pub(crate) fn fire_receive(
        &mut self,
        desired_streams: Vec<DesiredStream>,
    ) -> Result<String, crate::PwshCoreError> {
        debug_assert!(!desired_streams.is_empty(), "At least one desired stream");
        Ok(self
            .shell
            .fire_receive(&self.connection, desired_streams)
            .into()
            .to_xml_string()?)
    }

    #[instrument(skip(self, soap_envelope), fields(envelope_length = soap_envelope.len()))]
    pub(crate) fn accept_response(
        &mut self,
        soap_envelope: String,
    ) -> Result<Vec<AcceptResponsResult>, crate::PwshCoreError> {
        debug!(target: "soap", "parsing SOAP envelope");

        let parsed = ironposh_xml::parser::parse(soap_envelope.as_str()).map_err(|e| {
            error!(target: "xml", error = %e, "failed to parse XML");
            e
        })?;

        let soap_envelope = SoapEnvelope::from_node(parsed.root_element()).map_err(|e| {
            error!(target: "soap", error = %e, "failed to parse SOAP envelope");
            crate::PwshCoreError::XmlParsingError(e)
        })?;

        let mut result = Vec::new();

        if soap_envelope.body.as_ref().receive_response.is_some() {
            debug!(target: "receive", "processing receive response");

            let (streams, command_state) = self
                .shell
                .accept_receive_response(&soap_envelope)
                .map_err(|e| {
                    error!(target: "receive", error = %e, "failed to accept receive response");
                    e
                })?;

            let streams_ids = streams
                .iter()
                .filter_map(|stream| stream.command_id().cloned())
                .collect::<Vec<_>>();

            let is_there_a_stream_has_no_command_id =
                streams.iter().any(|stream| stream.command_id().is_none());
            if is_there_a_stream_has_no_command_id {
                debug!(
                    target: "receive",
                    "stream without command_id found, should be runspace pool stream"
                );
                self.runspace_pool_desired_stream_is_pooling = false
            }

            debug!(
                target: "receive",
                stream_count = streams.len(),
                stream_command_ids = ?streams_ids,
                "processing streams"
            );

            let handle_pwsh_response = self.handle_pwsh_responses(streams).map_err(|e| {
                error!(target: "pwsh", error = %e, "failed to handle PowerShell responses");
                e
            })?;

            debug!(
                target: "pwsh",
                response_names = ?handle_pwsh_response.iter().map(|r| r.name()).collect::<Vec<_>>(),
                response_count = handle_pwsh_response.len(),
                "handled PowerShell responses"
            );

            result.extend(handle_pwsh_response.into_iter().map(|resp| resp.into()));

            if let Some(command_state) = command_state
                && command_state.is_done()
            {
                debug!(
                    target: "pipeline",
                    pipeline_id = ?command_state.command_id,
                    "command state done received, removing pipeline"
                );
                // If command state is done, we can remove the pipeline from the pool
                let pipeline = self.pipelines.remove(&command_state.command_id);
                if pipeline.is_some() {
                    result.push(AcceptResponsResult::PipelineFinished(PipelineHandle {
                        id: command_state.command_id,
                    }));
                }
            }

            let desired_streams = if !streams_ids.is_empty() {
                // find the intersetction of streams.id and self.pipelines.keys()
                let next_desired_streams = streams_ids.into_iter().filter(|stream| {
                    self.pipelines
                        .keys()
                        .any(|pipeline_id| pipeline_id == stream)
                });

                // keep unique stream with the same id
                let mut stream_set = HashSet::new();

                for stream in next_desired_streams {
                    stream_set.insert(stream);
                }

                stream_set
                    .into_iter()
                    .map(|stream| DesiredStream::new("stdout", stream.to_owned().into()))
                    .collect::<Vec<_>>()
            } else if !self.runspace_pool_desired_stream_is_pooling {
                self.runspace_pool_desired_stream_is_pooling = true;
                DesiredStream::runspace_pool_streams()
            } else {
                vec![]
            };

            if !desired_streams.is_empty() {
                result.push(AcceptResponsResult::ReceiveResponse { desired_streams });
            }
        }

        if soap_envelope.body.as_ref().command_response.is_some() {
            let pipeline_id = self.shell.accept_commannd_response(&soap_envelope)?;

            // We have received the pipeline creation response
            // 1. update the state of the pipeline
            // 2. fire receive request for the new pipeline
            self.pipelines
                .get_mut(&pipeline_id)
                .ok_or(crate::PwshCoreError::InvalidResponse(
                    "Pipeline not found for command response".into(),
                ))?
                .state = PsInvocationState::Running;

            result.push(AcceptResponsResult::ReceiveResponse {
                desired_streams: vec![DesiredStream::stdout_for_command(pipeline_id)],
            });
        }

        debug!(
            target: "accept_response",
            result_count = result.len(),
            result_types = ?result.iter().map(std::mem::discriminant).collect::<Vec<_>>(),
            "accept response results"
        );

        Ok(result)
    }

    pub(crate) fn init_pipeline(
        &mut self,
        uuid: Uuid,
    ) -> Result<PipelineHandle, crate::PwshCoreError> {
        if self.pipelines.contains_key(&uuid) {
            return Err(crate::PwshCoreError::InvalidState(
                "Pipeline with this UUID already exists",
            ));
        }

        self.pipelines.insert(uuid, Pipeline::new());
        Ok(PipelineHandle { id: uuid })
    }

    /// Fire create pipeline for a specific pipeline handle (used by service API)
    #[instrument(
        skip(self, responses),
        fields(
            response_count = responses.len(),
            processed_messages = 0u32
        )
    )]
    fn handle_pwsh_responses(
        &mut self,
        responses: Vec<crate::runspace::win_rs::Stream>,
    ) -> Result<Vec<PwshMessageResponse>, crate::PwshCoreError> {
        let mut result = Vec::new();
        let span = tracing::Span::current();
        let mut message_count = 0u32;

        for (stream_index, stream) in responses.into_iter().enumerate() {
            debug!(
                target: "stream",
                stream_index,
                stream_name = ?stream.name(),
                pipeline_id = ?stream.command_id(),
                "processing stream"
            );

            let messages = match self.defragmenter.defragment(stream.value()).map_err(|e| {
                error!(target: "defragment", stream_index, error = %e, "failed to defragment stream");
                e
            })? {
                fragmentation::DefragmentResult::Incomplete => {
                    debug!(target: "defragment", stream_index, "stream incomplete, continuing");
                    continue;
                }
                fragmentation::DefragmentResult::Complete(power_shell_remoting_messages) => {
                    debug!(
                        target: "defragment",
                        stream_index,
                        message_count = power_shell_remoting_messages.len(),
                        "stream complete"
                    );
                    power_shell_remoting_messages
                }
            };

            for (msg_index, message) in messages.into_iter().enumerate() {
                message_count += 1;
                span.record("processed_messages", message_count);

                let ps_value = message.parse_ps_message().map_err(|e| {
                    error!(
                        target: "ps_message",
                        stream_index,
                        msg_index,
                        error = %e,
                        "failed to parse PS message"
                    );
                    e
                })?;

                info!(
                    target: "ps_message",
                    message_type = ?message.message_type,
                    stream_index,
                    msg_index,
                    "parsed PS message"
                );

                match message.message_type {
                    ironposh_psrp::MessageType::SessionCapability => {
                        debug!(target: "session", "handling SessionCapability message");
                        self.handle_session_capability(ps_value).map_err(|e| {
                            error!(target: "session", error = %e, "failed to handle SessionCapability");
                            e
                        })?;
                    }
                    ironposh_psrp::MessageType::ApplicationPrivateData => {
                        debug!(target: "session", "handling ApplicationPrivateData message");
                        self.handle_application_private_data(ps_value)
                            .map_err(|e| {
                                error!(target: "session", error = %e, "failed to handle ApplicationPrivateData");
                                e
                            })?;
                    }
                    ironposh_psrp::MessageType::RunspacepoolState => {
                        debug!(target: "runspace", "handling RunspacepoolState message");
                        self.handle_runspacepool_state(ps_value).map_err(|e| {
                            error!(target: "runspace", error = %e, "failed to handle RunspacepoolState");
                            e
                        })?;
                    }
                    ironposh_psrp::MessageType::ProgressRecord => {
                        debug!(
                            target: "progress",
                            stream_name = ?stream.name(),
                            command_id = ?stream.command_id(),
                            "handling ProgressRecord message"
                        );
                        self.handle_progress_record(ps_value, stream.name(), stream.command_id())
                            .map_err(|e| {
                                error!(target: "progress", error = %e, "failed to handle ProgressRecord");
                                e
                            })?;
                    }
                    ironposh_psrp::MessageType::InformationRecord => {
                        debug!(
                            target: "information",
                            stream_name = ?stream.name(),
                            command_id = ?stream.command_id(),
                            "handling InformationRecord message"
                        );
                        self.handle_information_record(
                            ps_value,
                            stream.name(),
                            stream.command_id(),
                        )
                        .map_err(|e| {
                            error!(target: "information", error = %e, "failed to handle InformationRecord");
                            e
                        })?;
                    }
                    ironposh_psrp::MessageType::PipelineState => {
                        debug!(
                            target: "pipeline",
                            stream_name = ?stream.name(),
                            command_id = ?stream.command_id(),
                            "handling PipelineState message"
                        );
                        self.handle_pipeline_state(ps_value, stream.name(), stream.command_id())
                            .map_err(|e| {
                                error!(target: "pipeline", error = %e, "failed to handle PipelineState");
                                e
                            })?;
                    }
                    ironposh_psrp::MessageType::PipelineHostCall => {
                        debug!(
                            target: "host_call",
                            stream_name = ?stream.name(),
                            pipeline_id = ?stream.command_id(),
                            "handling PipelineHostCall message"
                        );

                        let host_call = self
                            .handle_pipeline_host_call(ps_value, stream.name(), stream.command_id())
                            .map_err(|e| {
                                error!(target: "host_call", error = %e, "failed to handle PipelineHostCall");
                                e
                            })?;
                        debug!(target: "host_call", host_call = ?host_call, "successfully created host call");
                        result.push(PwshMessageResponse::HostCall(host_call));
                        debug!(target: "host_call", result_len = result.len(), "pushed HostCall response");
                    }
                    ironposh_psrp::MessageType::PipelineOutput => {
                        debug!(
                            target: "pipeline_output",
                            stream_name = ?stream.name(),
                            command_id = ?stream.command_id(),
                            "handling PipelineOutput message"
                        );

                        let output = self.handle_pipeline_output(ps_value)?;

                        debug!(target: "pipeline_output", output = ?output, "successfully handled PipelineOutput");
                        result.push(PwshMessageResponse::PipelineOutput {
                            output,
                            handle: PipelineHandle {
                                id: *stream.command_id().ok_or(
                                    crate::PwshCoreError::InvalidResponse(
                                        "PipelineOutput message must have a command_id".into(),
                                    ),
                                )?,
                            },
                        });
                    }
                    _ => {
                        error!(
                            target: "ps_message",
                            message_type = ?message.message_type,
                            "received message type but no handler implemented"
                        );
                        todo!("Handle other message types as needed");
                    }
                }
            }
        }

        info!(
            target: "pwsh_responses",
            result_count = result.len(),
            total_messages_processed = message_count,
            "processed PowerShell responses"
        );
        Ok(result)
    }

    #[instrument(skip(self, session_capability), fields(protocol_version = tracing::field::Empty, ps_version = tracing::field::Empty))]
    fn handle_session_capability(
        &mut self,
        session_capability: PsValue,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(session_capability) = session_capability else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected SessionCapability as PsValue::Object".into(),
            ));
        };

        let session_capability = SessionCapability::try_from(session_capability)?;

        // Record the protocol and PS versions in the span
        let span = tracing::Span::current();
        span.record("protocol_version", &session_capability.protocol_version);
        span.record("ps_version", &session_capability.ps_version);

        debug!(
            target: "session",
            capability = ?session_capability,
            "received SessionCapability"
        );
        self.session_capability = Some(session_capability);
        Ok(())
    }

    #[instrument(skip(self, app_data))]
    fn handle_application_private_data(
        &mut self,
        app_data: PsValue,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(app_data) = app_data else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected ApplicationPrivateData as PsValue::Object".into(),
            ));
        };

        let app_data = ApplicationPrivateData::try_from(app_data)?;
        trace!(target: "session", app_data = ?app_data, "received ApplicationPrivateData");
        self.application_private_data = Some(app_data);
        Ok(())
    }

    #[instrument(skip(self, ps_value), fields(runspace_state = tracing::field::Empty))]
    fn handle_runspacepool_state(&mut self, ps_value: PsValue) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(runspacepool_state) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected RunspacepoolState as PsValue::Object".into(),
            ));
        };

        let runspacepool_state = RunspacePoolStateMessage::try_from(runspacepool_state)?;

        // Record the state in the span
        let span = tracing::Span::current();
        span.record(
            "runspace_state",
            format!("{:?}", runspacepool_state.runspace_state),
        );

        trace!(target: "runspace", state = ?runspacepool_state, "received RunspacePoolState");

        self.state = RunspacePoolState::from(&runspacepool_state.runspace_state);

        Ok(())
    }

    #[instrument(skip(self, ps_value), fields(stream_name, command_id = ?command_id))]
    fn handle_progress_record(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(progress_record) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected ProgressRecord as PsValue::Object".into(),
            ));
        };

        let progress_record = ironposh_psrp::ProgressRecord::try_from(progress_record)?;

        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        trace!(
            target: "progress",
            progress_record = ?progress_record,
            stream_name = stream_name,
            command_id = ?command_id,
            "received ProgressRecord"
        );

        // Find the pipeline by command_id
        let pipeline = self
            .pipelines
            .get_mut(command_id)
            .ok_or(PwshCoreError::InvalidResponse(
                "Pipeline not found for command_id".into(),
            ))?;

        pipeline.add_progress_record(progress_record);

        Ok(())
    }

    #[instrument(skip(self, ps_value, stream_name, command_id))]
    fn handle_information_record(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(info_record) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected InformationRecord as PsValue::Object".into(),
            ));
        };

        let info_record = ironposh_psrp::InformationRecord::try_from(info_record)?;
        trace!(
            ?info_record,
            stream_name = stream_name,
            command_id = ?command_id,
            "Received InformationRecord"
        );

        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        // Find the pipeline by command_id
        let pipeline = self
            .pipelines
            .get_mut(command_id)
            .ok_or(PwshCoreError::InvalidResponse(
                "Pipeline not found for command_id".into(),
            ))?;

        pipeline.add_information_record(info_record);

        Ok(())
    }

    #[instrument(skip(self, ps_value, stream_name, command_id))]
    fn handle_pipeline_state(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<(), crate::PwshCoreError> {
        let PsValue::Object(pipeline_state) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected PipelineState as PsValue::Object".into(),
            ));
        };

        let pipeline_state = ironposh_psrp::PipelineStateMessage::try_from(pipeline_state)?;
        trace!(
            ?pipeline_state,
            stream_name = stream_name,
            command_id = ?command_id,
            "Received PipelineState"
        );
        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        // Find the pipeline by command_id
        let pipeline = self
            .pipelines
            .get_mut(command_id)
            .ok_or(PwshCoreError::InvalidResponse(
                "Pipeline not found for command_id".into(),
            ))?;
        // Update the pipeline state
        pipeline.state = PsInvocationState::from(pipeline_state.pipeline_state);

        Ok(())
    }

    /// Invokes the specified pipeline and waits for its completion.
    ///
    /// This method will handle the entire PSRP message exchange:
    /// 1. Send the `CreatePipeline` message.
    /// 2. Send `Command`, `Send`, and `EndOfInput` messages.
    /// 3. Enter a loop to `Receive` and process responses.
    /// 4. Defragment and deserialize messages, updating the pipeline's state, output, and error streams.
    /// 5. Return the final output upon completion.
    pub fn invoke_pipeline_request(
        &mut self,
        handle: PipelineHandle,
    ) -> Result<String, PwshCoreError> {
        let pipeline = self
            .pipelines
            .get_mut(&handle.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;

        // Set pipeline state to Running
        pipeline.state = PsInvocationState::Running;
        info!(pipeline_id = %handle.id(), "Invoking pipeline");

        // Convert business pipeline to protocol pipeline and build CreatePipeline message
        let protocol_pipeline = pipeline.to_protocol_pipeline()?;
        let create_pipeline = CreatePipeline::builder()
            .power_shell(protocol_pipeline)
            .host_info(self.host_info.clone())
            .apartment_state(self.apartment_state)
            .build();

        debug!(?create_pipeline);

        let fragmented =
            self.fragmenter
                .fragment(&create_pipeline, self.id, Some(handle.id()), None)?;

        let arguments = fragmented
            .into_iter()
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))
            .collect::<Vec<_>>();

        let request = self.shell.create_pipeline_request(
            &self.connection,
            handle.id(),
            arguments,
            None,
            None,
        )?;

        Ok(request.into().to_xml_string()?)
    }

    #[instrument(skip_all)]
    pub fn handle_pipeline_host_call(
        &mut self,
        ps_value: PsValue,
        stream_name: &str,
        command_id: Option<&Uuid>,
    ) -> Result<HostCallRequest, crate::PwshCoreError> {
        let PsValue::Object(pipeline_host_call) = ps_value else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected PipelineHostCall as PsValue::Object".into(),
            ));
        };

        let pipeline_host_call = ironposh_psrp::PipelineHostCall::try_from(pipeline_host_call)?;

        debug!(
            ?pipeline_host_call,
            stream_name = stream_name,
            command_id = ?command_id,
            method_id = pipeline_host_call.method_id,
            method_name = pipeline_host_call.method_name,
            parameter_count = pipeline_host_call.parameters.len(),
            "Received PipelineHostCall"
        );

        // Question: Can we have a Optional command id here?
        let Some(command_id) = command_id else {
            return Err(PwshCoreError::InvalidResponse(
                "Expected command_id to be Some".into(),
            ));
        };

        Ok(HostCallRequest::from((
            &pipeline_host_call,
            HostCallScope::Pipeline {
                command_id: command_id.to_owned(),
            },
        )))
    }

    /// Send a pipeline host response to the server
    pub fn send_pipeline_host_response(
        &mut self,
        command_id: uuid::Uuid,
        host_response: ironposh_psrp::PipelineHostResponse,
    ) -> Result<String, PwshCoreError> {
        // Fragment the host response message
        let fragmented =
            self.fragmenter
                .fragment(&host_response, self.id, Some(command_id), None)?;

        // Encode fragments as base64
        let arguments = fragmented
            .into_iter()
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))
            .collect::<Vec<_>>();

        // Create WS-Man Send request (send data to stdin)
        let request =
            self.shell
                .send_data_request(&self.connection, Some(command_id), arguments)?;

        Ok(request.into().to_xml_string()?)
    }

    /// Send a runspace pool host response to the server
    pub fn send_runspace_pool_host_response(
        &mut self,
        host_response: ironposh_psrp::RunspacePoolHostResponse,
    ) -> Result<String, PwshCoreError> {
        // Fragment the host response message
        let fragmented = self.fragmenter.fragment(
            &host_response,
            self.id,
            None, // No command ID for runspace pool messages
            None,
        )?;

        // Encode fragments as base64
        let arguments = fragmented
            .into_iter()
            .map(|bytes| base64::engine::general_purpose::STANDARD.encode(&bytes[..]))
            .collect::<Vec<_>>();

        // Create WS-Man Send request (send data to stdin)
        let request = self.shell.send_data_request(
            &self.connection,
            None, // No command ID for runspace pool
            arguments,
        )?;

        Ok(request.into().to_xml_string()?)
    }

    pub fn handle_pipeline_output(
        &mut self,
        ps_value: PsValue,
    ) -> Result<PipelineOutput, PwshCoreError> {
        let pipeline_output = PipelineOutput::from(ps_value);

        Ok(pipeline_output)
    }

    pub(crate) fn add_command(
        &mut self,
        powershell: PipelineHandle,
        command: PipelineCommand,
    ) -> Result<(), PwshCoreError> {
        let pipeline = self
            .pipelines
            .get_mut(&powershell.id())
            .ok_or(PwshCoreError::InvalidState("Pipeline handle not found"))?;

        if pipeline.state != PsInvocationState::NotStarted {
            return Err(PwshCoreError::InvalidState(
                "Cannot add to a pipeline that has already been started",
            ));
        }

        pipeline.add_command(command);
        Ok(())
    }
}


--- File: crates/ironposh-client-core/src/runspace_pool/types.rs ---
use std::hash::Hash;

use crate::runspace_pool::PsInvocationState;

#[derive(Debug, Clone)]
pub struct PipelineRepresentation {
    pub id: uuid::Uuid,
    pub state: PsInvocationState,
}

impl PipelineRepresentation {
    pub fn new(id: uuid::Uuid) -> Self {
        PipelineRepresentation {
            id,
            state: PsInvocationState::NotStarted,
        }
    }

    pub fn id(&self) -> uuid::Uuid {
        self.id
    }
}

impl Hash for PipelineRepresentation {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}

impl PartialEq for PipelineRepresentation {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl Eq for PipelineRepresentation {}

pub struct Runspace {
    pub id: uuid::Uuid,
    pub state: super::enums::RunspacePoolState,
}


--- File: crates/ironposh-client-sync/Cargo.toml ---
[[bin]]
name = "ironposh-client-sync"
path = "src/main.rs"

[package]
name = "ironposh-client-sync"
version = "0.1.0"
edition = "2021"

[dependencies]
ironposh-client-core = { version = "0.1.0", path = "../ironposh-client-core" }
ironposh-psrp = { version = "0.1.0", path = "../ironposh-psrp" }
ureq = "2.10"
anyhow = "1.0"
regex = "1.0"
tracing = "0.1.41"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }
clap = { version = "4.5", features = ["derive"] }
uuid = { version = "1.18.0", features = ["v4"] }
tracing-appender = "0.2"
tracing-log = "0.2"



--- File: crates/ironposh-client-sync/src/config.rs ---
use clap::{Parser, ValueEnum};
use ironposh_client_core::{
    connector::{config::KerberosConfig, http::ServerAddress, ConnectorConfig, Scheme},
    Authentication, SspiAuthConfig,
};
use std::sync::OnceLock;
use tracing_log::LogTracer;
use tracing_subscriber::{fmt, prelude::*, registry::Registry, EnvFilter};

static LOG_GUARD: OnceLock<tracing_appender::non_blocking::WorkerGuard> = OnceLock::new();

/// Sets up a panic hook to ensure logs are flushed before the program exits.
fn setup_panic_hook() {
    std::panic::set_hook(Box::new(|panic_info| {
        // Log the panic information
        tracing::error!("A panic occurred: {}", panic_info);
    }));
}

/// PowerShell Remoting Client (Synchronous)
#[derive(Parser)]
#[command(version, about, long_about = None)]
pub struct Args {
    /// Server IP address to connect to
    #[arg(
        short,
        long,
        default_value = "IT-HELP-DC.ad.it-help.ninja",
        help = "Server IP address or hostname"
    )]
    pub server: String,

    /// Server port to connect to
    #[arg(short, long, default_value = "5985", help = "Server port")]
    pub port: u16,

    /// Username for authentication
    #[arg(
        short,
        long,
        default_value = "Administrator",
        help = "Username for authentication"
    )]
    pub username: String,

    /// Password for authentication
    #[arg(
        short = 'P',
        long,
        default_value = "DevoLabs123!",
        help = "Password for authentication"
    )]
    pub password: String,

    #[arg(
        short,
        long,
        help = "Optional domain for authentication",
        default_value = "ad.it-help.ninja"
    )]
    pub domain: String,

    #[arg(short, long, help = "Authentication method", default_value_t = AuthMethod::Basic)]
    pub auth_method: AuthMethod,

    /// Optional KDC URL for Kerberos authentication
    #[arg(
        long,
        help = "KDC URL for Kerberos authentication (e.g., ldap://dc.domain.com:389)"
    )]
    pub kdc_url: Option<String>,

    /// Optional client computer name for Kerberos authentication
    #[arg(long, help = "Client computer name for Kerberos authentication")]
    pub client_computer_name: Option<String>,

    /// Use HTTPS instead of HTTP
    #[arg(long, help = "Use HTTPS (default: HTTP)")]
    pub https: bool,

    /// Verbose logging (can be repeated for more verbosity)
    #[arg(short, long, action = clap::ArgAction::Count, help = "Increase logging verbosity")]
    pub verbose: u8,
}

#[derive(Debug, Clone, Copy, ValueEnum)]
pub enum AuthMethod {
    Basic,
    Ntlm,
    Kerberos,
    Negotiate,
}

impl std::fmt::Display for AuthMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AuthMethod::Basic => write!(f, "basic"),
            AuthMethod::Ntlm => write!(f, "ntlm"),
            AuthMethod::Kerberos => write!(f, "kerberos"),
            AuthMethod::Negotiate => write!(f, "negotiate"),
        }
    }
}

/// Initialize logging with file output and proper structured logging
pub fn init_logging(verbose_level: u8) -> anyhow::Result<()> {
    // Set up the panic hook to flush logs on panic
    setup_panic_hook();

    // Bridge logs from the `log` crate to `tracing`
    LogTracer::init().ok();

    let file = std::fs::File::create("winrm_client.log")?;
    let (nb_writer, guard) = tracing_appender::non_blocking(file);

    // Store the guard in a static OnceLock to ensure it lives for the duration of the program.
    if LOG_GUARD.set(guard).is_err() {
        // This case should ideally not happen in a single-threaded setup,
        // but it's good practice to handle it.
        tracing::warn!("LOG_GUARD was already set. This may indicate a problem in initialization.");
    }

    // Determine log level based on verbosity using global filters
    let filter_str = match verbose_level {
        0 => "info,ureq=error",
        1 => "debug,ureq=warn",
        2 => "trace,ureq=info",
        _ => "trace",
    };

    let env_filter = EnvFilter::new(filter_str);

    let subscriber = Registry::default().with(env_filter).with(
        fmt::layer()
            .with_writer(nb_writer)
            .with_target(true)
            .with_line_number(true)
            .with_file(true)
            .compact(),
    );

    tracing::subscriber::set_global_default(subscriber)?;

    // Immediately log something to confirm initialization.
    tracing::info!("Logging system initialized.");

    Ok(())
}

/// Create connector configuration from command line arguments
pub fn create_connector_config(args: &Args) -> Result<ConnectorConfig, anyhow::Error> {
    let server = ServerAddress::parse(&args.server)?;
    let scheme = if args.https {
        Scheme::Https
    } else {
        Scheme::Http
    };

    let domain = if args.domain.trim().is_empty() {
        None
    } else {
        Some(args.domain.as_str())
    };

    let auth = match args.auth_method {
        AuthMethod::Basic => Authentication::Basic {
            username: args.username.clone(),
            password: args.password.clone(),
        },
        AuthMethod::Ntlm => {
            let client_username = ironposh_client_core::credentials::ClientUserName::new(
                &args.username,
                domain.as_deref(),
            )?;
            let identity = ironposh_client_core::credentials::ClientAuthIdentity::new(
                client_username,
                args.password.clone(),
            );
            Authentication::Sspi(SspiAuthConfig::NTLM {
                target_name: args.server.clone(),
                identity,
            })
        }
        AuthMethod::Kerberos => {
            let client_username = ironposh_client_core::credentials::ClientUserName::new(
                &args.username,
                domain.as_deref(),
            )?;
            let identity = ironposh_client_core::credentials::ClientAuthIdentity::new(
                client_username,
                args.password.clone(),
            );
            Authentication::Sspi(SspiAuthConfig::Kerberos {
                target_name: args.server.clone(),
                identity,
                kerberos_config: KerberosConfig {
                    kdc_url: args.kdc_url.as_ref().and_then(|url| url.parse().ok()),
                    client_computer_name: args.client_computer_name.clone(),
                },
            })
        }
        AuthMethod::Negotiate => {
            let client_username = ironposh_client_core::credentials::ClientUserName::new(
                &args.username,
                domain.as_deref(),
            )?;
            let identity = ironposh_client_core::credentials::ClientAuthIdentity::new(
                client_username,
                args.password.clone(),
            );
            Authentication::Sspi(SspiAuthConfig::Negotiate {
                target_name: args.server.clone(),
                identity,
                kerberos_config: Some(KerberosConfig {
                    kdc_url: args.kdc_url.as_ref().and_then(|url| url.parse().ok()),
                    client_computer_name: args.client_computer_name.clone(),
                }),
            })
        }
    };

    Ok(ConnectorConfig {
        server: (server, args.port),
        scheme,
        authentication: auth,
        host_info: ironposh_psrp::HostInfo::builder()
            .is_host_null(false)
            .is_host_ui_null(true)
            .is_host_raw_ui_null(true)
            .build(),
    })
}


--- File: crates/ironposh-client-sync/src/connection.rs ---
use ironposh_client_core::connector::{
    auth_sequence::{AuthSequence, SecurityContextBuilderHolder},
    authenticator::SecContextMaybeInit,
    http::{HttpRequest, HttpResponse},
    Connector, ConnectorConfig, ConnectorStepResult,
};

pub trait HttpClient {
    fn send_request(
        &self,
        request: HttpRequest<String>,
    ) -> Result<HttpResponse<String>, anyhow::Error>;
}

pub struct RemotePowershell {
    active_session: ironposh_client_core::connector::active_session::ActiveSession,
    client: Box<dyn HttpClient>,
    next_request: ironposh_client_core::connector::http::HttpRequest<String>,
}

impl RemotePowershell {
    /// Establish connection to the PowerShell remote server
    pub fn open(
        config: ConnectorConfig,
        client: impl HttpClient + 'static,
    ) -> Result<Self, anyhow::Error> {
        let mut connector = Connector::new(config);
        let mut response = None;

        let (active_session, next_request) = loop {
            let step_result = connector.step(response.take())?;

            match step_result {
                ConnectorStepResult::SendBack(http_request) => {
                    response = Some(client.send_request(http_request)?);
                }
                ConnectorStepResult::SendBackError(e) => {
                    anyhow::bail!("Connection failed: {}", e);
                }
                ConnectorStepResult::Connected {
                    active_session,
                    next_receive_request,
                } => {
                    break (*active_session, next_receive_request);
                }
                ConnectorStepResult::Auth { mut sequence } => {
                    // Authentication sequence handling - mimic auth_sequence.rs pattern
                    let _final_token = loop {
                        let sec_ctx_init = {
                            let mut holder = SecurityContextBuilderHolder::new();
                            let result =
                                sequence.try_init_sec_context(response.as_ref(), &mut holder)?;

                            match result {
                                SecContextMaybeInit::Initialized(sec_context_init) => {
                                    sec_context_init
                                }
                                SecContextMaybeInit::RunGenerator {
                                    mut packet,
                                    mut generator_holder,
                                } => loop {
                                    let kdc_response = send_packet(packet)?;
                                    match AuthSequence::resume(generator_holder, kdc_response)? {
                                        SecContextMaybeInit::Initialized(sec_context_init) => {
                                            break sec_context_init;
                                        }
                                        SecContextMaybeInit::RunGenerator {
                                            packet: packet2,
                                            generator_holder: generator2,
                                        } => {
                                            packet = packet2;
                                            generator_holder = generator2;
                                        }
                                    }
                                },
                            }
                        };

                        let action = sequence.process_initialized_sec_context(sec_ctx_init)?;

                        match action {
                            ironposh_client_core::connector::auth_sequence::SecCtxInited::Continue(http_request) => {
                                response = Some(client.send_request(http_request)?);
                            }
                            ironposh_client_core::connector::auth_sequence::SecCtxInited::Done(token) => {
                                break token;
                            },
                        }
                    };

                    // After authentication is complete, continue with the connector step
                    response = None; // Reset response for next iteration
                }
            }
        };

        Ok(Self {
            active_session,
            client: Box::new(client),
            next_request,
        })
    }

    /// Extract the components for use in the main event loop
    pub fn into_components(
        self,
    ) -> (
        ironposh_client_core::connector::active_session::ActiveSession,
        ironposh_client_core::connector::http::HttpRequest<String>,
    ) {
        (self.active_session, self.next_request)
    }
}

fn send_packet(
    packet: ironposh_client_core::connector::NetworkRequest,
) -> Result<Vec<u8>, anyhow::Error> {
    use std::io::{Read, Write};
    use std::net::{TcpStream, UdpSocket};
    use std::time::Duration;

    match packet.protocol {
        ironposh_client_core::connector::NetworkProtocol::Tcp => {
            // TCP implementation for Kerberos KDC communication
            let host = packet.url.host_str()
                .ok_or_else(|| anyhow::anyhow!("Missing host in URL"))?;
            let port = packet.url.port()
                .ok_or_else(|| anyhow::anyhow!("Missing port in URL"))?;

            // Establish TCP connection to the KDC
            let mut stream = TcpStream::connect((host, port))
                .map_err(|e| anyhow::anyhow!("Failed to connect to KDC at {}:{}: {}", host, port, e))?;

            // Set timeouts for the connection
            stream.set_read_timeout(Some(Duration::from_secs(30)))
                .map_err(|e| anyhow::anyhow!("Failed to set read timeout: {}", e))?;
            stream.set_write_timeout(Some(Duration::from_secs(30)))
                .map_err(|e| anyhow::anyhow!("Failed to set write timeout: {}", e))?;

            // For Kerberos TCP transport (RFC 4120), the packet is prefixed with a 4-byte length field
            // in network byte order (big-endian)
            let packet_len = packet.data.len() as u32;
            let length_prefix = packet_len.to_be_bytes();

            // Send the length prefix followed by the packet data
            stream.write_all(&length_prefix)
                .map_err(|e| anyhow::anyhow!("Failed to write packet length: {}", e))?;
            stream.write_all(&packet.data)
                .map_err(|e| anyhow::anyhow!("Failed to write packet data: {}", e))?;
            stream.flush()
                .map_err(|e| anyhow::anyhow!("Failed to flush stream: {}", e))?;

            // Read the response length (4 bytes, big-endian)
            let mut length_buf = [0u8; 4];
            stream.read_exact(&mut length_buf)
                .map_err(|e| anyhow::anyhow!("Failed to read response length: {}", e))?;

            let response_len = u32::from_be_bytes(length_buf) as usize;

            // Validate response length to prevent excessive memory allocation
            if response_len > 65536 {  // 64KB max response size
                return Err(anyhow::anyhow!("Response too large: {} bytes", response_len));
            }

            // Read the response data
            let mut response_data = vec![0u8; response_len];
            stream.read_exact(&mut response_data)
                .map_err(|e| anyhow::anyhow!("Failed to read response data: {}", e))?;

            Ok(response_data)
        }
        
        ironposh_client_core::connector::NetworkProtocol::Udp => {
            // UDP implementation for Kerberos KDC communication
            let host = packet.url.host_str()
                .ok_or_else(|| anyhow::anyhow!("Missing host in URL"))?;
            let port = packet.url.port()
                .ok_or_else(|| anyhow::anyhow!("Missing port in URL"))?;

            // Create UDP socket
            let socket = UdpSocket::bind("0.0.0.0:0")
                .map_err(|e| anyhow::anyhow!("Failed to bind UDP socket: {}", e))?;

            // Set timeout for UDP operations
            socket.set_read_timeout(Some(Duration::from_secs(30)))
                .map_err(|e| anyhow::anyhow!("Failed to set UDP read timeout: {}", e))?;
            socket.set_write_timeout(Some(Duration::from_secs(30)))
                .map_err(|e| anyhow::anyhow!("Failed to set UDP write timeout: {}", e))?;

            // Connect to the KDC
            socket.connect((host, port))
                .map_err(|e| anyhow::anyhow!("Failed to connect UDP socket to {}:{}: {}", host, port, e))?;

            // For UDP, send packet data directly (no length prefix like TCP)
            socket.send(&packet.data)
                .map_err(|e| anyhow::anyhow!("Failed to send UDP packet: {}", e))?;

            // Read the response
            let mut response_data = vec![0u8; 65536]; // Max UDP packet size
            let bytes_received = socket.recv(&mut response_data)
                .map_err(|e| anyhow::anyhow!("Failed to receive UDP response: {}", e))?;

            response_data.truncate(bytes_received);
            Ok(response_data)
        }
        
        ironposh_client_core::connector::NetworkProtocol::Http => {
            // HTTP implementation for potential web-based authentication
            let request = ureq::post(packet.url.as_str())
                .set("Content-Type", "application/octet-stream")
                .set("User-Agent", "ironposh-client/1.0");

            let response = request.send_bytes(&packet.data)
                .map_err(|e| anyhow::anyhow!("HTTP request failed: {}", e))?;

            let mut response_data = Vec::new();
            response.into_reader().read_to_end(&mut response_data)
                .map_err(|e| anyhow::anyhow!("Failed to read HTTP response: {}", e))?;

            Ok(response_data)
        }
        
        ironposh_client_core::connector::NetworkProtocol::Https => {
            // HTTPS implementation for secure web-based authentication
            let request = ureq::post(packet.url.as_str())
                .set("Content-Type", "application/octet-stream")
                .set("User-Agent", "ironposh-client/1.0");

            let response = request.send_bytes(&packet.data)
                .map_err(|e| anyhow::anyhow!("HTTPS request failed: {}", e))?;

            let mut response_data = Vec::new();
            response.into_reader().read_to_end(&mut response_data)
                .map_err(|e| anyhow::anyhow!("Failed to read HTTPS response: {}", e))?;

            Ok(response_data)
        }
    }
}


--- File: crates/ironposh-client-sync/src/http_client.rs ---
use crate::connection::HttpClient;
use tracing::{debug, info};

pub struct UreqHttpClient;

impl HttpClient for UreqHttpClient {
    fn send_request(
        &self,
        request: ironposh_client_core::connector::http::HttpRequest<String>,
    ) -> Result<ironposh_client_core::connector::http::HttpResponse<String>, anyhow::Error> {
        make_http_request(&request)
    }
}

/// Make an HTTP request using ureq (synchronous)
pub fn make_http_request(
    request: &ironposh_client_core::connector::http::HttpRequest<String>,
) -> Result<ironposh_client_core::connector::http::HttpResponse<String>, anyhow::Error> {
    info!("Making HTTP request to: {}", request.url);
    debug!("Request headers: {:?}", request.headers);
    debug!(
        "Request body length: {:?}",
        request.body.as_ref().map(|b| b.len())
    );

    // Build the HTTP client request
    let mut ureq_request = match request.method {
        ironposh_client_core::connector::http::Method::Post => ureq::post(&request.url),
        ironposh_client_core::connector::http::Method::Get => ureq::get(&request.url),
        ironposh_client_core::connector::http::Method::Put => ureq::put(&request.url),
        ironposh_client_core::connector::http::Method::Delete => ureq::delete(&request.url),
    };

    // Add headers
    for (name, value) in &request.headers {
        ureq_request = ureq_request.set(name, value);
    }

    // Add cookie if present
    if let Some(cookie) = &request.cookie {
        ureq_request = ureq_request.set("Cookie", cookie);
    }

    // Make the request
    let response_result = if let Some(body) = &request.body {
        ureq_request.send_string(body)
    } else {
        ureq_request.call()
    };

    // Handle the response, including potential 401 authentication challenges
    let (status_code, headers, response_body) = match response_result {
        Ok(response) => {
            let status = response.status();
            let headers: Vec<(String, String)> = response
                .headers_names()
                .iter()
                .filter_map(|name| {
                    response
                        .header(name)
                        .map(|value| (name.clone(), value.to_string()))
                })
                .collect();
            let body = response.into_string()?;
            (status, headers, body)
        }
        Err(ureq::Error::Status(status, response)) => {
            // Handle status codes like 401 which are expected in authentication flows
            let headers: Vec<(String, String)> = response
                .headers_names()
                .iter()
                .filter_map(|name| {
                    response
                        .header(name)
                        .map(|value| (name.clone(), value.to_string()))
                })
                .collect();
            let body = response.into_string().unwrap_or_default();
            (status, headers, body)
        }
        Err(e) => {
            // For other errors (network issues, etc.), propagate them
            return Err(e.into());
        }
    };

    debug!("Response status: {}", status_code);
    debug!("Response headers: {:?}", headers);
    debug!("Response body length: {}", response_body.len());

    // Return as HttpResponse with actual response data
    Ok(ironposh_client_core::connector::http::HttpResponse {
        status_code: status_code as u16,
        headers,
        body: Some(response_body),
    })
}


--- File: crates/ironposh-client-sync/src/main.rs ---
mod config;
mod connection;
mod http_client;
mod network;
mod types;
mod user_input;

use anyhow::Context;
use clap::Parser;
use ironposh_client_core::connector::active_session::UserEvent;
use ironposh_client_core::connector::ActiveSessionOutput;
use std::sync::mpsc;
use std::thread;
use tracing::{error, info, instrument, warn};

use config::{create_connector_config, init_logging, Args};
use connection::RemotePowershell;
use http_client::UreqHttpClient;
use network::NetworkHandler;
use types::NextStep;
use user_input::UserInputHandler;

/// Establish connection to the PowerShell remote server
fn establish_connection(
    config: ironposh_client_core::connector::ConnectorConfig,
) -> anyhow::Result<(
    ironposh_client_core::connector::active_session::ActiveSession,
    ironposh_client_core::connector::http::HttpRequest<String>,
)> {
    let client = UreqHttpClient;
    let remote_ps = RemotePowershell::open(config, client)?;
    Ok(remote_ps.into_components())
}

#[instrument(name = "main", level = "info")]
fn main() -> anyhow::Result<()> {
    // Parse command line arguments
    let args = Args::parse();

    // Initialize logging. If it fails, we can't log, so just print and exit.
    if let Err(e) = init_logging(args.verbose) {
        eprintln!("Failed to initialize logging: {}", e);
        // Exit with a non-zero status code to indicate failure
        std::process::exit(1);
    }

    // Run the actual application logic and handle any errors
    if let Err(e) = run_app(&args) {
        // Log the error before exiting. This is crucial.
        error!("Application failed to run: {:?}", e);
        
        // The program will now exit, and the log buffer should be flushed upon exit.
        return Err(e);
    }

    Ok(())
}

/// The main application logic, extracted to a separate function.
fn run_app(args: &Args) -> anyhow::Result<()> {
    info!("Starting WinRM PowerShell client (Synchronous)");

    // Display connection information
    info!(
        server = %args.server,
        port = args.port,
        username = %args.username,
        scheme = %if args.https { "HTTPS" } else { "HTTP" },
        "connecting to server"
    );

    // Create configuration and establish connection
    let config = create_connector_config(args)?;
    let (active_session, next_request) = establish_connection(config)?;
    info!("Runspace pool is now open and ready for operations!");

    // Set up communication channels
    let (network_request_tx, network_request_rx) = mpsc::channel();
    let (network_response_tx, network_response_rx) = mpsc::channel();
    let (user_request_tx, user_request_rx) = mpsc::channel();
    let (user_event_tx, user_event_rx) = mpsc::channel();

    // Spawn network handler
    let mut network_handler = NetworkHandler::new(network_request_rx, network_response_tx);
    let network_handle = thread::spawn(move || {
        network_handler.run();
    });

    // Spawn user input/UI handler
    let mut user_input_handler = UserInputHandler::new(user_request_tx.clone(), user_event_rx);
    let user_handle = thread::spawn(move || {
        user_input_handler.run();
    });

    // Send initial network request
    network_request_tx
        .send(next_request)
        .context("Failed to send initial request")?;

    // Run the main event loop
    run_event_loop(
        active_session,
        network_response_rx,
        user_request_rx,
        network_request_tx,
        user_event_tx,
    )
    .inspect_err(|e| error!("Error in main event loop: {}", e))?;

    info!("Exiting main function");
    // Clean up threads (they will exit when channels are dropped)
    drop(network_handle);
    drop(user_handle);
    Ok(())
}

/// Main event loop that processes network responses and user requests
#[instrument(level = "info", skip_all, fields(iterations = 0u64))]
fn run_event_loop(
    mut active_session: ironposh_client_core::connector::active_session::ActiveSession,
    network_response_rx: mpsc::Receiver<
        ironposh_client_core::connector::http::HttpResponse<String>,
    >,
    user_request_rx: mpsc::Receiver<ironposh_client_core::connector::UserOperation>,
    network_request_tx: mpsc::Sender<ironposh_client_core::connector::http::HttpRequest<String>>,
    user_event_tx: mpsc::Sender<UserEvent>,
) -> anyhow::Result<()> {
    let span = tracing::Span::current();
    let mut iteration_count = 0u64;

    loop {
        iteration_count += 1;
        span.record("iterations", iteration_count);

        // Use select! equivalent for synchronous channels
        let next_step = select_sync(&network_response_rx, &user_request_rx)?;

        info!(next_step = %next_step, "processing step");

        let step_results = match next_step {
            NextStep::NetworkResponse(http_response) => {
                info!(
                    target: "network",
                    body_length = http_response.body.as_ref().map(|b| b.len()).unwrap_or(0),
                    "processing network response"
                );

                active_session
                    .accept_server_response(http_response)
                    .map_err(|e| {
                        error!(target: "network", error = %e, "failed to accept server response");
                        e
                    })
                    .context("Failed to accept server response")?
            }
            NextStep::UserRequest(user_operation) => {
                info!(target: "user", operation = ?user_operation, "processing user operation");

                vec![active_session
                    .accept_client_operation(*user_operation)
                    .map_err(|e| {
                        error!(target: "user", error = %e, "failed to accept user operation");
                        e
                    })
                    .context("Failed to accept user operation")?]
            }
        };

        info!(
            step_result_count = step_results.len(),
            "received server response, processing step results"
        );

        for step_result in step_results {
            info!(step_result = ?step_result, "processing step result");
            match step_result {
                ActiveSessionOutput::SendBack(http_requests) => {
                    info!(
                        target: "network",
                        request_count = http_requests.len(),
                        "sending HTTP requests"
                    );
                    for http_request in http_requests {
                        network_request_tx
                            .send(http_request)
                            .context("Failed to send HTTP request")?;
                    }
                }
                ActiveSessionOutput::SendBackError(e) => {
                    error!(target: "session", error = %e, "session step failed");
                    return Err(anyhow::anyhow!("Session step failed: {}", e));
                }
                ActiveSessionOutput::UserEvent(event) => {
                    info!(target: "user", event = ?event, "sending user event");
                    // Send all user events to the UI thread
                    if let Err(e) = user_event_tx.send(event) {
                        error!(target: "user", error = %e, "failed to send user event");
                    }
                }
                ActiveSessionOutput::HostCall(host_call) => {
                    info!(
                        target: "host",
                        method_name = %host_call.method_name,
                        call_id = host_call.call_id,
                        "received host call"
                    );

                    let method = host_call.get_param().map_err(|e| {
                        error!(target: "host", error = %e, "failed to parse host call parameters");
                        e
                    })?;

                    info!(target: "host", method = ?method, "processing host call method");

                    // Handle the host call and create a response
                    use ironposh_client_core::host::{HostCallMethodReturn, RawUIMethodReturn};

                    let response = match method {
                        // For GetBufferSize, return a default console buffer size
                        ironposh_client_core::host::HostCallMethodWithParams::RawUIMethod(
                            ironposh_client_core::host::RawUIMethodParams::GetBufferSize,
                        ) => {
                            info!(target: "host", method = "GetBufferSize", "returning default console size");
                            HostCallMethodReturn::RawUIMethod(RawUIMethodReturn::GetBufferSize(
                                120, 30,
                            ))
                        }

                        // For WriteProgress, just acknowledge (void return)
                        ironposh_client_core::host::HostCallMethodWithParams::UIMethod(
                            ironposh_client_core::host::UIMethodParams::WriteProgress(
                                source_id,
                                record,
                            ),
                        ) => {
                            info!(
                                target: "host",
                                method = "WriteProgress",
                                source_id = source_id,
                                record = %record,
                                "handling write progress"
                            );
                            HostCallMethodReturn::UIMethod(
                                ironposh_client_core::host::UIMethodReturn::WriteProgress,
                            )
                        }

                        // For other methods, return not implemented error for now
                        other => {
                            warn!(target: "host", method = ?other, "host call method not implemented");
                            HostCallMethodReturn::Error(
                                ironposh_client_core::host::HostError::NotImplemented,
                            )
                        }
                    };

                    // Submit the response
                    let host_response = host_call.submit_result(response);
                    info!(
                        target: "host",
                        call_id = host_response.call_id,
                        "created host call response"
                    );

                    // For now, we're not sending the response back yet - that requires more infrastructure
                    // TODO: Implement sending host call responses back to the server
                }
                ActiveSessionOutput::OperationSuccess => {
                    info!(target: "session", "operation completed successfully");
                }
            }
        }
    }
}

/// Synchronous select equivalent for two receivers
fn select_sync(
    network_rx: &mpsc::Receiver<ironposh_client_core::connector::http::HttpResponse<String>>,
    user_rx: &mpsc::Receiver<ironposh_client_core::connector::UserOperation>,
) -> anyhow::Result<NextStep> {
    use std::sync::mpsc::TryRecvError;

    loop {
        // Try to receive from network first
        match network_rx.try_recv() {
            Ok(response) => return Ok(NextStep::NetworkResponse(response)),
            Err(TryRecvError::Empty) => {
                // Try user channel
                match user_rx.try_recv() {
                    Ok(request) => return Ok(NextStep::UserRequest(Box::new(request))),
                    Err(TryRecvError::Empty) => {
                        // Both channels empty, wait a bit and try again
                        thread::sleep(std::time::Duration::from_millis(10));
                        continue;
                    }
                    Err(TryRecvError::Disconnected) => {
                        return Err(anyhow::anyhow!("User request channel disconnected"));
                    }
                }
            }
            Err(TryRecvError::Disconnected) => {
                return Err(anyhow::anyhow!("Network response channel disconnected"));
            }
        }
    }
}


--- File: crates/ironposh-client-sync/src/network.rs ---
use std::sync::mpsc;
use std::thread;
use tracing::{error, info_span};

use crate::http_client::make_http_request;

/// Network request handler (synchronous)
pub struct NetworkHandler {
    network_request_rx: mpsc::Receiver<ironposh_client_core::connector::http::HttpRequest<String>>,
    network_response_tx: mpsc::Sender<ironposh_client_core::connector::http::HttpResponse<String>>,
}

impl NetworkHandler {
    pub fn new(
        network_request_rx: mpsc::Receiver<
            ironposh_client_core::connector::http::HttpRequest<String>,
        >,
        network_response_tx: mpsc::Sender<
            ironposh_client_core::connector::http::HttpResponse<String>,
        >,
    ) -> Self {
        Self {
            network_request_rx,
            network_response_tx,
        }
    }

    pub fn run(&mut self) {
        let _span = info_span!("NetworkRequestHandler").entered();

        while let Ok(request) = self.network_request_rx.recv() {
            let network_response_tx = self.network_response_tx.clone();

            // Handle request in a separate thread to avoid blocking
            thread::spawn(move || match make_http_request(&request) {
                Ok(response) => {
                    if let Err(e) = network_response_tx.send(response) {
                        error!("Failed to send network response: {}", e);
                    }
                }
                Err(e) => {
                    error!("HTTP request failed: {}", e);
                }
            });
        }
    }
}


--- File: crates/ironposh-client-sync/src/types.rs ---
use std::fmt;

use ironposh_client_core::connector::UserOperation;

/// Represents the next step in the event loop
#[derive(Debug)]
pub enum NextStep {
    NetworkResponse(ironposh_client_core::connector::http::HttpResponse<String>),
    UserRequest(Box<UserOperation>),
}

impl fmt::Display for NextStep {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            NextStep::NetworkResponse(_) => write!(f, "NetworkResponse"),
            NextStep::UserRequest(_) => write!(f, "UserRequest"),
        }
    }
}


--- File: crates/ironposh-client-sync/src/user_input.rs ---
use ironposh_client_core::connector::active_session::PowershellOperations;
use ironposh_client_core::pipeline::PipelineCommand;
use ironposh_client_core::powershell::PipelineHandle;
use ironposh_client_core::connector::UserOperation;
use ironposh_psrp::PipelineOutput;
use regex::Regex;
use std::io::{self, Write};
use std::sync::mpsc;
use std::time::Duration;
use tracing::{error, info, instrument};
use uuid::Uuid;

/// Handle user input for PowerShell commands (synchronous)
pub struct UserInputHandler {
    user_request_tx: mpsc::Sender<UserOperation>,
    user_event_rx: mpsc::Receiver<ironposh_client_core::connector::active_session::UserEvent>,
}

impl UserInputHandler {
    pub fn new(
        user_request_tx: mpsc::Sender<UserOperation>,
        user_event_rx: mpsc::Receiver<ironposh_client_core::connector::active_session::UserEvent>,
    ) -> Self {
        Self {
            user_request_tx,
            user_event_rx,
        }
    }

    #[instrument(skip_all, name = "user_input_handler")]
    pub fn run(&mut self) {
        let stdin = io::stdin();
        let mut stdout = io::stdout();
        let mut pipeline: Option<PipelineHandle> = None;

        info!("starting user input handler");
        self.user_request_tx
            .send(UserOperation::CreatePipeline {
                uuid: uuid::Uuid::new_v4(),
            })
            .expect("Failed to send create pipeline request");

        loop {
            // Check for user events
            match self.process_user_events(&mut pipeline) {
                PipelineOperated::Continue => continue,
                PipelineOperated::KeepGoing => {}
            }

            print!("> ");
            stdout.flush().unwrap();
            let mut line = String::new();
            match stdin.read_line(&mut line) {
                Ok(0) => break, // EOF
                Ok(_) => {
                    let command = line.trim().to_string();
                    if command.to_lowercase() == "exit" {
                        info!("user requested exit");
                        break;
                    }

                    if command.is_empty() {
                        continue;
                    }
                    // Ensure we have a pipeline before executing the command

                    if let Some(pipeline_handle) = pipeline {
                        // Add the script to the pipeline
                        if let Err(e) = self.user_request_tx.send(UserOperation::OperatePipeline {
                            powershell: pipeline_handle,
                            operation: PowershellOperations::AddCommand {
                                command: PipelineCommand::new_script(command),
                            },
                        }) {
                            error!(error = %e, "failed to send operation");
                            break;
                        }

                        // Invoke the pipeline
                        if let Err(e) = self.user_request_tx.send(UserOperation::InvokePipeline {
                            powershell: pipeline_handle,
                        }) {
                            error!(error = %e, "failed to send invoke");
                            break;
                        }
                    }
                }
                Err(e) => {
                    error!(error = %e, "failed to read input");
                    break;
                }
            }
        }
    }

    #[instrument(skip_all)]
    fn process_user_events(&mut self, pipeline: &mut Option<PipelineHandle>) -> PipelineOperated {
        while let Ok(event) = self.user_event_rx.recv_timeout(Duration::from_millis(100)) {
            match event {
                ironposh_client_core::connector::active_session::UserEvent::PipelineCreated {
                    powershell,
                } => {
                    info!(pipeline_id = %powershell.id(), "pipeline created");
                    *pipeline = Some(powershell);
                    return PipelineOperated::KeepGoing;
                }
                ironposh_client_core::connector::active_session::UserEvent::PipelineFinished {
                    powershell,
                } => {
                    info!(pipeline_id = %powershell.id(), "pipeline finished");
                    if let Some(current_pipeline) = pipeline {
                        if *current_pipeline == powershell {
                            *pipeline = None;
                            self.user_request_tx
                                .send(UserOperation::CreatePipeline {
                                    uuid: Uuid::new_v4(),
                                })
                                .expect("Failed to send create pipeline request");
                        }
                    }
                }
                ironposh_client_core::connector::active_session::UserEvent::PipelineOutput {
                    output,
                    powershell,
                } => {
                    info!(pipeline_id = %powershell.id(), "pipeline output: {:?}", output);
                    if let Some(current_pipeline) = pipeline {
                        if *current_pipeline == powershell {
                            println!(
                                "{}",
                                format_pipeline_output(&output).unwrap_or_else(|e| {
                                    error!(error = %e, "failed to format pipeline output");
                                    "Error formatting output".to_string()
                                })
                            );
                        }
                    }
                }
            }
        }
        PipelineOperated::Continue
    }
}

fn format_pipeline_output(output: &PipelineOutput) -> Result<String, anyhow::Error> {
    let Some(output_str) = output.data.as_string() else {
        return Err(anyhow::anyhow!("Pipeline output is not a string"));
    };

    decode_escaped_ps_string(&output_str)
}

/// Decode PowerShell Remoting Protocol escape sequences, like _x000A_
/// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/301404a9-232f-439c-8644-1a213675bfac
fn decode_escaped_ps_string(input: &str) -> Result<String, anyhow::Error> {
    if input.is_empty() {
        return Ok(String::new());
    }

    // Split with capturing parentheses to include the separator in the resulting array
    let regex =
        Regex::new(r"(_x[0-9A-F]{4}_)").map_err(|e| anyhow::anyhow!("Regex error: {}", e))?;
    let parts: Vec<&str> = regex.split(input).collect();

    if parts.len() <= 1 {
        return Ok(input.to_string());
    }

    let mut result = String::new();
    let mut high_surrogate: Option<u16> = None;

    // We need to manually handle the split parts and captures
    let mut current_pos = 0;
    for captures in regex.find_iter(input) {
        // Add the text before the match
        if captures.start() > current_pos {
            result.push_str(&input[current_pos..captures.start()]);
            high_surrogate = None;
        }

        // Process the escaped sequence
        let escaped = captures.as_str();
        if let Some(hex_str) = escaped.strip_prefix("_x").and_then(|s| s.strip_suffix("_")) {
            match u16::from_str_radix(hex_str, 16) {
                Ok(code_unit) => {
                    if let Some(high) = high_surrogate {
                        // We have a high surrogate from before, try to form a surrogate pair
                        if (0xDC00..=0xDFFF).contains(&code_unit) {
                            // This is a low surrogate, form the pair
                            let code_point = 0x10000
                                + ((high as u32 - 0xD800) << 10)
                                + (code_unit as u32 - 0xDC00);
                            if let Some(ch) = char::from_u32(code_point) {
                                result.push(ch);
                            } else {
                                // Invalid code point, add the escaped sequence as-is
                                result.push_str(escaped);
                            }
                            high_surrogate = None;
                        } else {
                            // Not a low surrogate, add the previous high surrogate as-is and process this one
                            result.push_str("_x");
                            result.push_str(&format!("{high:04X}"));
                            result.push('_');

                            if (0xD800..=0xDBFF).contains(&code_unit) {
                                high_surrogate = Some(code_unit);
                            } else {
                                if let Some(ch) = char::from_u32(code_unit as u32) {
                                    result.push(ch);
                                } else {
                                    result.push_str(escaped);
                                }
                                high_surrogate = None;
                            }
                        }
                    } else if (0xD800..=0xDBFF).contains(&code_unit) {
                        // High surrogate, save it for the next iteration
                        high_surrogate = Some(code_unit);
                    } else {
                        // Regular character or low surrogate without high surrogate
                        if let Some(ch) = char::from_u32(code_unit as u32) {
                            result.push(ch);
                        } else {
                            // Invalid character, add the escaped sequence as-is
                            result.push_str(escaped);
                        }
                        high_surrogate = None;
                    }
                }
                Err(_) => {
                    // Invalid hex, add the escaped sequence as-is
                    result.push_str(escaped);
                    high_surrogate = None;
                }
            }
        } else {
            // Not a valid escape sequence, add as-is
            result.push_str(escaped);
            high_surrogate = None;
        }

        current_pos = captures.end();
    }

    // Add any remaining text after the last match
    if current_pos < input.len() {
        result.push_str(&input[current_pos..]);
    }

    // If we have an unmatched high surrogate at the end, add it as-is
    if let Some(high) = high_surrogate {
        result.push_str("_x");
        result.push_str(&format!("{high:04X}"));
        result.push('_');
    }

    Ok(result)
}

pub enum PipelineOperated {
    Continue,
    KeepGoing,
}


