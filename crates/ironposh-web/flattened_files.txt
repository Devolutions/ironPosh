--- File: crates/ironposh-web/src/client.rs ---
use crate::{
    error::WasmError, http_client::GatewayHttpViaWSClient, types::WasmWinRmConfig,
    WasmPowerShellStream,
};
use ironposh_async::RemoteAsyncPowershellClient;
use ironposh_client_core::connector::WinRmConfig;
use js_sys::Promise;
use url::Url;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::future_to_promise;

// Main PowerShell client
#[wasm_bindgen]
pub struct WasmPowerShellClient {
    client: RemoteAsyncPowershellClient,
}

#[wasm_bindgen]
impl WasmPowerShellClient {
    #[wasm_bindgen]
    pub fn connect(config: WasmWinRmConfig) -> Result<Self, WasmError> {
        let url = Url::parse(&config.gateway_url).map_err(|e| WasmError::UrlParseError {
            source: e,
            target: config.gateway_url.clone(),
        })?;

        let http_client = GatewayHttpViaWSClient::new(url, config.gateway_token.to_owned());
        let internal_config: WinRmConfig = config.into();
        let (client, task) = RemoteAsyncPowershellClient::open_task(internal_config, http_client);
        // Spawn background task
        wasm_bindgen_futures::spawn_local(async move {
            if let Err(e) = task.await {
                web_sys::console::error_1(&format!("Background task failed: {}", e).into());
            }
        });

        Ok(Self { client })
    }

    #[wasm_bindgen]
    pub async fn execute_command(
        &mut self,
        script: String,
    ) -> Result<WasmPowerShellStream, WasmError> {
        let stream = self.client.send_script(script).await?;

        let stream = crate::stream::WasmPowerShellStream::new(stream);
        Ok(stream)
    }

    #[wasm_bindgen]
    pub fn disconnect(&self) -> Promise {
        future_to_promise(async move { Ok(JsValue::NULL) })
    }
}


--- File: crates/ironposh-web/src/error.rs ---
use serde::{Deserialize, Serialize};
use tsify::Tsify;
use wasm_bindgen::JsValue;

#[derive(Debug, thiserror::Error)]
pub enum WasmError {
    #[error("IO Error: {0}")]
    IOError(String),

    #[error("Internal Error: {0}")]
    IronPoshError(#[from] anyhow::Error),

    #[error("Generic Error: {0}")]
    Generic(String),

    #[error("WebSocket Error: {0}")]
    WebSocket(String),

    #[error("internal powershell error: {0}")]
    PowerShellError(#[from] ironposh_psrp::PowerShellRemotingError),

    #[error("Serialization Error")]
    SerializationError(#[from] serde_wasm_bindgen::Error),

    #[error("URL Parse Error for target: {target}, source : {source}")]
    UrlParseError {
        source: url::ParseError,
        target: String,
    },
}

unsafe impl Send for WasmError {}
unsafe impl Sync for WasmError {}

impl WasmError {
    pub fn name(&self) -> &str {
        match self {
            WasmError::IOError(_) => "IOError",
            WasmError::IronPoshError(_) => "IronPoshError",
            WasmError::Generic(_) => "GenericError",
            WasmError::WebSocket(_) => "WebSocketError",
            WasmError::PowerShellError(_) => "PowerShellError",
            WasmError::SerializationError(_) => "SerializationError",
            WasmError::UrlParseError { .. } => "UrlParseError",
        }
    }
}

impl From<WasmError> for IronPoshError {
    fn from(value: WasmError) -> Self {
        IronPoshError {
            code: value.name().to_string(),
            message: value.to_string(),
        }
    }
}

impl From<WasmError> for JsValue {
    fn from(value: WasmError) -> Self {
        let api_error: IronPoshError = value.into();
        api_error.into()
    }
}

#[derive(Serialize, Deserialize, Tsify)]
#[tsify(from_wasm_abi, into_wasm_abi)]
pub struct IronPoshError {
    pub code: String,
    pub message: String,
}


--- File: crates/ironposh-web/src/types.rs ---
use ironposh_psrp::PipelineOutput;
use serde::{Deserialize, Serialize};
use tsify::Tsify;
use wasm_bindgen::{prelude::wasm_bindgen, JsValue};

use crate::error::WasmError;


// WASM-compatible structs with tsify for TypeScript generation
#[derive(Tsify, Serialize, Deserialize, Debug, Clone)]
#[tsify(into_wasm_abi, from_wasm_abi)]
pub struct WasmWinRmConfig {
    pub server: String,
    pub port: u16,
    pub use_https: bool,
    pub username: String,
    pub password: String,
    pub domain: Option<String>,
    pub locale: Option<String>,
    pub gateway_url: String,
    pub gateway_token: String,
}

#[derive(Tsify, Serialize, Deserialize, Debug, Clone)]
#[tsify(into_wasm_abi, from_wasm_abi)]
pub enum WasmPowerShellEvent {
    PipelineCreated { pipeline_id: String },
    PipelineFinished { pipeline_id: String },
    PipelineOutput { pipeline_id: String, data: String },
    PipelineError { pipeline_id: String, error: String },
}

#[derive(Tsify, Serialize, Deserialize, Debug, Clone)]
#[tsify(into_wasm_abi, from_wasm_abi)]
pub struct WasmHostCallEvent {
    pub call_id: String,
    pub call_type: String,
    pub message: String,
    pub options: Option<Vec<String>>,
}

// Opaque
#[wasm_bindgen]
pub struct WasmPipelineOutput {
    output: PipelineOutput,
}

#[wasm_bindgen]
impl WasmPipelineOutput {
    #[wasm_bindgen]
    pub fn to_formatted_string(&self) -> Result<String, WasmError> {
        Ok(self.output.format_as_displyable_string()?)
    }

    #[wasm_bindgen]
    pub fn to_object(&self) -> Result<JsValue, WasmError> {
        let obj = serde_wasm_bindgen::to_value(&self.output)?;
        Ok(obj)
    }
}


--- File: crates/ironposh-web/src/http_convert.rs ---
use anyhow::{Context, Result};
use ironposh_client_core::connector::http::{HttpBody, HttpRequest, HttpResponse, Method};

/// Serialize an HttpRequest to HTTP/1.1 wire format as bytes
pub fn serialize_http_request(request: &HttpRequest) -> Result<Vec<u8>> {
    let mut buffer = Vec::new();

    // Request line: METHOD PATH HTTP/1.1
    let method_str = match request.method {
        Method::Get => "GET",
        Method::Post => "POST",
        Method::Put => "PUT",
        Method::Delete => "DELETE",
    };

    // Parse URL to get path and host
    let url = url::Url::parse(&request.url).context("Failed to parse request URL")?;

    let path = if url.query().is_some() {
        format!("{}?{}", url.path(), url.query().unwrap())
    } else {
        url.path().to_string()
    };

    // Request line
    let request_line = format!("{} {} HTTP/1.1\r\n", method_str, path);
    buffer.extend_from_slice(request_line.as_bytes());

    // Host header (required for HTTP/1.1)
    if let Some(host) = url.host_str() {
        let host_header = if let Some(port) = url.port() {
            format!("Host: {}:{}\r\n", host, port)
        } else {
            format!("Host: {}\r\n", host)
        };
        buffer.extend_from_slice(host_header.as_bytes());
    }

    // Headers
    for (name, value) in &request.headers {
        let header_line = format!("{}: {}\r\n", name, value);
        buffer.extend_from_slice(header_line.as_bytes());
    }

    // Cookie header if present
    if let Some(cookie) = &request.cookie {
        let cookie_line = format!("Cookie: {}\r\n", cookie);
        buffer.extend_from_slice(cookie_line.as_bytes());
    }

    // Body handling
    if let Some(body) = &request.body {
        match body {
            HttpBody::Text(text) => {
                let content_length = format!("Content-Length: {}\r\n", text.len());
                buffer.extend_from_slice(content_length.as_bytes());
                buffer.extend_from_slice(b"\r\n");
                buffer.extend_from_slice(text.as_bytes());
                return Ok(buffer);
            }
            HttpBody::Encrypted(bytes) => {
                let content_length = format!("Content-Length: {}\r\n", bytes.len());
                buffer.extend_from_slice(content_length.as_bytes());
                buffer.extend_from_slice(b"\r\n");
                buffer.extend_from_slice(bytes);
                return Ok(buffer);
            }
            HttpBody::Xml(xml) => {
                let content_length = format!("Content-Length: {}\r\n", xml.len());
                buffer.extend_from_slice(content_length.as_bytes());
                buffer.extend_from_slice(b"\r\n");
                buffer.extend_from_slice(xml.as_bytes());
                return Ok(buffer);
            }
            HttpBody::None => {
                // No body content
            }
        };
    }

    // No body - just end headers
    buffer.extend_from_slice(b"\r\n");

    Ok(buffer)
}

/// Deserialize HTTP/1.1 wire format bytes to HttpResponse
pub fn deserialize_http_response(bytes: &[u8]) -> Result<HttpResponse> {
    // Find the end of headers (double CRLF)
    let header_end = bytes
        .windows(4)
        .position(|window| window == b"\r\n\r\n")
        .context("Failed to find end of headers in HTTP response")?;

    let header_section = &bytes[..header_end];
    let body_start = header_end + 4;

    // Parse headers as UTF-8
    let header_str = std::str::from_utf8(header_section)
        .context("Failed to parse HTTP response headers as UTF-8")?;

    let mut lines = header_str.lines();

    // Parse status line: HTTP/1.1 200 OK
    let status_line = lines
        .next()
        .context("Missing status line in HTTP response")?;

    let status_code = status_line
        .split_whitespace()
        .nth(1)
        .and_then(|code| code.parse::<u16>().ok())
        .context("Failed to parse status code from status line")?;

    // Parse headers
    let mut headers = Vec::new();
    let mut content_type = None;

    for line in lines {
        if line.is_empty() {
            continue;
        }

        if let Some((name, value)) = line.split_once(':') {
            let name = name.trim().to_string();
            let value = value.trim().to_string();

            // Track content-type for body parsing
            if name.eq_ignore_ascii_case("content-type") {
                content_type = Some(value.clone());
            }

            headers.push((name, value));
        }
    }

    // Parse body
    let body_bytes = &bytes[body_start..];

    // Determine if we should treat as encrypted based on content-type
    let body = if let Some(ct) = &content_type {
        if ct.contains("application/soap+xml")
            || ct.contains("application/octet-stream")
            || ct.contains("multipart/encrypted")
        {
            // Could be encrypted SOAP - check if it's valid UTF-8
            if let Ok(text) = std::str::from_utf8(body_bytes) {
                HttpBody::Text(text.to_string())
            } else {
                HttpBody::Encrypted(body_bytes.to_vec())
            }
        } else {
            // Text-based content type
            let text = std::str::from_utf8(body_bytes)
                .context("Failed to parse response body as UTF-8")?;
            HttpBody::Text(text.to_string())
        }
    } else {
        // No content-type, try to parse as UTF-8, otherwise treat as encrypted
        if let Ok(text) = std::str::from_utf8(body_bytes) {
            HttpBody::Text(text.to_string())
        } else {
            HttpBody::Encrypted(body_bytes.to_vec())
        }
    };

    Ok(HttpResponse {
        status_code,
        headers,
        body,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialize_simple_get() {
        let request = HttpRequest {
            method: Method::Get,
            url: "http://example.com/path".to_string(),
            headers: vec![("User-Agent".to_string(), "test".to_string())],
            cookie: None,
            body: None,
        };

        let bytes = serialize_http_request(&request).unwrap();
        let result = String::from_utf8(bytes).unwrap();

        assert!(result.starts_with("GET /path HTTP/1.1\r\n"));
        assert!(result.contains("Host: example.com\r\n"));
        assert!(result.contains("User-Agent: test\r\n"));
    }

    #[test]
    fn test_serialize_post_with_body() {
        let request = HttpRequest {
            method: Method::Post,
            url: "http://example.com/api".to_string(),
            headers: vec![("Content-Type".to_string(), "text/plain".to_string())],
            cookie: None,
            body: Some(HttpBody::Text("test body".to_string())),
        };

        let bytes = serialize_http_request(&request).unwrap();
        let result = String::from_utf8(bytes).unwrap();

        assert!(result.starts_with("POST /api HTTP/1.1\r\n"));
        assert!(result.contains("Content-Length: 9\r\n"));
        assert!(result.ends_with("test body"));
    }

    #[test]
    fn test_deserialize_response() {
        let raw = b"HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 5\r\n\r\nhello";

        let response = deserialize_http_response(raw).unwrap();

        assert_eq!(response.status_code, 200);
        assert_eq!(response.body.as_str().unwrap(), "hello");
    }
}


--- File: crates/ironposh-web/src/utils.rs ---
pub fn set_panic_hook() {
    console_error_panic_hook::set_once();
}


--- File: crates/ironposh-web/src/websocket.rs ---
use futures::{SinkExt, StreamExt};
use gloo_net::websocket::{futures::WebSocket, Message};
use url::Url;

use crate::error::WasmError;
pub struct WebsocketStream {
    tx: futures::stream::SplitSink<WebSocket, Message>,
    rx: futures::stream::SplitStream<WebSocket>,
}

impl WebsocketStream {
    pub fn new(url: Url) -> Result<Self, WasmError> {
        let s = url.as_str().to_string();
        let ws = WebSocket::open(&s)
            .map_err(|e| WasmError::IOError(format!("Failed to open WebSocket: {e:?}")))?;
        let (tx, rx) = ws.split(); // ← consumes, no Clone needed
        Ok(Self { tx, rx })
    }

    /// Sends text. If the socket is still CONNECTING, this `await` blocks until it's OPEN.
    pub async fn send_text(&mut self, s: impl Into<String>) -> Result<(), WasmError> {
        self.tx
            .send(Message::Text(s.into()))
            .await
            .map_err(|e| WasmError::WebSocket(format!("send failed: {e:?}")))
    }

    pub async fn send_bytes(&mut self, bytes: impl AsRef<[u8]>) -> Result<(), WasmError> {
        self.tx
            .send(Message::Bytes(bytes.as_ref().to_vec()))
            .await
            .map_err(|e| WasmError::WebSocket(format!("send failed: {e:?}")))
    }

    /// Waits for the next incoming message (or end-of-stream).
    pub async fn recv(&mut self) -> Option<Result<Message, WasmError>> {
        match self.rx.next().await {
            Some(Ok(m)) => Some(Ok(m)),
            Some(Err(e)) => Some(Err(WasmError::WebSocket(format!("recv error: {e:?}")))),
            None => None, // closed
        }
    }

    /// Graceful close (sends a close frame).
    pub async fn close(mut self) -> Result<(), WasmError> {
        self.tx
            .close()
            .await
            .map_err(|e| WasmError::WebSocket(format!("close failed: {e:?}")))
    }
}


--- File: crates/ironposh-web/src/stream.rs ---
use std::convert::TryInto;

use futures::{channel::mpsc::Receiver, StreamExt};
use ironposh_client_core::connector::active_session::UserEvent;
use js_sys::Promise;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::future_to_promise;

use crate::{error::WasmError, WasmPowerShellEvent};

// PowerShell stream wrapper - this needs to be a simple struct
#[wasm_bindgen]
pub struct WasmPowerShellStream {
    // We'll use interior mutability pattern
    inner: Receiver<UserEvent>,
}

impl WasmPowerShellStream {
    pub(crate) fn new(receiver: Receiver<UserEvent>) -> Self {
        Self { inner: receiver }
    }
}

#[wasm_bindgen]
impl WasmPowerShellStream {
    #[wasm_bindgen]
    pub async fn next(&mut self) -> Result<Option<WasmPowerShellEvent>, WasmError> {
        let event = self.inner.next().await;
        if let Some(event) = event {
            let wasm_powershell_event: WasmPowerShellEvent = event.try_into()?;
            return Ok(Some(wasm_powershell_event));
        }
        Ok(None)
    }
}


--- File: crates/ironposh-web/src/lib.rs ---
use wasm_bindgen::prelude::*;

pub mod client;
pub mod conversions;
pub mod error;
pub mod http_client;
pub mod http_convert;
pub mod stream;
pub mod types;
pub mod websocket;

// Re-export the main types for JS/TS
pub use client::WasmPowerShellClient;
pub use stream::WasmPowerShellStream;
pub use types::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
pub fn set_panic_hook() {
    console_error_panic_hook::set_once();
}


--- File: crates/ironposh-web/Cargo.toml ---
[package]
name = "ironposh-web"
version = "0.1.0"
authors = ["irving ou <jou@devolutions.net>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]


[dependencies]
wasm-bindgen = "0.2.84"
console_error_panic_hook = { version = "0.1" }
tsify = { version = "0.5.5", features = ["js"] }
serde = { version = "1.0.227", features = ["derive"] }
wasm-bindgen-futures = "0.4.54"
ironposh-async = { path = "../ironposh-async" }
ironposh-client-core = { path = "../ironposh-client-core" }
ironposh-psrp = { path = "../ironposh-psrp" }
js-sys = "0.3.81"
web-sys = { version = "0.3.81", features = ["console", "Request", "RequestInit", "RequestMode", "Response", "Headers", "Window"] }
tracing-wasm = "0.2.1"
getrandom = { version = "0.2", features = ["js"] }
anyhow = "1.0"
futures = "0.3"
wee_alloc = { version = "0.4", optional = true }
gloo-net = { version = "0.6.0", features = ["websocket"] }
uuid = { version = "1.18.1", features = ["v4"] }
thiserror = "2.0.16"
url = "2.5.7"
tracing = "0.1.41"
serde-wasm-bindgen = "0.6.5"

[features]
default = []
wee_alloc = ["dep:wee_alloc"]

[dev-dependencies]
wasm-bindgen-test = "0.3.34"

[profile.release]
# Tell `rustc` to optimize for small code size.
opt-level = "s"


--- File: crates/ironposh-web/tests/web.rs ---
//! Test suite for the Web and headless browsers.

#![cfg(target_arch = "wasm32")]

extern crate wasm_bindgen_test;
use wasm_bindgen_test::*;

wasm_bindgen_test_configure!(run_in_browser);

#[wasm_bindgen_test]
fn pass() {
    assert_eq!(1 + 1, 2);
}


--- File: crates/ironposh-web/flattened_files.txt ---
--- File: crates/ironposh-web/src/client.rs ---
use crate::{
    error::WasmError, http_client::GatewayHttpViaWSClient, types::WasmWinRmConfig,
    WasmPowerShellStream,
};
use ironposh_async::RemoteAsyncPowershellClient;
use ironposh_client_core::connector::WinRmConfig;
use js_sys::Promise;
use url::Url;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::future_to_promise;

// Main PowerShell client
#[wasm_bindgen]
pub struct WasmPowerShellClient {
    client: RemoteAsyncPowershellClient,
}

#[wasm_bindgen]
impl WasmPowerShellClient {
    #[wasm_bindgen]
    pub fn connect(config: WasmWinRmConfig) -> Result<Self, WasmError> {
        let url = Url::parse(&config.gateway_url).map_err(|e| WasmError::UrlParseError {
            source: e,
            target: config.gateway_url.clone(),
        })?;

        let http_client = GatewayHttpViaWSClient::new(url, config.gateway_token.to_owned());
        let internal_config: WinRmConfig = config.into();
        let (client, task) = RemoteAsyncPowershellClient::open_task(internal_config, http_client);
        // Spawn background task
        wasm_bindgen_futures::spawn_local(async move {
            if let Err(e) = task.await {
                web_sys::console::error_1(&format!("Background task failed: {}", e).into());
            }
        });

        Ok(Self { client })
    }

    #[wasm_bindgen]
    pub async fn execute_command(
        &mut self,
        script: String,
    ) -> Result<WasmPowerShellStream, WasmError> {
        let stream = self.client.send_script(script).await?;

        let stream = crate::stream::WasmPowerShellStream::new(stream);
        Ok(stream)
    }

    #[wasm_bindgen]
    pub fn disconnect(&self) -> Promise {
        future_to_promise(async move { Ok(JsValue::NULL) })
    }
}


--- File: crates/ironposh-web/src/error.rs ---
use serde::{Deserialize, Serialize};
use tsify::Tsify;
use wasm_bindgen::JsValue;

#[derive(Debug, thiserror::Error)]
pub enum WasmError {
    #[error("IO Error: {0}")]
    IOError(String),

    #[error("Internal Error: {0}")]
    IronPoshError(#[from] anyhow::Error),

    #[error("Generic Error: {0}")]
    Generic(String),

    #[error("WebSocket Error: {0}")]
    WebSocket(String),

    #[error("internal powershell error: {0}")]
    PowerShellError(#[from] ironposh_psrp::PowerShellRemotingError),

    #[error("Serialization Error")]
    SerializationError(#[from] serde_wasm_bindgen::Error),

    #[error("URL Parse Error for target: {target}, source : {source}")]
    UrlParseError {
        source: url::ParseError,
        target: String,
    },
}

unsafe impl Send for WasmError {}
unsafe impl Sync for WasmError {}

impl WasmError {
    pub fn name(&self) -> &str {
        match self {
            WasmError::IOError(_) => "IOError",
            WasmError::IronPoshError(_) => "IronPoshError",
            WasmError::Generic(_) => "GenericError",
            WasmError::WebSocket(_) => "WebSocketError",
            WasmError::PowerShellError(_) => "PowerShellError",
            WasmError::SerializationError(_) => "SerializationError",
            WasmError::UrlParseError { .. } => "UrlParseError",
        }
    }
}

impl From<WasmError> for IronPoshError {
    fn from(value: WasmError) -> Self {
        IronPoshError {
            code: value.name().to_string(),
            message: value.to_string(),
        }
    }
}

impl From<WasmError> for JsValue {
    fn from(value: WasmError) -> Self {
        let api_error: IronPoshError = value.into();
        api_error.into()
    }
}

#[derive(Serialize, Deserialize, Tsify)]
#[tsify(from_wasm_abi, into_wasm_abi)]
pub struct IronPoshError {
    pub code: String,
    pub message: String,
}


--- File: crates/ironposh-web/src/types.rs ---
use ironposh_psrp::PipelineOutput;
use serde::{Deserialize, Serialize};
use tsify::Tsify;
use wasm_bindgen::{prelude::wasm_bindgen, JsValue};

use crate::error::WasmError;


// WASM-compatible structs with tsify for TypeScript generation
#[derive(Tsify, Serialize, Deserialize, Debug, Clone)]
#[tsify(into_wasm_abi, from_wasm_abi)]
pub struct WasmWinRmConfig {
    pub server: String,
    pub port: u16,
    pub use_https: bool,
    pub username: String,
    pub password: String,
    pub domain: Option<String>,
    pub locale: Option<String>,
    pub gateway_url: String,
    pub gateway_token: String,
}

#[derive(Tsify, Serialize, Deserialize, Debug, Clone)]
#[tsify(into_wasm_abi, from_wasm_abi)]
pub enum WasmPowerShellEvent {
    PipelineCreated { pipeline_id: String },
    PipelineFinished { pipeline_id: String },
    PipelineOutput { pipeline_id: String, data: String },
    PipelineError { pipeline_id: String, error: String },
}

#[derive(Tsify, Serialize, Deserialize, Debug, Clone)]
#[tsify(into_wasm_abi, from_wasm_abi)]
pub struct WasmHostCallEvent {
    pub call_id: String,
    pub call_type: String,
    pub message: String,
    pub options: Option<Vec<String>>,
}

// Opaque
#[wasm_bindgen]
pub struct WasmPipelineOutput {
    output: PipelineOutput,
}

#[wasm_bindgen]
impl WasmPipelineOutput {
    #[wasm_bindgen]
    pub fn to_formatted_string(&self) -> Result<String, WasmError> {
        Ok(self.output.format_as_displyable_string()?)
    }

    #[wasm_bindgen]
    pub fn to_object(&self) -> Result<JsValue, WasmError> {
        let obj = serde_wasm_bindgen::to_value(&self.output)?;
        Ok(obj)
    }
}


--- File: crates/ironposh-web/src/http_convert.rs ---
use anyhow::{Context, Result};
use ironposh_client_core::connector::http::{HttpBody, HttpRequest, HttpResponse, Method};

/// Serialize an HttpRequest to HTTP/1.1 wire format as bytes
pub fn serialize_http_request(request: &HttpRequest) -> Result<Vec<u8>> {
    let mut buffer = Vec::new();

    // Request line: METHOD PATH HTTP/1.1
    let method_str = match request.method {
        Method::Get => "GET",
        Method::Post => "POST",
        Method::Put => "PUT",
        Method::Delete => "DELETE",
    };

    // Parse URL to get path and host
    let url = url::Url::parse(&request.url).context("Failed to parse request URL")?;

    let path = if url.query().is_some() {
        format!("{}?{}", url.path(), url.query().unwrap())
    } else {
        url.path().to_string()
    };

    // Request line
    let request_line = format!("{} {} HTTP/1.1\r\n", method_str, path);
    buffer.extend_from_slice(request_line.as_bytes());

    // Host header (required for HTTP/1.1)
    if let Some(host) = url.host_str() {
        let host_header = if let Some(port) = url.port() {
            format!("Host: {}:{}\r\n", host, port)
        } else {
            format!("Host: {}\r\n", host)
        };
        buffer.extend_from_slice(host_header.as_bytes());
    }

    // Headers
    for (name, value) in &request.headers {
        let header_line = format!("{}: {}\r\n", name, value);
        buffer.extend_from_slice(header_line.as_bytes());
    }

    // Cookie header if present
    if let Some(cookie) = &request.cookie {
        let cookie_line = format!("Cookie: {}\r\n", cookie);
        buffer.extend_from_slice(cookie_line.as_bytes());
    }

    // Body handling
    if let Some(body) = &request.body {
        match body {
            HttpBody::Text(text) => {
                let content_length = format!("Content-Length: {}\r\n", text.len());
                buffer.extend_from_slice(content_length.as_bytes());
                buffer.extend_from_slice(b"\r\n");
                buffer.extend_from_slice(text.as_bytes());
                return Ok(buffer);
            }
            HttpBody::Encrypted(bytes) => {
                let content_length = format!("Content-Length: {}\r\n", bytes.len());
                buffer.extend_from_slice(content_length.as_bytes());
                buffer.extend_from_slice(b"\r\n");
                buffer.extend_from_slice(bytes);
                return Ok(buffer);
            }
            HttpBody::Xml(xml) => {
                let content_length = format!("Content-Length: {}\r\n", xml.len());
                buffer.extend_from_slice(content_length.as_bytes());
                buffer.extend_from_slice(b"\r\n");
                buffer.extend_from_slice(xml.as_bytes());
                return Ok(buffer);
            }
            HttpBody::None => {
                // No body content
            }
        };
    }

    // No body - just end headers
    buffer.extend_from_slice(b"\r\n");

    Ok(buffer)
}

/// Deserialize HTTP/1.1 wire format bytes to HttpResponse
pub fn deserialize_http_response(bytes: &[u8]) -> Result<HttpResponse> {
    // Find the end of headers (double CRLF)
    let header_end = bytes
        .windows(4)
        .position(|window| window == b"\r\n\r\n")
        .context("Failed to find end of headers in HTTP response")?;

    let header_section = &bytes[..header_end];
    let body_start = header_end + 4;

    // Parse headers as UTF-8
    let header_str = std::str::from_utf8(header_section)
        .context("Failed to parse HTTP response headers as UTF-8")?;

    let mut lines = header_str.lines();

    // Parse status line: HTTP/1.1 200 OK
    let status_line = lines
        .next()
        .context("Missing status line in HTTP response")?;

    let status_code = status_line
        .split_whitespace()
        .nth(1)
        .and_then(|code| code.parse::<u16>().ok())
        .context("Failed to parse status code from status line")?;

    // Parse headers
    let mut headers = Vec::new();
    let mut content_type = None;

    for line in lines {
        if line.is_empty() {
            continue;
        }

        if let Some((name, value)) = line.split_once(':') {
            let name = name.trim().to_string();
            let value = value.trim().to_string();

            // Track content-type for body parsing
            if name.eq_ignore_ascii_case("content-type") {
                content_type = Some(value.clone());
            }

            headers.push((name, value));
        }
    }

    // Parse body
    let body_bytes = &bytes[body_start..];

    // Determine if we should treat as encrypted based on content-type
    let body = if let Some(ct) = &content_type {
        if ct.contains("application/soap+xml")
            || ct.contains("application/octet-stream")
            || ct.contains("multipart/encrypted")
        {
            // Could be encrypted SOAP - check if it's valid UTF-8
            if let Ok(text) = std::str::from_utf8(body_bytes) {
                HttpBody::Text(text.to_string())
            } else {
                HttpBody::Encrypted(body_bytes.to_vec())
            }
        } else {
            // Text-based content type
            let text = std::str::from_utf8(body_bytes)
                .context("Failed to parse response body as UTF-8")?;
            HttpBody::Text(text.to_string())
        }
    } else {
        // No content-type, try to parse as UTF-8, otherwise treat as encrypted
        if let Ok(text) = std::str::from_utf8(body_bytes) {
            HttpBody::Text(text.to_string())
        } else {
            HttpBody::Encrypted(body_bytes.to_vec())
        }
    };

    Ok(HttpResponse {
        status_code,
        headers,
        body,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialize_simple_get() {
        let request = HttpRequest {
            method: Method::Get,
            url: "http://example.com/path".to_string(),
            headers: vec![("User-Agent".to_string(), "test".to_string())],
            cookie: None,
            body: None,
        };

        let bytes = serialize_http_request(&request).unwrap();
        let result = String::from_utf8(bytes).unwrap();

        assert!(result.starts_with("GET /path HTTP/1.1\r\n"));
        assert!(result.contains("Host: example.com\r\n"));
        assert!(result.contains("User-Agent: test\r\n"));
    }

    #[test]
    fn test_serialize_post_with_body() {
        let request = HttpRequest {
            method: Method::Post,
            url: "http://example.com/api".to_string(),
            headers: vec![("Content-Type".to_string(), "text/plain".to_string())],
            cookie: None,
            body: Some(HttpBody::Text("test body".to_string())),
        };

        let bytes = serialize_http_request(&request).unwrap();
        let result = String::from_utf8(bytes).unwrap();

        assert!(result.starts_with("POST /api HTTP/1.1\r\n"));
        assert!(result.contains("Content-Length: 9\r\n"));
        assert!(result.ends_with("test body"));
    }

    #[test]
    fn test_deserialize_response() {
        let raw = b"HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 5\r\n\r\nhello";

        let response = deserialize_http_response(raw).unwrap();

        assert_eq!(response.status_code, 200);
        assert_eq!(response.body.as_str().unwrap(), "hello");
    }
}


--- File: crates/ironposh-web/src/utils.rs ---
pub fn set_panic_hook() {
    console_error_panic_hook::set_once();
}


--- File: crates/ironposh-web/src/websocket.rs ---


--- File: crates/ironposh-web/src/http_client.rs ---
use std::rc::Rc;

use anyhow::Result;
use futures::{lock::Mutex, SinkExt, StreamExt};
use gloo_net::websocket::futures::WebSocket;
use ironposh_async::HttpClient;
use ironposh_client_core::connector::{
    authenticator::SecContextMaybeInit,
    conntion_pool::{ConnectionId, SecContextInited, TrySend},
    http::{HttpRequest, HttpRequestAction, HttpResponse, HttpResponseTargeted},
};
use tracing::info;

use crate::{
    error::WasmError,
    http_convert::{deserialize_http_response, serialize_http_request},
};


// HTTP client implementation for WASM
pub(crate) struct GatewayHttpViaWSClient {
    gateway_url: url::Url,
    connection_map: Rc<Mutex<std::collections::HashMap<ConnectionId, WebsocketStream>>>,
    // We here assume that the token is short lived but can be reused for multiple connections in parallel
    token: String,
}

impl GatewayHttpViaWSClient {
    pub fn new(gateway_url: url::Url, token: String) -> Self {
        Self {
            gateway_url,
            connection_map: Rc::new(Mutex::new(std::collections::HashMap::new())),
            token,
        }
    }
}

impl HttpClient for GatewayHttpViaWSClient {
    async fn send_request(&self, try_send: TrySend) -> anyhow::Result<HttpResponseTargeted> {
        match try_send {
            TrySend::JustSend { request, conn_id } => {
                let response = self.send_http_request(request, &conn_id).await;
                response.map(|resp| HttpResponseTargeted::new(resp, conn_id, None))
            }
            TrySend::AuthNeeded { mut auth_sequence } => {
                info!("starting authentication sequence");
                let mut auth_response: Option<HttpResponse> = None;

                loop {
                    // 1) Initialize security context
                    let (seq, mut holder) = auth_sequence.prepare();
                    let init =
                        match seq.try_init_sec_context(auth_response.as_ref(), &mut holder)? {
                            SecContextMaybeInit::Initialized(sec) => sec,
                            SecContextMaybeInit::RunGenerator { .. } => {
                                todo!("Kerbero not supported in WASM yet");
                            }
                        };

                    // 2) Process initialized context → either Continue (send another token) or Done
                    match auth_sequence.process_sec_ctx_init(init)? {
                        SecContextInited::Continue { request, sequence } => {
                            info!("continuing authentication sequence");
                            let HttpRequestAction {
                                connection_id,
                                request,
                            } = request;
                            let response = self.send_http_request(request, &connection_id).await?;
                            auth_response = Some(response);
                            auth_sequence = sequence;
                        }

                        SecContextInited::SendRequest {
                            request,
                            authenticated_http_channel_cert,
                        } => {
                            info!(
                                "authentication sequence complete, sending final encrypted request"
                            );
                            let HttpRequestAction {
                                connection_id,
                                request,
                            } = request;

                            // Send the final (sealed) request
                            let resp = self.send_http_request(request, &connection_id).await?;

                            // Return targeted response WITH the provider attached
                            info!("authentication sequence successful");
                            return Ok(HttpResponseTargeted::new(
                                resp,
                                connection_id,
                                Some(authenticated_http_channel_cert),
                            ));
                        }
                    }
                }
            }
        }
    }
}

impl GatewayHttpViaWSClient {
    async fn send_http_request(
        &self,
        req: HttpRequest,
        con_id: &ConnectionId,
    ) -> Result<HttpResponse> {
        let mut map = self.connection_map.lock().await;
        let stream = if let Some(stream) = map.get_mut(con_id) {
            stream
        } else {
            // Create new WebSocket connection
            let url = self.gateway_url.clone();

            let stream = WebsocketStream::new(url)?;
            map.insert(*con_id, stream);
            map.get_mut(con_id).unwrap()
        };

        stream.send_http(req).await
    }
}

pub struct WebsocketStream {
    ws: WebSocket,
}

unsafe impl Send for WebsocketStream {}

impl WebsocketStream {
    async fn send_http(&mut self, request: HttpRequest) -> Result<HttpResponse> {
        // The Gateway relays HTTP requests over WebSocket to TCP, so we can assume that we are working on TCP directly
        // Serialize the HTTP request to HTTP/1.1 wire format
        let http_request_bytes = serialize_http_request(&request)
            .map_err(|e| WasmError::IOError(format!("Failed to serialize HTTP request: {}", e)))?;

        info!(
            method = ?request.method,
            url = %request.url,
            bytes_length = http_request_bytes.len(),
            "sending HTTP request over WebSocket"
        );

        // Send the serialized HTTP request over WebSocket
        self.ws
            .send(gloo_net::websocket::Message::Bytes(http_request_bytes))
            .await
            .map_err(|e| {
                WasmError::IOError(format!(
                    "Failed to send HTTP request over WebSocket: {:?}",
                    e
                ))
            })?;

        // Wait for the response from the gateway
        let message = self.ws.next().await.ok_or(WasmError::IOError(
            "WebSocket closed before receiving response".to_string(),
        ))??;

        // Extract bytes from the WebSocket message
        let response_bytes = match message {
            gloo_net::websocket::Message::Bytes(bytes) => bytes,
            gloo_net::websocket::Message::Text(text) => {
                return Err(WasmError::IOError(format!(
                    "Expected binary WebSocket message, got text: {}",
                    text
                ))
                .into());
            }
        };

        info!(
            response_bytes_length = response_bytes.len(),
            "received HTTP response over WebSocket"
        );

        // Deserialize the HTTP response from HTTP/1.1 wire format
        let response = deserialize_http_response(&response_bytes).map_err(|e| {
            WasmError::IOError(format!("Failed to deserialize HTTP response: {}", e))
        })?;

        info!(
            status_code = response.status_code,
            "HTTP response deserialized successfully"
        );

        Ok(response)
    }
}

impl WebsocketStream {
    pub fn new(url: url::Url) -> Result<Self, WasmError> {
        let ws = WebSocket::open(url.as_str())
            .map_err(|e| WasmError::IOError(format!("Failed to open WebSocket: {:?}", e)))?;

        Ok(Self { ws })
    }
}

/// It's wasm, it will never be sent across threads, we are safe
unsafe impl Sync for GatewayHttpViaWSClient {}
/// It's wasm, it will never be sent across threads, we are safe
unsafe impl Send for GatewayHttpViaWSClient {}


--- File: crates/ironposh-web/src/conversions.rs ---
use std::convert::TryFrom;

use crate::types::{WasmPowerShellEvent, WasmWinRmConfig};
use ironposh_client_core::{
    connector::active_session::UserEvent,
    connector::{config::AuthenticatorConfig, http::ServerAddress, Scheme, WinRmConfig},
};
use ironposh_psrp::messages::init_runspace_pool::{HostDefaultData, HostInfo, Size};

// Convert WASM config to internal config
impl From<WasmWinRmConfig> for WinRmConfig {
    fn from(config: WasmWinRmConfig) -> Self {
        WinRmConfig {
            server: (
                ServerAddress::parse(&config.server).expect("Invalid server address"),
                config.port,
            ),
            scheme: if config.use_https {
                Scheme::Https
            } else {
                Scheme::Http
            },
            authentication: AuthenticatorConfig::Basic {
                username: config.username,
                password: config.password,
            },
            host_info: HostInfo::builder()
                .host_default_data(
                    HostDefaultData::builder()
                        .buffer_size(Size {
                            width: 120,
                            height: 30,
                        })
                        .window_size(Size {
                            width: 120,
                            height: 30,
                        })
                        .max_window_size(Size {
                            width: 120,
                            height: 30,
                        })
                        .max_physical_window_size(Size {
                            width: 120,
                            height: 30,
                        })
                        .build(),
                )
                .build(),
        }
    }
}

// Convert internal UserEvent to WASM event
impl TryFrom<UserEvent> for WasmPowerShellEvent {
    type Error = crate::error::WasmError;
    fn try_from(value: UserEvent) -> Result<Self, Self::Error> {
        let res = match value {
            UserEvent::PipelineCreated { pipeline } => WasmPowerShellEvent::PipelineCreated {
                pipeline_id: pipeline.id().to_string(),
            },
            UserEvent::PipelineFinished { pipeline } => WasmPowerShellEvent::PipelineFinished {
                pipeline_id: pipeline.id().to_string(),
            },
            UserEvent::PipelineOutput { pipeline, output } => WasmPowerShellEvent::PipelineOutput {
                pipeline_id: pipeline.id().to_string(),
                data: output.format_as_displyable_string()?,
            },
            UserEvent::ErrorRecord {
                error_record,
                handle,
            } => WasmPowerShellEvent::PipelineError {
                pipeline_id: handle.id().to_string(),
                error: format!("{:?}", error_record),
            },
        };

        Ok(res)
    }
}



