use std::{collections::BTreeMap, fmt::Display};

use serde::{Deserialize, Serialize};

use super::{Container, PsEnums, PsPrimitiveValue, PsProperty, PsType};

/*
https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/3e107e78-3f28-4f85-9e25-493fd9b09726
The <Obj> element can include the following subelements in any order.
    Type names (section 2.2.5.2.3).
    ToString (section 2.2.5.2.4).
    Element generated by one of the following:
        Value of a primitive type (when the Complex Object is an Extended Primitive Object) (section 2.2.5.2.5).
        Contents of known containers (section 2.2.5.2.6).
        Contents of enums (section 2.2.5.2.7).
    Adapted Properties (section 2.2.5.2.8).
    Extended properties (section 2.2.5.2.9).

*/
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Default, Serialize, Deserialize)]
pub struct ComplexObject {
    pub type_def: Option<PsType>,
    pub to_string: Option<String>,
    pub content: ComplexObjectContent,
    pub adapted_properties: BTreeMap<String, PsProperty>,
    pub extended_properties: BTreeMap<String, PsProperty>,
}

impl Display for ComplexObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(to_string) = &self.to_string {
            // For some types, the ToString is enough. But for others, like FileSystemInfo,
            // it's not. We will have a special formatting for well-known types.
            if let Some(type_def) = &self.type_def {
                if type_def
                    .type_names
                    .iter()
                    .any(|t| t.as_ref() == "System.IO.FileSystemInfo")
                {
                    // This is a FileSystemInfo object, let's format it better.
                } else {
                    return write!(f, "{to_string}");
                }
            } else {
                return write!(f, "{to_string}");
            }
        }

        // Fallback to a property-based representation
        writeln!(f, "@{{")?;
        for prop in self.adapted_properties.values() {
            writeln!(f, "  {} = {}", prop.name, prop.value)?;
        }
        for prop in self.extended_properties.values() {
            writeln!(f, "  {} = {}", prop.name, prop.value)?;
        }
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Default, Serialize, Deserialize)]
pub enum ComplexObjectContent {
    /// If the Complex Object being serialized is an Extended Primitive Object, then the value of the primitive type is serialized as described in section 2.2.5.1.
    ///Example (compare with the serialization of a string without notes in section 2.2.5.1.1):
    ///
    ///     <Obj RefId="RefId-0">
    ///       <S>This is a string</S>
    ///       <MS>
    ///         <S N="Note1">My note</S>
    ///       </MS>
    ///     </Obj>
    ExtendedPrimitive(PsPrimitiveValue),
    Container(Container),
    PsEnums(PsEnums),
    #[default]
    Standard,
}

impl Display for ComplexObjectContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ComplexObjectContent::ExtendedPrimitive(p) => p.fmt(f),
            ComplexObjectContent::Container(c) => c.fmt(f),
            ComplexObjectContent::PsEnums(e) => e.fmt(f),
            ComplexObjectContent::Standard => write!(f, "System.Object"), // Fallback
        }
    }
}
